
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model ShowGuest
 * 
 */
export type ShowGuest = $Result.DefaultSelection<Prisma.$ShowGuestPayload>
/**
 * Model Guest
 * 
 */
export type Guest = $Result.DefaultSelection<Prisma.$GuestPayload>
/**
 * Model SocialLink
 * 
 */
export type SocialLink = $Result.DefaultSelection<Prisma.$SocialLinkPayload>
/**
 * Model Show
 * 
 */
export type Show = $Result.DefaultSelection<Prisma.$ShowPayload>
/**
 * Model Transcript
 * 
 */
export type Transcript = $Result.DefaultSelection<Prisma.$TranscriptPayload>
/**
 * Model TranscriptUtterance
 * 
 */
export type TranscriptUtterance = $Result.DefaultSelection<Prisma.$TranscriptUtterancePayload>
/**
 * Model TranscriptUtteranceWord
 * 
 */
export type TranscriptUtteranceWord = $Result.DefaultSelection<Prisma.$TranscriptUtteranceWordPayload>
/**
 * Model AiShowNote
 * 
 */
export type AiShowNote = $Result.DefaultSelection<Prisma.$AiShowNotePayload>
/**
 * Model AiSummaryEntry
 * 
 */
export type AiSummaryEntry = $Result.DefaultSelection<Prisma.$AiSummaryEntryPayload>
/**
 * Model AiTweet
 * 
 */
export type AiTweet = $Result.DefaultSelection<Prisma.$AiTweetPayload>
/**
 * Model Link
 * 
 */
export type Link = $Result.DefaultSelection<Prisma.$LinkPayload>
/**
 * Model AiGuest
 * 
 */
export type AiGuest = $Result.DefaultSelection<Prisma.$AiGuestPayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model Video
 * 
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model Playlist
 * 
 */
export type Playlist = $Result.DefaultSelection<Prisma.$PlaylistPayload>
/**
 * Model PlaylistOnVideo
 * 
 */
export type PlaylistOnVideo = $Result.DefaultSelection<Prisma.$PlaylistOnVideoPayload>
/**
 * Model RemotePlaylist
 * 
 */
export type RemotePlaylist = $Result.DefaultSelection<Prisma.$RemotePlaylistPayload>
/**
 * Model ShowVideo
 * 
 */
export type ShowVideo = $Result.DefaultSelection<Prisma.$ShowVideoPayload>
/**
 * Model UserSubmission
 * 
 */
export type UserSubmission = $Result.DefaultSelection<Prisma.$UserSubmissionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ThemeStatus: {
  PUBLISHED: 'PUBLISHED',
  UNPUBLISHED: 'UNPUBLISHED'
};

export type ThemeStatus = (typeof ThemeStatus)[keyof typeof ThemeStatus]


export const ShowType: {
  HASTY: 'HASTY',
  TASTY: 'TASTY',
  SUPPER: 'SUPPER',
  SPECIAL: 'SPECIAL'
};

export type ShowType = (typeof ShowType)[keyof typeof ShowType]


export const UserSubmissionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED'
};

export type UserSubmissionStatus = (typeof UserSubmissionStatus)[keyof typeof UserSubmissionStatus]


export const UserSubmissionType: {
  POTLUCK: 'POTLUCK',
  SPOOKY: 'SPOOKY',
  GUEST: 'GUEST',
  FEEDBACK: 'FEEDBACK',
  OTHER: 'OTHER',
  OSS: 'OSS'
};

export type UserSubmissionType = (typeof UserSubmissionType)[keyof typeof UserSubmissionType]

}

export type ThemeStatus = $Enums.ThemeStatus

export const ThemeStatus: typeof $Enums.ThemeStatus

export type ShowType = $Enums.ShowType

export const ShowType: typeof $Enums.ShowType

export type UserSubmissionStatus = $Enums.UserSubmissionStatus

export const UserSubmissionStatus: typeof $Enums.UserSubmissionStatus

export type UserSubmissionType = $Enums.UserSubmissionType

export const UserSubmissionType: typeof $Enums.UserSubmissionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.showGuest`: Exposes CRUD operations for the **ShowGuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShowGuests
    * const showGuests = await prisma.showGuest.findMany()
    * ```
    */
  get showGuest(): Prisma.ShowGuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guest`: Exposes CRUD operations for the **Guest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guests
    * const guests = await prisma.guest.findMany()
    * ```
    */
  get guest(): Prisma.GuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialLink`: Exposes CRUD operations for the **SocialLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialLinks
    * const socialLinks = await prisma.socialLink.findMany()
    * ```
    */
  get socialLink(): Prisma.SocialLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.show`: Exposes CRUD operations for the **Show** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shows
    * const shows = await prisma.show.findMany()
    * ```
    */
  get show(): Prisma.ShowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcript`: Exposes CRUD operations for the **Transcript** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transcripts
    * const transcripts = await prisma.transcript.findMany()
    * ```
    */
  get transcript(): Prisma.TranscriptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcriptUtterance`: Exposes CRUD operations for the **TranscriptUtterance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranscriptUtterances
    * const transcriptUtterances = await prisma.transcriptUtterance.findMany()
    * ```
    */
  get transcriptUtterance(): Prisma.TranscriptUtteranceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transcriptUtteranceWord`: Exposes CRUD operations for the **TranscriptUtteranceWord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TranscriptUtteranceWords
    * const transcriptUtteranceWords = await prisma.transcriptUtteranceWord.findMany()
    * ```
    */
  get transcriptUtteranceWord(): Prisma.TranscriptUtteranceWordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiShowNote`: Exposes CRUD operations for the **AiShowNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiShowNotes
    * const aiShowNotes = await prisma.aiShowNote.findMany()
    * ```
    */
  get aiShowNote(): Prisma.AiShowNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiSummaryEntry`: Exposes CRUD operations for the **AiSummaryEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiSummaryEntries
    * const aiSummaryEntries = await prisma.aiSummaryEntry.findMany()
    * ```
    */
  get aiSummaryEntry(): Prisma.AiSummaryEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiTweet`: Exposes CRUD operations for the **AiTweet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiTweets
    * const aiTweets = await prisma.aiTweet.findMany()
    * ```
    */
  get aiTweet(): Prisma.AiTweetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.link`: Exposes CRUD operations for the **Link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Links
    * const links = await prisma.link.findMany()
    * ```
    */
  get link(): Prisma.LinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiGuest`: Exposes CRUD operations for the **AiGuest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiGuests
    * const aiGuests = await prisma.aiGuest.findMany()
    * ```
    */
  get aiGuest(): Prisma.AiGuestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlist`: Exposes CRUD operations for the **Playlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Playlists
    * const playlists = await prisma.playlist.findMany()
    * ```
    */
  get playlist(): Prisma.PlaylistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playlistOnVideo`: Exposes CRUD operations for the **PlaylistOnVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaylistOnVideos
    * const playlistOnVideos = await prisma.playlistOnVideo.findMany()
    * ```
    */
  get playlistOnVideo(): Prisma.PlaylistOnVideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.remotePlaylist`: Exposes CRUD operations for the **RemotePlaylist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RemotePlaylists
    * const remotePlaylists = await prisma.remotePlaylist.findMany()
    * ```
    */
  get remotePlaylist(): Prisma.RemotePlaylistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.showVideo`: Exposes CRUD operations for the **ShowVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShowVideos
    * const showVideos = await prisma.showVideo.findMany()
    * ```
    */
  get showVideo(): Prisma.ShowVideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSubmission`: Exposes CRUD operations for the **UserSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubmissions
    * const userSubmissions = await prisma.userSubmission.findMany()
    * ```
    */
  get userSubmission(): Prisma.UserSubmissionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    Session: 'Session',
    ShowGuest: 'ShowGuest',
    Guest: 'Guest',
    SocialLink: 'SocialLink',
    Show: 'Show',
    Transcript: 'Transcript',
    TranscriptUtterance: 'TranscriptUtterance',
    TranscriptUtteranceWord: 'TranscriptUtteranceWord',
    AiShowNote: 'AiShowNote',
    AiSummaryEntry: 'AiSummaryEntry',
    AiTweet: 'AiTweet',
    Link: 'Link',
    AiGuest: 'AiGuest',
    Topic: 'Topic',
    Video: 'Video',
    Playlist: 'Playlist',
    PlaylistOnVideo: 'PlaylistOnVideo',
    RemotePlaylist: 'RemotePlaylist',
    ShowVideo: 'ShowVideo',
    UserSubmission: 'UserSubmission'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "userRole" | "session" | "showGuest" | "guest" | "socialLink" | "show" | "transcript" | "transcriptUtterance" | "transcriptUtteranceWord" | "aiShowNote" | "aiSummaryEntry" | "aiTweet" | "link" | "aiGuest" | "topic" | "video" | "playlist" | "playlistOnVideo" | "remotePlaylist" | "showVideo" | "userSubmission"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      ShowGuest: {
        payload: Prisma.$ShowGuestPayload<ExtArgs>
        fields: Prisma.ShowGuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShowGuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowGuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShowGuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowGuestPayload>
          }
          findFirst: {
            args: Prisma.ShowGuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowGuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShowGuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowGuestPayload>
          }
          findMany: {
            args: Prisma.ShowGuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowGuestPayload>[]
          }
          create: {
            args: Prisma.ShowGuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowGuestPayload>
          }
          createMany: {
            args: Prisma.ShowGuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShowGuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowGuestPayload>
          }
          update: {
            args: Prisma.ShowGuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowGuestPayload>
          }
          deleteMany: {
            args: Prisma.ShowGuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShowGuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShowGuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowGuestPayload>
          }
          aggregate: {
            args: Prisma.ShowGuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShowGuest>
          }
          groupBy: {
            args: Prisma.ShowGuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShowGuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShowGuestCountArgs<ExtArgs>
            result: $Utils.Optional<ShowGuestCountAggregateOutputType> | number
          }
        }
      }
      Guest: {
        payload: Prisma.$GuestPayload<ExtArgs>
        fields: Prisma.GuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          findFirst: {
            args: Prisma.GuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          findMany: {
            args: Prisma.GuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>[]
          }
          create: {
            args: Prisma.GuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          createMany: {
            args: Prisma.GuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          update: {
            args: Prisma.GuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          deleteMany: {
            args: Prisma.GuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPayload>
          }
          aggregate: {
            args: Prisma.GuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuest>
          }
          groupBy: {
            args: Prisma.GuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuestCountArgs<ExtArgs>
            result: $Utils.Optional<GuestCountAggregateOutputType> | number
          }
        }
      }
      SocialLink: {
        payload: Prisma.$SocialLinkPayload<ExtArgs>
        fields: Prisma.SocialLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          findFirst: {
            args: Prisma.SocialLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          findMany: {
            args: Prisma.SocialLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>[]
          }
          create: {
            args: Prisma.SocialLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          createMany: {
            args: Prisma.SocialLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocialLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          update: {
            args: Prisma.SocialLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          deleteMany: {
            args: Prisma.SocialLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialLinkPayload>
          }
          aggregate: {
            args: Prisma.SocialLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialLink>
          }
          groupBy: {
            args: Prisma.SocialLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialLinkCountArgs<ExtArgs>
            result: $Utils.Optional<SocialLinkCountAggregateOutputType> | number
          }
        }
      }
      Show: {
        payload: Prisma.$ShowPayload<ExtArgs>
        fields: Prisma.ShowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowPayload>
          }
          findFirst: {
            args: Prisma.ShowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowPayload>
          }
          findMany: {
            args: Prisma.ShowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowPayload>[]
          }
          create: {
            args: Prisma.ShowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowPayload>
          }
          createMany: {
            args: Prisma.ShowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowPayload>
          }
          update: {
            args: Prisma.ShowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowPayload>
          }
          deleteMany: {
            args: Prisma.ShowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowPayload>
          }
          aggregate: {
            args: Prisma.ShowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShow>
          }
          groupBy: {
            args: Prisma.ShowGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShowGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShowCountArgs<ExtArgs>
            result: $Utils.Optional<ShowCountAggregateOutputType> | number
          }
        }
      }
      Transcript: {
        payload: Prisma.$TranscriptPayload<ExtArgs>
        fields: Prisma.TranscriptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findFirst: {
            args: Prisma.TranscriptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          findMany: {
            args: Prisma.TranscriptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>[]
          }
          create: {
            args: Prisma.TranscriptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          createMany: {
            args: Prisma.TranscriptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TranscriptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          update: {
            args: Prisma.TranscriptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          deleteMany: {
            args: Prisma.TranscriptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranscriptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptPayload>
          }
          aggregate: {
            args: Prisma.TranscriptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscript>
          }
          groupBy: {
            args: Prisma.TranscriptGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptCountAggregateOutputType> | number
          }
        }
      }
      TranscriptUtterance: {
        payload: Prisma.$TranscriptUtterancePayload<ExtArgs>
        fields: Prisma.TranscriptUtteranceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptUtteranceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtterancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptUtteranceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtterancePayload>
          }
          findFirst: {
            args: Prisma.TranscriptUtteranceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtterancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptUtteranceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtterancePayload>
          }
          findMany: {
            args: Prisma.TranscriptUtteranceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtterancePayload>[]
          }
          create: {
            args: Prisma.TranscriptUtteranceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtterancePayload>
          }
          createMany: {
            args: Prisma.TranscriptUtteranceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TranscriptUtteranceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtterancePayload>
          }
          update: {
            args: Prisma.TranscriptUtteranceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtterancePayload>
          }
          deleteMany: {
            args: Prisma.TranscriptUtteranceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptUtteranceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranscriptUtteranceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtterancePayload>
          }
          aggregate: {
            args: Prisma.TranscriptUtteranceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscriptUtterance>
          }
          groupBy: {
            args: Prisma.TranscriptUtteranceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptUtteranceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptUtteranceCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptUtteranceCountAggregateOutputType> | number
          }
        }
      }
      TranscriptUtteranceWord: {
        payload: Prisma.$TranscriptUtteranceWordPayload<ExtArgs>
        fields: Prisma.TranscriptUtteranceWordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranscriptUtteranceWordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtteranceWordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranscriptUtteranceWordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtteranceWordPayload>
          }
          findFirst: {
            args: Prisma.TranscriptUtteranceWordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtteranceWordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranscriptUtteranceWordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtteranceWordPayload>
          }
          findMany: {
            args: Prisma.TranscriptUtteranceWordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtteranceWordPayload>[]
          }
          create: {
            args: Prisma.TranscriptUtteranceWordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtteranceWordPayload>
          }
          createMany: {
            args: Prisma.TranscriptUtteranceWordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TranscriptUtteranceWordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtteranceWordPayload>
          }
          update: {
            args: Prisma.TranscriptUtteranceWordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtteranceWordPayload>
          }
          deleteMany: {
            args: Prisma.TranscriptUtteranceWordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranscriptUtteranceWordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranscriptUtteranceWordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranscriptUtteranceWordPayload>
          }
          aggregate: {
            args: Prisma.TranscriptUtteranceWordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranscriptUtteranceWord>
          }
          groupBy: {
            args: Prisma.TranscriptUtteranceWordGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranscriptUtteranceWordGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranscriptUtteranceWordCountArgs<ExtArgs>
            result: $Utils.Optional<TranscriptUtteranceWordCountAggregateOutputType> | number
          }
        }
      }
      AiShowNote: {
        payload: Prisma.$AiShowNotePayload<ExtArgs>
        fields: Prisma.AiShowNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiShowNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiShowNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiShowNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiShowNotePayload>
          }
          findFirst: {
            args: Prisma.AiShowNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiShowNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiShowNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiShowNotePayload>
          }
          findMany: {
            args: Prisma.AiShowNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiShowNotePayload>[]
          }
          create: {
            args: Prisma.AiShowNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiShowNotePayload>
          }
          createMany: {
            args: Prisma.AiShowNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiShowNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiShowNotePayload>
          }
          update: {
            args: Prisma.AiShowNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiShowNotePayload>
          }
          deleteMany: {
            args: Prisma.AiShowNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiShowNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiShowNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiShowNotePayload>
          }
          aggregate: {
            args: Prisma.AiShowNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiShowNote>
          }
          groupBy: {
            args: Prisma.AiShowNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiShowNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiShowNoteCountArgs<ExtArgs>
            result: $Utils.Optional<AiShowNoteCountAggregateOutputType> | number
          }
        }
      }
      AiSummaryEntry: {
        payload: Prisma.$AiSummaryEntryPayload<ExtArgs>
        fields: Prisma.AiSummaryEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiSummaryEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSummaryEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiSummaryEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSummaryEntryPayload>
          }
          findFirst: {
            args: Prisma.AiSummaryEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSummaryEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiSummaryEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSummaryEntryPayload>
          }
          findMany: {
            args: Prisma.AiSummaryEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSummaryEntryPayload>[]
          }
          create: {
            args: Prisma.AiSummaryEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSummaryEntryPayload>
          }
          createMany: {
            args: Prisma.AiSummaryEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiSummaryEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSummaryEntryPayload>
          }
          update: {
            args: Prisma.AiSummaryEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSummaryEntryPayload>
          }
          deleteMany: {
            args: Prisma.AiSummaryEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiSummaryEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiSummaryEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSummaryEntryPayload>
          }
          aggregate: {
            args: Prisma.AiSummaryEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiSummaryEntry>
          }
          groupBy: {
            args: Prisma.AiSummaryEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiSummaryEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiSummaryEntryCountArgs<ExtArgs>
            result: $Utils.Optional<AiSummaryEntryCountAggregateOutputType> | number
          }
        }
      }
      AiTweet: {
        payload: Prisma.$AiTweetPayload<ExtArgs>
        fields: Prisma.AiTweetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiTweetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTweetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiTweetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTweetPayload>
          }
          findFirst: {
            args: Prisma.AiTweetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTweetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiTweetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTweetPayload>
          }
          findMany: {
            args: Prisma.AiTweetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTweetPayload>[]
          }
          create: {
            args: Prisma.AiTweetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTweetPayload>
          }
          createMany: {
            args: Prisma.AiTweetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiTweetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTweetPayload>
          }
          update: {
            args: Prisma.AiTweetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTweetPayload>
          }
          deleteMany: {
            args: Prisma.AiTweetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiTweetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiTweetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiTweetPayload>
          }
          aggregate: {
            args: Prisma.AiTweetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiTweet>
          }
          groupBy: {
            args: Prisma.AiTweetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiTweetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiTweetCountArgs<ExtArgs>
            result: $Utils.Optional<AiTweetCountAggregateOutputType> | number
          }
        }
      }
      Link: {
        payload: Prisma.$LinkPayload<ExtArgs>
        fields: Prisma.LinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          findFirst: {
            args: Prisma.LinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          findMany: {
            args: Prisma.LinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>[]
          }
          create: {
            args: Prisma.LinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          createMany: {
            args: Prisma.LinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          update: {
            args: Prisma.LinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          deleteMany: {
            args: Prisma.LinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          aggregate: {
            args: Prisma.LinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLink>
          }
          groupBy: {
            args: Prisma.LinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkCountArgs<ExtArgs>
            result: $Utils.Optional<LinkCountAggregateOutputType> | number
          }
        }
      }
      AiGuest: {
        payload: Prisma.$AiGuestPayload<ExtArgs>
        fields: Prisma.AiGuestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiGuestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGuestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiGuestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGuestPayload>
          }
          findFirst: {
            args: Prisma.AiGuestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGuestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiGuestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGuestPayload>
          }
          findMany: {
            args: Prisma.AiGuestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGuestPayload>[]
          }
          create: {
            args: Prisma.AiGuestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGuestPayload>
          }
          createMany: {
            args: Prisma.AiGuestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AiGuestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGuestPayload>
          }
          update: {
            args: Prisma.AiGuestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGuestPayload>
          }
          deleteMany: {
            args: Prisma.AiGuestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiGuestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiGuestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGuestPayload>
          }
          aggregate: {
            args: Prisma.AiGuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiGuest>
          }
          groupBy: {
            args: Prisma.AiGuestGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiGuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiGuestCountArgs<ExtArgs>
            result: $Utils.Optional<AiGuestCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      Playlist: {
        payload: Prisma.$PlaylistPayload<ExtArgs>
        fields: Prisma.PlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findFirst: {
            args: Prisma.PlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          findMany: {
            args: Prisma.PlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>[]
          }
          create: {
            args: Prisma.PlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          createMany: {
            args: Prisma.PlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          update: {
            args: Prisma.PlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistPayload>
          }
          aggregate: {
            args: Prisma.PlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylist>
          }
          groupBy: {
            args: Prisma.PlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistCountAggregateOutputType> | number
          }
        }
      }
      PlaylistOnVideo: {
        payload: Prisma.$PlaylistOnVideoPayload<ExtArgs>
        fields: Prisma.PlaylistOnVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaylistOnVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistOnVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaylistOnVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistOnVideoPayload>
          }
          findFirst: {
            args: Prisma.PlaylistOnVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistOnVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaylistOnVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistOnVideoPayload>
          }
          findMany: {
            args: Prisma.PlaylistOnVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistOnVideoPayload>[]
          }
          create: {
            args: Prisma.PlaylistOnVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistOnVideoPayload>
          }
          createMany: {
            args: Prisma.PlaylistOnVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlaylistOnVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistOnVideoPayload>
          }
          update: {
            args: Prisma.PlaylistOnVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistOnVideoPayload>
          }
          deleteMany: {
            args: Prisma.PlaylistOnVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaylistOnVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlaylistOnVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaylistOnVideoPayload>
          }
          aggregate: {
            args: Prisma.PlaylistOnVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaylistOnVideo>
          }
          groupBy: {
            args: Prisma.PlaylistOnVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaylistOnVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaylistOnVideoCountArgs<ExtArgs>
            result: $Utils.Optional<PlaylistOnVideoCountAggregateOutputType> | number
          }
        }
      }
      RemotePlaylist: {
        payload: Prisma.$RemotePlaylistPayload<ExtArgs>
        fields: Prisma.RemotePlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RemotePlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemotePlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RemotePlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemotePlaylistPayload>
          }
          findFirst: {
            args: Prisma.RemotePlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemotePlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RemotePlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemotePlaylistPayload>
          }
          findMany: {
            args: Prisma.RemotePlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemotePlaylistPayload>[]
          }
          create: {
            args: Prisma.RemotePlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemotePlaylistPayload>
          }
          createMany: {
            args: Prisma.RemotePlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RemotePlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemotePlaylistPayload>
          }
          update: {
            args: Prisma.RemotePlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemotePlaylistPayload>
          }
          deleteMany: {
            args: Prisma.RemotePlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RemotePlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RemotePlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RemotePlaylistPayload>
          }
          aggregate: {
            args: Prisma.RemotePlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRemotePlaylist>
          }
          groupBy: {
            args: Prisma.RemotePlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<RemotePlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.RemotePlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<RemotePlaylistCountAggregateOutputType> | number
          }
        }
      }
      ShowVideo: {
        payload: Prisma.$ShowVideoPayload<ExtArgs>
        fields: Prisma.ShowVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShowVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShowVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowVideoPayload>
          }
          findFirst: {
            args: Prisma.ShowVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShowVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowVideoPayload>
          }
          findMany: {
            args: Prisma.ShowVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowVideoPayload>[]
          }
          create: {
            args: Prisma.ShowVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowVideoPayload>
          }
          createMany: {
            args: Prisma.ShowVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShowVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowVideoPayload>
          }
          update: {
            args: Prisma.ShowVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowVideoPayload>
          }
          deleteMany: {
            args: Prisma.ShowVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShowVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShowVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShowVideoPayload>
          }
          aggregate: {
            args: Prisma.ShowVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShowVideo>
          }
          groupBy: {
            args: Prisma.ShowVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShowVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShowVideoCountArgs<ExtArgs>
            result: $Utils.Optional<ShowVideoCountAggregateOutputType> | number
          }
        }
      }
      UserSubmission: {
        payload: Prisma.$UserSubmissionPayload<ExtArgs>
        fields: Prisma.UserSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubmissionPayload>
          }
          findFirst: {
            args: Prisma.UserSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubmissionPayload>
          }
          findMany: {
            args: Prisma.UserSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubmissionPayload>[]
          }
          create: {
            args: Prisma.UserSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubmissionPayload>
          }
          createMany: {
            args: Prisma.UserSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubmissionPayload>
          }
          update: {
            args: Prisma.UserSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubmissionPayload>
          }
          aggregate: {
            args: Prisma.UserSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubmission>
          }
          groupBy: {
            args: Prisma.UserSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubmissionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
    session?: SessionOmit
    showGuest?: ShowGuestOmit
    guest?: GuestOmit
    socialLink?: SocialLinkOmit
    show?: ShowOmit
    transcript?: TranscriptOmit
    transcriptUtterance?: TranscriptUtteranceOmit
    transcriptUtteranceWord?: TranscriptUtteranceWordOmit
    aiShowNote?: AiShowNoteOmit
    aiSummaryEntry?: AiSummaryEntryOmit
    aiTweet?: AiTweetOmit
    link?: LinkOmit
    aiGuest?: AiGuestOmit
    topic?: TopicOmit
    video?: VideoOmit
    playlist?: PlaylistOmit
    playlistOnVideo?: PlaylistOnVideoOmit
    remotePlaylist?: RemotePlaylistOmit
    showVideo?: ShowVideoOmit
    userSubmission?: UserSubmissionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    session: number
    roles: number
    hostedShows: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | UserCountOutputTypeCountSessionArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    hostedShows?: boolean | UserCountOutputTypeCountHostedShowsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHostedShowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type GuestCountOutputType
   */

  export type GuestCountOutputType = {
    social: number
    shows: number
  }

  export type GuestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    social?: boolean | GuestCountOutputTypeCountSocialArgs
    shows?: boolean | GuestCountOutputTypeCountShowsArgs
  }

  // Custom InputTypes
  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestCountOutputType
     */
    select?: GuestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountSocialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLinkWhereInput
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountShowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowGuestWhereInput
  }


  /**
   * Count Type ShowCountOutputType
   */

  export type ShowCountOutputType = {
    guests: number
    videos: number
    hosts: number
  }

  export type ShowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guests?: boolean | ShowCountOutputTypeCountGuestsArgs
    videos?: boolean | ShowCountOutputTypeCountVideosArgs
    hosts?: boolean | ShowCountOutputTypeCountHostsArgs
  }

  // Custom InputTypes
  /**
   * ShowCountOutputType without action
   */
  export type ShowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowCountOutputType
     */
    select?: ShowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShowCountOutputType without action
   */
  export type ShowCountOutputTypeCountGuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowGuestWhereInput
  }

  /**
   * ShowCountOutputType without action
   */
  export type ShowCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowVideoWhereInput
  }

  /**
   * ShowCountOutputType without action
   */
  export type ShowCountOutputTypeCountHostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type TranscriptCountOutputType
   */

  export type TranscriptCountOutputType = {
    utterances: number
    ShowGuest: number
  }

  export type TranscriptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utterances?: boolean | TranscriptCountOutputTypeCountUtterancesArgs
    ShowGuest?: boolean | TranscriptCountOutputTypeCountShowGuestArgs
  }

  // Custom InputTypes
  /**
   * TranscriptCountOutputType without action
   */
  export type TranscriptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptCountOutputType
     */
    select?: TranscriptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TranscriptCountOutputType without action
   */
  export type TranscriptCountOutputTypeCountUtterancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptUtteranceWhereInput
  }

  /**
   * TranscriptCountOutputType without action
   */
  export type TranscriptCountOutputTypeCountShowGuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowGuestWhereInput
  }


  /**
   * Count Type TranscriptUtteranceCountOutputType
   */

  export type TranscriptUtteranceCountOutputType = {
    words: number
  }

  export type TranscriptUtteranceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    words?: boolean | TranscriptUtteranceCountOutputTypeCountWordsArgs
  }

  // Custom InputTypes
  /**
   * TranscriptUtteranceCountOutputType without action
   */
  export type TranscriptUtteranceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceCountOutputType
     */
    select?: TranscriptUtteranceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TranscriptUtteranceCountOutputType without action
   */
  export type TranscriptUtteranceCountOutputTypeCountWordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptUtteranceWordWhereInput
  }


  /**
   * Count Type AiShowNoteCountOutputType
   */

  export type AiShowNoteCountOutputType = {
    summary: number
    tweets: number
    links: number
    guests: number
    topics: number
  }

  export type AiShowNoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    summary?: boolean | AiShowNoteCountOutputTypeCountSummaryArgs
    tweets?: boolean | AiShowNoteCountOutputTypeCountTweetsArgs
    links?: boolean | AiShowNoteCountOutputTypeCountLinksArgs
    guests?: boolean | AiShowNoteCountOutputTypeCountGuestsArgs
    topics?: boolean | AiShowNoteCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * AiShowNoteCountOutputType without action
   */
  export type AiShowNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNoteCountOutputType
     */
    select?: AiShowNoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiShowNoteCountOutputType without action
   */
  export type AiShowNoteCountOutputTypeCountSummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSummaryEntryWhereInput
  }

  /**
   * AiShowNoteCountOutputType without action
   */
  export type AiShowNoteCountOutputTypeCountTweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiTweetWhereInput
  }

  /**
   * AiShowNoteCountOutputType without action
   */
  export type AiShowNoteCountOutputTypeCountLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkWhereInput
  }

  /**
   * AiShowNoteCountOutputType without action
   */
  export type AiShowNoteCountOutputTypeCountGuestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiGuestWhereInput
  }

  /**
   * AiShowNoteCountOutputType without action
   */
  export type AiShowNoteCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }


  /**
   * Count Type VideoCountOutputType
   */

  export type VideoCountOutputType = {
    playlists: number
    shows: number
  }

  export type VideoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlists?: boolean | VideoCountOutputTypeCountPlaylistsArgs
    shows?: boolean | VideoCountOutputTypeCountShowsArgs
  }

  // Custom InputTypes
  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoCountOutputType
     */
    select?: VideoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistOnVideoWhereInput
  }

  /**
   * VideoCountOutputType without action
   */
  export type VideoCountOutputTypeCountShowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowVideoWhereInput
  }


  /**
   * Count Type PlaylistCountOutputType
   */

  export type PlaylistCountOutputType = {
    videos: number
  }

  export type PlaylistCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | PlaylistCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistCountOutputType
     */
    select?: PlaylistCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaylistCountOutputType without action
   */
  export type PlaylistCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistOnVideoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    github_id: number | null
  }

  export type UserSumAggregateOutputType = {
    github_id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    avatar_url: string | null
    created_at: Date | null
    email: string | null
    github_id: number | null
    updated_at: Date | null
    username: string | null
    theme: string | null
    name: string | null
    twitter: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    avatar_url: string | null
    created_at: Date | null
    email: string | null
    github_id: number | null
    updated_at: Date | null
    username: string | null
    theme: string | null
    name: string | null
    twitter: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    avatar_url: number
    created_at: number
    email: number
    github_id: number
    updated_at: number
    username: number
    theme: number
    name: number
    twitter: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    github_id?: true
  }

  export type UserSumAggregateInputType = {
    github_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    avatar_url?: true
    created_at?: true
    email?: true
    github_id?: true
    updated_at?: true
    username?: true
    theme?: true
    name?: true
    twitter?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    avatar_url?: true
    created_at?: true
    email?: true
    github_id?: true
    updated_at?: true
    username?: true
    theme?: true
    name?: true
    twitter?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    avatar_url?: true
    created_at?: true
    email?: true
    github_id?: true
    updated_at?: true
    username?: true
    theme?: true
    name?: true
    twitter?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    avatar_url: string | null
    created_at: Date
    email: string | null
    github_id: number
    updated_at: Date
    username: string | null
    theme: string
    name: string | null
    twitter: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    avatar_url?: boolean
    created_at?: boolean
    email?: boolean
    github_id?: boolean
    updated_at?: boolean
    username?: boolean
    theme?: boolean
    name?: boolean
    twitter?: boolean
    session?: boolean | User$sessionArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    hostedShows?: boolean | User$hostedShowsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    avatar_url?: boolean
    created_at?: boolean
    email?: boolean
    github_id?: boolean
    updated_at?: boolean
    username?: boolean
    theme?: boolean
    name?: boolean
    twitter?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "avatar_url" | "created_at" | "email" | "github_id" | "updated_at" | "username" | "theme" | "name" | "twitter", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | User$sessionArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    hostedShows?: boolean | User$hostedShowsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>[]
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      hostedShows: Prisma.$ShowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      avatar_url: string | null
      created_at: Date
      email: string | null
      github_id: number
      updated_at: Date
      username: string | null
      theme: string
      name: string | null
      twitter: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends User$sessionArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hostedShows<T extends User$hostedShowsArgs<ExtArgs> = {}>(args?: Subset<T, User$hostedShowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly avatar_url: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly email: FieldRef<"User", 'String'>
    readonly github_id: FieldRef<"User", 'Int'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
    readonly theme: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly twitter: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.session
   */
  export type User$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.hostedShows
   */
  export type User$hostedShowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    where?: ShowWhereInput
    orderBy?: ShowOrderByWithRelationInput | ShowOrderByWithRelationInput[]
    cursor?: ShowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowScalarFieldEnum | ShowScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>



  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roleId", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    access_token: string | null
    session_token: string | null
    created_at: Date | null
    updated_at: Date | null
    ip: string | null
    country: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    access_token: string | null
    session_token: string | null
    created_at: Date | null
    updated_at: Date | null
    ip: string | null
    country: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    user_id: number
    access_token: number
    session_token: number
    created_at: number
    updated_at: number
    ip: number
    country: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    user_id?: true
    access_token?: true
    session_token?: true
    created_at?: true
    updated_at?: true
    ip?: true
    country?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    user_id?: true
    access_token?: true
    session_token?: true
    created_at?: true
    updated_at?: true
    ip?: true
    country?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    user_id?: true
    access_token?: true
    session_token?: true
    created_at?: true
    updated_at?: true
    ip?: true
    country?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    user_id: string | null
    access_token: string | null
    session_token: string
    created_at: Date
    updated_at: Date
    ip: string | null
    country: string | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    access_token?: boolean
    session_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    ip?: boolean
    country?: boolean
    user?: boolean | Session$userArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    user_id?: boolean
    access_token?: boolean
    session_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    ip?: boolean
    country?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "access_token" | "session_token" | "created_at" | "updated_at" | "ip" | "country", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Session$userArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string | null
      access_token: string | null
      session_token: string
      created_at: Date
      updated_at: Date
      ip: string | null
      country: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Session$userArgs<ExtArgs> = {}>(args?: Subset<T, Session$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly user_id: FieldRef<"Session", 'String'>
    readonly access_token: FieldRef<"Session", 'String'>
    readonly session_token: FieldRef<"Session", 'String'>
    readonly created_at: FieldRef<"Session", 'DateTime'>
    readonly updated_at: FieldRef<"Session", 'DateTime'>
    readonly ip: FieldRef<"Session", 'String'>
    readonly country: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.user
   */
  export type Session$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model ShowGuest
   */

  export type AggregateShowGuest = {
    _count: ShowGuestCountAggregateOutputType | null
    _min: ShowGuestMinAggregateOutputType | null
    _max: ShowGuestMaxAggregateOutputType | null
  }

  export type ShowGuestMinAggregateOutputType = {
    id: string | null
    showId: string | null
    guestId: string | null
    transcriptId: string | null
  }

  export type ShowGuestMaxAggregateOutputType = {
    id: string | null
    showId: string | null
    guestId: string | null
    transcriptId: string | null
  }

  export type ShowGuestCountAggregateOutputType = {
    id: number
    showId: number
    guestId: number
    transcriptId: number
    _all: number
  }


  export type ShowGuestMinAggregateInputType = {
    id?: true
    showId?: true
    guestId?: true
    transcriptId?: true
  }

  export type ShowGuestMaxAggregateInputType = {
    id?: true
    showId?: true
    guestId?: true
    transcriptId?: true
  }

  export type ShowGuestCountAggregateInputType = {
    id?: true
    showId?: true
    guestId?: true
    transcriptId?: true
    _all?: true
  }

  export type ShowGuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShowGuest to aggregate.
     */
    where?: ShowGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowGuests to fetch.
     */
    orderBy?: ShowGuestOrderByWithRelationInput | ShowGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShowGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShowGuests
    **/
    _count?: true | ShowGuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShowGuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShowGuestMaxAggregateInputType
  }

  export type GetShowGuestAggregateType<T extends ShowGuestAggregateArgs> = {
        [P in keyof T & keyof AggregateShowGuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShowGuest[P]>
      : GetScalarType<T[P], AggregateShowGuest[P]>
  }




  export type ShowGuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowGuestWhereInput
    orderBy?: ShowGuestOrderByWithAggregationInput | ShowGuestOrderByWithAggregationInput[]
    by: ShowGuestScalarFieldEnum[] | ShowGuestScalarFieldEnum
    having?: ShowGuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShowGuestCountAggregateInputType | true
    _min?: ShowGuestMinAggregateInputType
    _max?: ShowGuestMaxAggregateInputType
  }

  export type ShowGuestGroupByOutputType = {
    id: string
    showId: string
    guestId: string
    transcriptId: string | null
    _count: ShowGuestCountAggregateOutputType | null
    _min: ShowGuestMinAggregateOutputType | null
    _max: ShowGuestMaxAggregateOutputType | null
  }

  type GetShowGuestGroupByPayload<T extends ShowGuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShowGuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShowGuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShowGuestGroupByOutputType[P]>
            : GetScalarType<T[P], ShowGuestGroupByOutputType[P]>
        }
      >
    >


  export type ShowGuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    showId?: boolean
    guestId?: boolean
    transcriptId?: boolean
    Show?: boolean | ShowDefaultArgs<ExtArgs>
    Guest?: boolean | GuestDefaultArgs<ExtArgs>
    Transcript?: boolean | ShowGuest$TranscriptArgs<ExtArgs>
  }, ExtArgs["result"]["showGuest"]>



  export type ShowGuestSelectScalar = {
    id?: boolean
    showId?: boolean
    guestId?: boolean
    transcriptId?: boolean
  }

  export type ShowGuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "showId" | "guestId" | "transcriptId", ExtArgs["result"]["showGuest"]>
  export type ShowGuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Show?: boolean | ShowDefaultArgs<ExtArgs>
    Guest?: boolean | GuestDefaultArgs<ExtArgs>
    Transcript?: boolean | ShowGuest$TranscriptArgs<ExtArgs>
  }

  export type $ShowGuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShowGuest"
    objects: {
      Show: Prisma.$ShowPayload<ExtArgs>
      Guest: Prisma.$GuestPayload<ExtArgs>
      Transcript: Prisma.$TranscriptPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      showId: string
      guestId: string
      transcriptId: string | null
    }, ExtArgs["result"]["showGuest"]>
    composites: {}
  }

  type ShowGuestGetPayload<S extends boolean | null | undefined | ShowGuestDefaultArgs> = $Result.GetResult<Prisma.$ShowGuestPayload, S>

  type ShowGuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShowGuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShowGuestCountAggregateInputType | true
    }

  export interface ShowGuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShowGuest'], meta: { name: 'ShowGuest' } }
    /**
     * Find zero or one ShowGuest that matches the filter.
     * @param {ShowGuestFindUniqueArgs} args - Arguments to find a ShowGuest
     * @example
     * // Get one ShowGuest
     * const showGuest = await prisma.showGuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShowGuestFindUniqueArgs>(args: SelectSubset<T, ShowGuestFindUniqueArgs<ExtArgs>>): Prisma__ShowGuestClient<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShowGuest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShowGuestFindUniqueOrThrowArgs} args - Arguments to find a ShowGuest
     * @example
     * // Get one ShowGuest
     * const showGuest = await prisma.showGuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShowGuestFindUniqueOrThrowArgs>(args: SelectSubset<T, ShowGuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShowGuestClient<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShowGuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowGuestFindFirstArgs} args - Arguments to find a ShowGuest
     * @example
     * // Get one ShowGuest
     * const showGuest = await prisma.showGuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShowGuestFindFirstArgs>(args?: SelectSubset<T, ShowGuestFindFirstArgs<ExtArgs>>): Prisma__ShowGuestClient<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShowGuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowGuestFindFirstOrThrowArgs} args - Arguments to find a ShowGuest
     * @example
     * // Get one ShowGuest
     * const showGuest = await prisma.showGuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShowGuestFindFirstOrThrowArgs>(args?: SelectSubset<T, ShowGuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShowGuestClient<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShowGuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowGuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShowGuests
     * const showGuests = await prisma.showGuest.findMany()
     * 
     * // Get first 10 ShowGuests
     * const showGuests = await prisma.showGuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const showGuestWithIdOnly = await prisma.showGuest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShowGuestFindManyArgs>(args?: SelectSubset<T, ShowGuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShowGuest.
     * @param {ShowGuestCreateArgs} args - Arguments to create a ShowGuest.
     * @example
     * // Create one ShowGuest
     * const ShowGuest = await prisma.showGuest.create({
     *   data: {
     *     // ... data to create a ShowGuest
     *   }
     * })
     * 
     */
    create<T extends ShowGuestCreateArgs>(args: SelectSubset<T, ShowGuestCreateArgs<ExtArgs>>): Prisma__ShowGuestClient<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShowGuests.
     * @param {ShowGuestCreateManyArgs} args - Arguments to create many ShowGuests.
     * @example
     * // Create many ShowGuests
     * const showGuest = await prisma.showGuest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShowGuestCreateManyArgs>(args?: SelectSubset<T, ShowGuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShowGuest.
     * @param {ShowGuestDeleteArgs} args - Arguments to delete one ShowGuest.
     * @example
     * // Delete one ShowGuest
     * const ShowGuest = await prisma.showGuest.delete({
     *   where: {
     *     // ... filter to delete one ShowGuest
     *   }
     * })
     * 
     */
    delete<T extends ShowGuestDeleteArgs>(args: SelectSubset<T, ShowGuestDeleteArgs<ExtArgs>>): Prisma__ShowGuestClient<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShowGuest.
     * @param {ShowGuestUpdateArgs} args - Arguments to update one ShowGuest.
     * @example
     * // Update one ShowGuest
     * const showGuest = await prisma.showGuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShowGuestUpdateArgs>(args: SelectSubset<T, ShowGuestUpdateArgs<ExtArgs>>): Prisma__ShowGuestClient<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShowGuests.
     * @param {ShowGuestDeleteManyArgs} args - Arguments to filter ShowGuests to delete.
     * @example
     * // Delete a few ShowGuests
     * const { count } = await prisma.showGuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShowGuestDeleteManyArgs>(args?: SelectSubset<T, ShowGuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShowGuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowGuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShowGuests
     * const showGuest = await prisma.showGuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShowGuestUpdateManyArgs>(args: SelectSubset<T, ShowGuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShowGuest.
     * @param {ShowGuestUpsertArgs} args - Arguments to update or create a ShowGuest.
     * @example
     * // Update or create a ShowGuest
     * const showGuest = await prisma.showGuest.upsert({
     *   create: {
     *     // ... data to create a ShowGuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShowGuest we want to update
     *   }
     * })
     */
    upsert<T extends ShowGuestUpsertArgs>(args: SelectSubset<T, ShowGuestUpsertArgs<ExtArgs>>): Prisma__ShowGuestClient<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShowGuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowGuestCountArgs} args - Arguments to filter ShowGuests to count.
     * @example
     * // Count the number of ShowGuests
     * const count = await prisma.showGuest.count({
     *   where: {
     *     // ... the filter for the ShowGuests we want to count
     *   }
     * })
    **/
    count<T extends ShowGuestCountArgs>(
      args?: Subset<T, ShowGuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShowGuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShowGuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowGuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShowGuestAggregateArgs>(args: Subset<T, ShowGuestAggregateArgs>): Prisma.PrismaPromise<GetShowGuestAggregateType<T>>

    /**
     * Group by ShowGuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowGuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShowGuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShowGuestGroupByArgs['orderBy'] }
        : { orderBy?: ShowGuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShowGuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShowGuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShowGuest model
   */
  readonly fields: ShowGuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShowGuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShowGuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Show<T extends ShowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowDefaultArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Guest<T extends GuestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuestDefaultArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Transcript<T extends ShowGuest$TranscriptArgs<ExtArgs> = {}>(args?: Subset<T, ShowGuest$TranscriptArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShowGuest model
   */
  interface ShowGuestFieldRefs {
    readonly id: FieldRef<"ShowGuest", 'String'>
    readonly showId: FieldRef<"ShowGuest", 'String'>
    readonly guestId: FieldRef<"ShowGuest", 'String'>
    readonly transcriptId: FieldRef<"ShowGuest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ShowGuest findUnique
   */
  export type ShowGuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    /**
     * Filter, which ShowGuest to fetch.
     */
    where: ShowGuestWhereUniqueInput
  }

  /**
   * ShowGuest findUniqueOrThrow
   */
  export type ShowGuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    /**
     * Filter, which ShowGuest to fetch.
     */
    where: ShowGuestWhereUniqueInput
  }

  /**
   * ShowGuest findFirst
   */
  export type ShowGuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    /**
     * Filter, which ShowGuest to fetch.
     */
    where?: ShowGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowGuests to fetch.
     */
    orderBy?: ShowGuestOrderByWithRelationInput | ShowGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShowGuests.
     */
    cursor?: ShowGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShowGuests.
     */
    distinct?: ShowGuestScalarFieldEnum | ShowGuestScalarFieldEnum[]
  }

  /**
   * ShowGuest findFirstOrThrow
   */
  export type ShowGuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    /**
     * Filter, which ShowGuest to fetch.
     */
    where?: ShowGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowGuests to fetch.
     */
    orderBy?: ShowGuestOrderByWithRelationInput | ShowGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShowGuests.
     */
    cursor?: ShowGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShowGuests.
     */
    distinct?: ShowGuestScalarFieldEnum | ShowGuestScalarFieldEnum[]
  }

  /**
   * ShowGuest findMany
   */
  export type ShowGuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    /**
     * Filter, which ShowGuests to fetch.
     */
    where?: ShowGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowGuests to fetch.
     */
    orderBy?: ShowGuestOrderByWithRelationInput | ShowGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShowGuests.
     */
    cursor?: ShowGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowGuests.
     */
    skip?: number
    distinct?: ShowGuestScalarFieldEnum | ShowGuestScalarFieldEnum[]
  }

  /**
   * ShowGuest create
   */
  export type ShowGuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    /**
     * The data needed to create a ShowGuest.
     */
    data: XOR<ShowGuestCreateInput, ShowGuestUncheckedCreateInput>
  }

  /**
   * ShowGuest createMany
   */
  export type ShowGuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShowGuests.
     */
    data: ShowGuestCreateManyInput | ShowGuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShowGuest update
   */
  export type ShowGuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    /**
     * The data needed to update a ShowGuest.
     */
    data: XOR<ShowGuestUpdateInput, ShowGuestUncheckedUpdateInput>
    /**
     * Choose, which ShowGuest to update.
     */
    where: ShowGuestWhereUniqueInput
  }

  /**
   * ShowGuest updateMany
   */
  export type ShowGuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShowGuests.
     */
    data: XOR<ShowGuestUpdateManyMutationInput, ShowGuestUncheckedUpdateManyInput>
    /**
     * Filter which ShowGuests to update
     */
    where?: ShowGuestWhereInput
    /**
     * Limit how many ShowGuests to update.
     */
    limit?: number
  }

  /**
   * ShowGuest upsert
   */
  export type ShowGuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    /**
     * The filter to search for the ShowGuest to update in case it exists.
     */
    where: ShowGuestWhereUniqueInput
    /**
     * In case the ShowGuest found by the `where` argument doesn't exist, create a new ShowGuest with this data.
     */
    create: XOR<ShowGuestCreateInput, ShowGuestUncheckedCreateInput>
    /**
     * In case the ShowGuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShowGuestUpdateInput, ShowGuestUncheckedUpdateInput>
  }

  /**
   * ShowGuest delete
   */
  export type ShowGuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    /**
     * Filter which ShowGuest to delete.
     */
    where: ShowGuestWhereUniqueInput
  }

  /**
   * ShowGuest deleteMany
   */
  export type ShowGuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShowGuests to delete
     */
    where?: ShowGuestWhereInput
    /**
     * Limit how many ShowGuests to delete.
     */
    limit?: number
  }

  /**
   * ShowGuest.Transcript
   */
  export type ShowGuest$TranscriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    where?: TranscriptWhereInput
  }

  /**
   * ShowGuest without action
   */
  export type ShowGuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
  }


  /**
   * Model Guest
   */

  export type AggregateGuest = {
    _count: GuestCountAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  export type GuestMinAggregateOutputType = {
    id: string | null
    name: string | null
    name_slug: string | null
    twitter: string | null
    github: string | null
    of: string | null
    url: string | null
  }

  export type GuestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    name_slug: string | null
    twitter: string | null
    github: string | null
    of: string | null
    url: string | null
  }

  export type GuestCountAggregateOutputType = {
    id: number
    name: number
    name_slug: number
    twitter: number
    github: number
    of: number
    url: number
    _all: number
  }


  export type GuestMinAggregateInputType = {
    id?: true
    name?: true
    name_slug?: true
    twitter?: true
    github?: true
    of?: true
    url?: true
  }

  export type GuestMaxAggregateInputType = {
    id?: true
    name?: true
    name_slug?: true
    twitter?: true
    github?: true
    of?: true
    url?: true
  }

  export type GuestCountAggregateInputType = {
    id?: true
    name?: true
    name_slug?: true
    twitter?: true
    github?: true
    of?: true
    url?: true
    _all?: true
  }

  export type GuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guest to aggregate.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guests
    **/
    _count?: true | GuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuestMaxAggregateInputType
  }

  export type GetGuestAggregateType<T extends GuestAggregateArgs> = {
        [P in keyof T & keyof AggregateGuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuest[P]>
      : GetScalarType<T[P], AggregateGuest[P]>
  }




  export type GuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestWhereInput
    orderBy?: GuestOrderByWithAggregationInput | GuestOrderByWithAggregationInput[]
    by: GuestScalarFieldEnum[] | GuestScalarFieldEnum
    having?: GuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuestCountAggregateInputType | true
    _min?: GuestMinAggregateInputType
    _max?: GuestMaxAggregateInputType
  }

  export type GuestGroupByOutputType = {
    id: string
    name: string
    name_slug: string
    twitter: string | null
    github: string | null
    of: string | null
    url: string | null
    _count: GuestCountAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  type GetGuestGroupByPayload<T extends GuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuestGroupByOutputType[P]>
            : GetScalarType<T[P], GuestGroupByOutputType[P]>
        }
      >
    >


  export type GuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    name_slug?: boolean
    twitter?: boolean
    github?: boolean
    of?: boolean
    url?: boolean
    social?: boolean | Guest$socialArgs<ExtArgs>
    shows?: boolean | Guest$showsArgs<ExtArgs>
    _count?: boolean | GuestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guest"]>



  export type GuestSelectScalar = {
    id?: boolean
    name?: boolean
    name_slug?: boolean
    twitter?: boolean
    github?: boolean
    of?: boolean
    url?: boolean
  }

  export type GuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "name_slug" | "twitter" | "github" | "of" | "url", ExtArgs["result"]["guest"]>
  export type GuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    social?: boolean | Guest$socialArgs<ExtArgs>
    shows?: boolean | Guest$showsArgs<ExtArgs>
    _count?: boolean | GuestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guest"
    objects: {
      social: Prisma.$SocialLinkPayload<ExtArgs>[]
      shows: Prisma.$ShowGuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      name_slug: string
      twitter: string | null
      github: string | null
      of: string | null
      url: string | null
    }, ExtArgs["result"]["guest"]>
    composites: {}
  }

  type GuestGetPayload<S extends boolean | null | undefined | GuestDefaultArgs> = $Result.GetResult<Prisma.$GuestPayload, S>

  type GuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuestCountAggregateInputType | true
    }

  export interface GuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guest'], meta: { name: 'Guest' } }
    /**
     * Find zero or one Guest that matches the filter.
     * @param {GuestFindUniqueArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuestFindUniqueArgs>(args: SelectSubset<T, GuestFindUniqueArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuestFindUniqueOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuestFindUniqueOrThrowArgs>(args: SelectSubset<T, GuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindFirstArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuestFindFirstArgs>(args?: SelectSubset<T, GuestFindFirstArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindFirstOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuestFindFirstOrThrowArgs>(args?: SelectSubset<T, GuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guests
     * const guests = await prisma.guest.findMany()
     * 
     * // Get first 10 Guests
     * const guests = await prisma.guest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guestWithIdOnly = await prisma.guest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuestFindManyArgs>(args?: SelectSubset<T, GuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guest.
     * @param {GuestCreateArgs} args - Arguments to create a Guest.
     * @example
     * // Create one Guest
     * const Guest = await prisma.guest.create({
     *   data: {
     *     // ... data to create a Guest
     *   }
     * })
     * 
     */
    create<T extends GuestCreateArgs>(args: SelectSubset<T, GuestCreateArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guests.
     * @param {GuestCreateManyArgs} args - Arguments to create many Guests.
     * @example
     * // Create many Guests
     * const guest = await prisma.guest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuestCreateManyArgs>(args?: SelectSubset<T, GuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guest.
     * @param {GuestDeleteArgs} args - Arguments to delete one Guest.
     * @example
     * // Delete one Guest
     * const Guest = await prisma.guest.delete({
     *   where: {
     *     // ... filter to delete one Guest
     *   }
     * })
     * 
     */
    delete<T extends GuestDeleteArgs>(args: SelectSubset<T, GuestDeleteArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guest.
     * @param {GuestUpdateArgs} args - Arguments to update one Guest.
     * @example
     * // Update one Guest
     * const guest = await prisma.guest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuestUpdateArgs>(args: SelectSubset<T, GuestUpdateArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guests.
     * @param {GuestDeleteManyArgs} args - Arguments to filter Guests to delete.
     * @example
     * // Delete a few Guests
     * const { count } = await prisma.guest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuestDeleteManyArgs>(args?: SelectSubset<T, GuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guests
     * const guest = await prisma.guest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuestUpdateManyArgs>(args: SelectSubset<T, GuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guest.
     * @param {GuestUpsertArgs} args - Arguments to update or create a Guest.
     * @example
     * // Update or create a Guest
     * const guest = await prisma.guest.upsert({
     *   create: {
     *     // ... data to create a Guest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guest we want to update
     *   }
     * })
     */
    upsert<T extends GuestUpsertArgs>(args: SelectSubset<T, GuestUpsertArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestCountArgs} args - Arguments to filter Guests to count.
     * @example
     * // Count the number of Guests
     * const count = await prisma.guest.count({
     *   where: {
     *     // ... the filter for the Guests we want to count
     *   }
     * })
    **/
    count<T extends GuestCountArgs>(
      args?: Subset<T, GuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuestAggregateArgs>(args: Subset<T, GuestAggregateArgs>): Prisma.PrismaPromise<GetGuestAggregateType<T>>

    /**
     * Group by Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuestGroupByArgs['orderBy'] }
        : { orderBy?: GuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guest model
   */
  readonly fields: GuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    social<T extends Guest$socialArgs<ExtArgs> = {}>(args?: Subset<T, Guest$socialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shows<T extends Guest$showsArgs<ExtArgs> = {}>(args?: Subset<T, Guest$showsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guest model
   */
  interface GuestFieldRefs {
    readonly id: FieldRef<"Guest", 'String'>
    readonly name: FieldRef<"Guest", 'String'>
    readonly name_slug: FieldRef<"Guest", 'String'>
    readonly twitter: FieldRef<"Guest", 'String'>
    readonly github: FieldRef<"Guest", 'String'>
    readonly of: FieldRef<"Guest", 'String'>
    readonly url: FieldRef<"Guest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Guest findUnique
   */
  export type GuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest findUniqueOrThrow
   */
  export type GuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest findFirst
   */
  export type GuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest findFirstOrThrow
   */
  export type GuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guest to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest findMany
   */
  export type GuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter, which Guests to fetch.
     */
    where?: GuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guests to fetch.
     */
    orderBy?: GuestOrderByWithRelationInput | GuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guests.
     */
    cursor?: GuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guests.
     */
    skip?: number
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * Guest create
   */
  export type GuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The data needed to create a Guest.
     */
    data: XOR<GuestCreateInput, GuestUncheckedCreateInput>
  }

  /**
   * Guest createMany
   */
  export type GuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guests.
     */
    data: GuestCreateManyInput | GuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guest update
   */
  export type GuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The data needed to update a Guest.
     */
    data: XOR<GuestUpdateInput, GuestUncheckedUpdateInput>
    /**
     * Choose, which Guest to update.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest updateMany
   */
  export type GuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guests.
     */
    data: XOR<GuestUpdateManyMutationInput, GuestUncheckedUpdateManyInput>
    /**
     * Filter which Guests to update
     */
    where?: GuestWhereInput
    /**
     * Limit how many Guests to update.
     */
    limit?: number
  }

  /**
   * Guest upsert
   */
  export type GuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * The filter to search for the Guest to update in case it exists.
     */
    where: GuestWhereUniqueInput
    /**
     * In case the Guest found by the `where` argument doesn't exist, create a new Guest with this data.
     */
    create: XOR<GuestCreateInput, GuestUncheckedCreateInput>
    /**
     * In case the Guest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuestUpdateInput, GuestUncheckedUpdateInput>
  }

  /**
   * Guest delete
   */
  export type GuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
    /**
     * Filter which Guest to delete.
     */
    where: GuestWhereUniqueInput
  }

  /**
   * Guest deleteMany
   */
  export type GuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guests to delete
     */
    where?: GuestWhereInput
    /**
     * Limit how many Guests to delete.
     */
    limit?: number
  }

  /**
   * Guest.social
   */
  export type Guest$socialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    where?: SocialLinkWhereInput
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    cursor?: SocialLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * Guest.shows
   */
  export type Guest$showsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    where?: ShowGuestWhereInput
    orderBy?: ShowGuestOrderByWithRelationInput | ShowGuestOrderByWithRelationInput[]
    cursor?: ShowGuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowGuestScalarFieldEnum | ShowGuestScalarFieldEnum[]
  }

  /**
   * Guest without action
   */
  export type GuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guest
     */
    select?: GuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guest
     */
    omit?: GuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestInclude<ExtArgs> | null
  }


  /**
   * Model SocialLink
   */

  export type AggregateSocialLink = {
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  export type SocialLinkMinAggregateOutputType = {
    id: string | null
    link: string | null
    guest_id: string | null
  }

  export type SocialLinkMaxAggregateOutputType = {
    id: string | null
    link: string | null
    guest_id: string | null
  }

  export type SocialLinkCountAggregateOutputType = {
    id: number
    link: number
    guest_id: number
    _all: number
  }


  export type SocialLinkMinAggregateInputType = {
    id?: true
    link?: true
    guest_id?: true
  }

  export type SocialLinkMaxAggregateInputType = {
    id?: true
    link?: true
    guest_id?: true
  }

  export type SocialLinkCountAggregateInputType = {
    id?: true
    link?: true
    guest_id?: true
    _all?: true
  }

  export type SocialLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLink to aggregate.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialLinks
    **/
    _count?: true | SocialLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialLinkMaxAggregateInputType
  }

  export type GetSocialLinkAggregateType<T extends SocialLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialLink[P]>
      : GetScalarType<T[P], AggregateSocialLink[P]>
  }




  export type SocialLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialLinkWhereInput
    orderBy?: SocialLinkOrderByWithAggregationInput | SocialLinkOrderByWithAggregationInput[]
    by: SocialLinkScalarFieldEnum[] | SocialLinkScalarFieldEnum
    having?: SocialLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialLinkCountAggregateInputType | true
    _min?: SocialLinkMinAggregateInputType
    _max?: SocialLinkMaxAggregateInputType
  }

  export type SocialLinkGroupByOutputType = {
    id: string
    link: string
    guest_id: string
    _count: SocialLinkCountAggregateOutputType | null
    _min: SocialLinkMinAggregateOutputType | null
    _max: SocialLinkMaxAggregateOutputType | null
  }

  type GetSocialLinkGroupByPayload<T extends SocialLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SocialLinkGroupByOutputType[P]>
        }
      >
    >


  export type SocialLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    link?: boolean
    guest_id?: boolean
    guest?: boolean | GuestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialLink"]>



  export type SocialLinkSelectScalar = {
    id?: boolean
    link?: boolean
    guest_id?: boolean
  }

  export type SocialLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "link" | "guest_id", ExtArgs["result"]["socialLink"]>
  export type SocialLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | GuestDefaultArgs<ExtArgs>
  }

  export type $SocialLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialLink"
    objects: {
      guest: Prisma.$GuestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      link: string
      guest_id: string
    }, ExtArgs["result"]["socialLink"]>
    composites: {}
  }

  type SocialLinkGetPayload<S extends boolean | null | undefined | SocialLinkDefaultArgs> = $Result.GetResult<Prisma.$SocialLinkPayload, S>

  type SocialLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialLinkCountAggregateInputType | true
    }

  export interface SocialLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialLink'], meta: { name: 'SocialLink' } }
    /**
     * Find zero or one SocialLink that matches the filter.
     * @param {SocialLinkFindUniqueArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialLinkFindUniqueArgs>(args: SelectSubset<T, SocialLinkFindUniqueArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialLinkFindUniqueOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindFirstArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialLinkFindFirstArgs>(args?: SelectSubset<T, SocialLinkFindFirstArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindFirstOrThrowArgs} args - Arguments to find a SocialLink
     * @example
     * // Get one SocialLink
     * const socialLink = await prisma.socialLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialLinks
     * const socialLinks = await prisma.socialLink.findMany()
     * 
     * // Get first 10 SocialLinks
     * const socialLinks = await prisma.socialLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialLinkWithIdOnly = await prisma.socialLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialLinkFindManyArgs>(args?: SelectSubset<T, SocialLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialLink.
     * @param {SocialLinkCreateArgs} args - Arguments to create a SocialLink.
     * @example
     * // Create one SocialLink
     * const SocialLink = await prisma.socialLink.create({
     *   data: {
     *     // ... data to create a SocialLink
     *   }
     * })
     * 
     */
    create<T extends SocialLinkCreateArgs>(args: SelectSubset<T, SocialLinkCreateArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialLinks.
     * @param {SocialLinkCreateManyArgs} args - Arguments to create many SocialLinks.
     * @example
     * // Create many SocialLinks
     * const socialLink = await prisma.socialLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialLinkCreateManyArgs>(args?: SelectSubset<T, SocialLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialLink.
     * @param {SocialLinkDeleteArgs} args - Arguments to delete one SocialLink.
     * @example
     * // Delete one SocialLink
     * const SocialLink = await prisma.socialLink.delete({
     *   where: {
     *     // ... filter to delete one SocialLink
     *   }
     * })
     * 
     */
    delete<T extends SocialLinkDeleteArgs>(args: SelectSubset<T, SocialLinkDeleteArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialLink.
     * @param {SocialLinkUpdateArgs} args - Arguments to update one SocialLink.
     * @example
     * // Update one SocialLink
     * const socialLink = await prisma.socialLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialLinkUpdateArgs>(args: SelectSubset<T, SocialLinkUpdateArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialLinks.
     * @param {SocialLinkDeleteManyArgs} args - Arguments to filter SocialLinks to delete.
     * @example
     * // Delete a few SocialLinks
     * const { count } = await prisma.socialLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialLinkDeleteManyArgs>(args?: SelectSubset<T, SocialLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialLinks
     * const socialLink = await prisma.socialLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialLinkUpdateManyArgs>(args: SelectSubset<T, SocialLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialLink.
     * @param {SocialLinkUpsertArgs} args - Arguments to update or create a SocialLink.
     * @example
     * // Update or create a SocialLink
     * const socialLink = await prisma.socialLink.upsert({
     *   create: {
     *     // ... data to create a SocialLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialLink we want to update
     *   }
     * })
     */
    upsert<T extends SocialLinkUpsertArgs>(args: SelectSubset<T, SocialLinkUpsertArgs<ExtArgs>>): Prisma__SocialLinkClient<$Result.GetResult<Prisma.$SocialLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkCountArgs} args - Arguments to filter SocialLinks to count.
     * @example
     * // Count the number of SocialLinks
     * const count = await prisma.socialLink.count({
     *   where: {
     *     // ... the filter for the SocialLinks we want to count
     *   }
     * })
    **/
    count<T extends SocialLinkCountArgs>(
      args?: Subset<T, SocialLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialLinkAggregateArgs>(args: Subset<T, SocialLinkAggregateArgs>): Prisma.PrismaPromise<GetSocialLinkAggregateType<T>>

    /**
     * Group by SocialLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialLinkGroupByArgs['orderBy'] }
        : { orderBy?: SocialLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialLink model
   */
  readonly fields: SocialLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guest<T extends GuestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuestDefaultArgs<ExtArgs>>): Prisma__GuestClient<$Result.GetResult<Prisma.$GuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialLink model
   */
  interface SocialLinkFieldRefs {
    readonly id: FieldRef<"SocialLink", 'String'>
    readonly link: FieldRef<"SocialLink", 'String'>
    readonly guest_id: FieldRef<"SocialLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SocialLink findUnique
   */
  export type SocialLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink findUniqueOrThrow
   */
  export type SocialLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink findFirst
   */
  export type SocialLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink findFirstOrThrow
   */
  export type SocialLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLink to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLinks.
     */
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink findMany
   */
  export type SocialLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter, which SocialLinks to fetch.
     */
    where?: SocialLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLinks to fetch.
     */
    orderBy?: SocialLinkOrderByWithRelationInput | SocialLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialLinks.
     */
    cursor?: SocialLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLinks.
     */
    skip?: number
    distinct?: SocialLinkScalarFieldEnum | SocialLinkScalarFieldEnum[]
  }

  /**
   * SocialLink create
   */
  export type SocialLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialLink.
     */
    data: XOR<SocialLinkCreateInput, SocialLinkUncheckedCreateInput>
  }

  /**
   * SocialLink createMany
   */
  export type SocialLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialLinks.
     */
    data: SocialLinkCreateManyInput | SocialLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialLink update
   */
  export type SocialLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialLink.
     */
    data: XOR<SocialLinkUpdateInput, SocialLinkUncheckedUpdateInput>
    /**
     * Choose, which SocialLink to update.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink updateMany
   */
  export type SocialLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialLinks.
     */
    data: XOR<SocialLinkUpdateManyMutationInput, SocialLinkUncheckedUpdateManyInput>
    /**
     * Filter which SocialLinks to update
     */
    where?: SocialLinkWhereInput
    /**
     * Limit how many SocialLinks to update.
     */
    limit?: number
  }

  /**
   * SocialLink upsert
   */
  export type SocialLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialLink to update in case it exists.
     */
    where: SocialLinkWhereUniqueInput
    /**
     * In case the SocialLink found by the `where` argument doesn't exist, create a new SocialLink with this data.
     */
    create: XOR<SocialLinkCreateInput, SocialLinkUncheckedCreateInput>
    /**
     * In case the SocialLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialLinkUpdateInput, SocialLinkUncheckedUpdateInput>
  }

  /**
   * SocialLink delete
   */
  export type SocialLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
    /**
     * Filter which SocialLink to delete.
     */
    where: SocialLinkWhereUniqueInput
  }

  /**
   * SocialLink deleteMany
   */
  export type SocialLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLinks to delete
     */
    where?: SocialLinkWhereInput
    /**
     * Limit how many SocialLinks to delete.
     */
    limit?: number
  }

  /**
   * SocialLink without action
   */
  export type SocialLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLink
     */
    select?: SocialLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialLink
     */
    omit?: SocialLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialLinkInclude<ExtArgs> | null
  }


  /**
   * Model Show
   */

  export type AggregateShow = {
    _count: ShowCountAggregateOutputType | null
    _avg: ShowAvgAggregateOutputType | null
    _sum: ShowSumAggregateOutputType | null
    _min: ShowMinAggregateOutputType | null
    _max: ShowMaxAggregateOutputType | null
  }

  export type ShowAvgAggregateOutputType = {
    number: number | null
  }

  export type ShowSumAggregateOutputType = {
    number: number | null
  }

  export type ShowMinAggregateOutputType = {
    id: string | null
    number: number | null
    title: string | null
    date: Date | null
    url: string | null
    youtube_url: string | null
    spotify_id: string | null
    show_notes: string | null
    hash: string | null
    slug: string | null
    md_file: string | null
    created_at: Date | null
    updated_at: Date | null
    show_type: $Enums.ShowType | null
  }

  export type ShowMaxAggregateOutputType = {
    id: string | null
    number: number | null
    title: string | null
    date: Date | null
    url: string | null
    youtube_url: string | null
    spotify_id: string | null
    show_notes: string | null
    hash: string | null
    slug: string | null
    md_file: string | null
    created_at: Date | null
    updated_at: Date | null
    show_type: $Enums.ShowType | null
  }

  export type ShowCountAggregateOutputType = {
    id: number
    number: number
    title: number
    date: number
    url: number
    youtube_url: number
    spotify_id: number
    show_notes: number
    hash: number
    slug: number
    md_file: number
    created_at: number
    updated_at: number
    show_type: number
    _all: number
  }


  export type ShowAvgAggregateInputType = {
    number?: true
  }

  export type ShowSumAggregateInputType = {
    number?: true
  }

  export type ShowMinAggregateInputType = {
    id?: true
    number?: true
    title?: true
    date?: true
    url?: true
    youtube_url?: true
    spotify_id?: true
    show_notes?: true
    hash?: true
    slug?: true
    md_file?: true
    created_at?: true
    updated_at?: true
    show_type?: true
  }

  export type ShowMaxAggregateInputType = {
    id?: true
    number?: true
    title?: true
    date?: true
    url?: true
    youtube_url?: true
    spotify_id?: true
    show_notes?: true
    hash?: true
    slug?: true
    md_file?: true
    created_at?: true
    updated_at?: true
    show_type?: true
  }

  export type ShowCountAggregateInputType = {
    id?: true
    number?: true
    title?: true
    date?: true
    url?: true
    youtube_url?: true
    spotify_id?: true
    show_notes?: true
    hash?: true
    slug?: true
    md_file?: true
    created_at?: true
    updated_at?: true
    show_type?: true
    _all?: true
  }

  export type ShowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Show to aggregate.
     */
    where?: ShowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shows to fetch.
     */
    orderBy?: ShowOrderByWithRelationInput | ShowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shows
    **/
    _count?: true | ShowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShowMaxAggregateInputType
  }

  export type GetShowAggregateType<T extends ShowAggregateArgs> = {
        [P in keyof T & keyof AggregateShow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShow[P]>
      : GetScalarType<T[P], AggregateShow[P]>
  }




  export type ShowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowWhereInput
    orderBy?: ShowOrderByWithAggregationInput | ShowOrderByWithAggregationInput[]
    by: ShowScalarFieldEnum[] | ShowScalarFieldEnum
    having?: ShowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShowCountAggregateInputType | true
    _avg?: ShowAvgAggregateInputType
    _sum?: ShowSumAggregateInputType
    _min?: ShowMinAggregateInputType
    _max?: ShowMaxAggregateInputType
  }

  export type ShowGroupByOutputType = {
    id: string
    number: number
    title: string
    date: Date
    url: string
    youtube_url: string | null
    spotify_id: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at: Date
    updated_at: Date
    show_type: $Enums.ShowType
    _count: ShowCountAggregateOutputType | null
    _avg: ShowAvgAggregateOutputType | null
    _sum: ShowSumAggregateOutputType | null
    _min: ShowMinAggregateOutputType | null
    _max: ShowMaxAggregateOutputType | null
  }

  type GetShowGroupByPayload<T extends ShowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShowGroupByOutputType[P]>
            : GetScalarType<T[P], ShowGroupByOutputType[P]>
        }
      >
    >


  export type ShowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    title?: boolean
    date?: boolean
    url?: boolean
    youtube_url?: boolean
    spotify_id?: boolean
    show_notes?: boolean
    hash?: boolean
    slug?: boolean
    md_file?: boolean
    created_at?: boolean
    updated_at?: boolean
    show_type?: boolean
    guests?: boolean | Show$guestsArgs<ExtArgs>
    transcript?: boolean | Show$transcriptArgs<ExtArgs>
    aiShowNote?: boolean | Show$aiShowNoteArgs<ExtArgs>
    videos?: boolean | Show$videosArgs<ExtArgs>
    hosts?: boolean | Show$hostsArgs<ExtArgs>
    _count?: boolean | ShowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["show"]>



  export type ShowSelectScalar = {
    id?: boolean
    number?: boolean
    title?: boolean
    date?: boolean
    url?: boolean
    youtube_url?: boolean
    spotify_id?: boolean
    show_notes?: boolean
    hash?: boolean
    slug?: boolean
    md_file?: boolean
    created_at?: boolean
    updated_at?: boolean
    show_type?: boolean
  }

  export type ShowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "title" | "date" | "url" | "youtube_url" | "spotify_id" | "show_notes" | "hash" | "slug" | "md_file" | "created_at" | "updated_at" | "show_type", ExtArgs["result"]["show"]>
  export type ShowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guests?: boolean | Show$guestsArgs<ExtArgs>
    transcript?: boolean | Show$transcriptArgs<ExtArgs>
    aiShowNote?: boolean | Show$aiShowNoteArgs<ExtArgs>
    videos?: boolean | Show$videosArgs<ExtArgs>
    hosts?: boolean | Show$hostsArgs<ExtArgs>
    _count?: boolean | ShowCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Show"
    objects: {
      guests: Prisma.$ShowGuestPayload<ExtArgs>[]
      transcript: Prisma.$TranscriptPayload<ExtArgs> | null
      aiShowNote: Prisma.$AiShowNotePayload<ExtArgs> | null
      videos: Prisma.$ShowVideoPayload<ExtArgs>[]
      hosts: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: number
      title: string
      date: Date
      url: string
      youtube_url: string | null
      spotify_id: string | null
      show_notes: string
      hash: string
      slug: string
      md_file: string
      created_at: Date
      updated_at: Date
      show_type: $Enums.ShowType
    }, ExtArgs["result"]["show"]>
    composites: {}
  }

  type ShowGetPayload<S extends boolean | null | undefined | ShowDefaultArgs> = $Result.GetResult<Prisma.$ShowPayload, S>

  type ShowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShowCountAggregateInputType | true
    }

  export interface ShowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Show'], meta: { name: 'Show' } }
    /**
     * Find zero or one Show that matches the filter.
     * @param {ShowFindUniqueArgs} args - Arguments to find a Show
     * @example
     * // Get one Show
     * const show = await prisma.show.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShowFindUniqueArgs>(args: SelectSubset<T, ShowFindUniqueArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Show that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShowFindUniqueOrThrowArgs} args - Arguments to find a Show
     * @example
     * // Get one Show
     * const show = await prisma.show.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShowFindUniqueOrThrowArgs>(args: SelectSubset<T, ShowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Show that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowFindFirstArgs} args - Arguments to find a Show
     * @example
     * // Get one Show
     * const show = await prisma.show.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShowFindFirstArgs>(args?: SelectSubset<T, ShowFindFirstArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Show that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowFindFirstOrThrowArgs} args - Arguments to find a Show
     * @example
     * // Get one Show
     * const show = await prisma.show.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShowFindFirstOrThrowArgs>(args?: SelectSubset<T, ShowFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shows
     * const shows = await prisma.show.findMany()
     * 
     * // Get first 10 Shows
     * const shows = await prisma.show.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const showWithIdOnly = await prisma.show.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShowFindManyArgs>(args?: SelectSubset<T, ShowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Show.
     * @param {ShowCreateArgs} args - Arguments to create a Show.
     * @example
     * // Create one Show
     * const Show = await prisma.show.create({
     *   data: {
     *     // ... data to create a Show
     *   }
     * })
     * 
     */
    create<T extends ShowCreateArgs>(args: SelectSubset<T, ShowCreateArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shows.
     * @param {ShowCreateManyArgs} args - Arguments to create many Shows.
     * @example
     * // Create many Shows
     * const show = await prisma.show.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShowCreateManyArgs>(args?: SelectSubset<T, ShowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Show.
     * @param {ShowDeleteArgs} args - Arguments to delete one Show.
     * @example
     * // Delete one Show
     * const Show = await prisma.show.delete({
     *   where: {
     *     // ... filter to delete one Show
     *   }
     * })
     * 
     */
    delete<T extends ShowDeleteArgs>(args: SelectSubset<T, ShowDeleteArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Show.
     * @param {ShowUpdateArgs} args - Arguments to update one Show.
     * @example
     * // Update one Show
     * const show = await prisma.show.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShowUpdateArgs>(args: SelectSubset<T, ShowUpdateArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shows.
     * @param {ShowDeleteManyArgs} args - Arguments to filter Shows to delete.
     * @example
     * // Delete a few Shows
     * const { count } = await prisma.show.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShowDeleteManyArgs>(args?: SelectSubset<T, ShowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shows
     * const show = await prisma.show.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShowUpdateManyArgs>(args: SelectSubset<T, ShowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Show.
     * @param {ShowUpsertArgs} args - Arguments to update or create a Show.
     * @example
     * // Update or create a Show
     * const show = await prisma.show.upsert({
     *   create: {
     *     // ... data to create a Show
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Show we want to update
     *   }
     * })
     */
    upsert<T extends ShowUpsertArgs>(args: SelectSubset<T, ShowUpsertArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowCountArgs} args - Arguments to filter Shows to count.
     * @example
     * // Count the number of Shows
     * const count = await prisma.show.count({
     *   where: {
     *     // ... the filter for the Shows we want to count
     *   }
     * })
    **/
    count<T extends ShowCountArgs>(
      args?: Subset<T, ShowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Show.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShowAggregateArgs>(args: Subset<T, ShowAggregateArgs>): Prisma.PrismaPromise<GetShowAggregateType<T>>

    /**
     * Group by Show.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShowGroupByArgs['orderBy'] }
        : { orderBy?: ShowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Show model
   */
  readonly fields: ShowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Show.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guests<T extends Show$guestsArgs<ExtArgs> = {}>(args?: Subset<T, Show$guestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transcript<T extends Show$transcriptArgs<ExtArgs> = {}>(args?: Subset<T, Show$transcriptArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    aiShowNote<T extends Show$aiShowNoteArgs<ExtArgs> = {}>(args?: Subset<T, Show$aiShowNoteArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    videos<T extends Show$videosArgs<ExtArgs> = {}>(args?: Subset<T, Show$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hosts<T extends Show$hostsArgs<ExtArgs> = {}>(args?: Subset<T, Show$hostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Show model
   */
  interface ShowFieldRefs {
    readonly id: FieldRef<"Show", 'String'>
    readonly number: FieldRef<"Show", 'Int'>
    readonly title: FieldRef<"Show", 'String'>
    readonly date: FieldRef<"Show", 'DateTime'>
    readonly url: FieldRef<"Show", 'String'>
    readonly youtube_url: FieldRef<"Show", 'String'>
    readonly spotify_id: FieldRef<"Show", 'String'>
    readonly show_notes: FieldRef<"Show", 'String'>
    readonly hash: FieldRef<"Show", 'String'>
    readonly slug: FieldRef<"Show", 'String'>
    readonly md_file: FieldRef<"Show", 'String'>
    readonly created_at: FieldRef<"Show", 'DateTime'>
    readonly updated_at: FieldRef<"Show", 'DateTime'>
    readonly show_type: FieldRef<"Show", 'ShowType'>
  }
    

  // Custom InputTypes
  /**
   * Show findUnique
   */
  export type ShowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    /**
     * Filter, which Show to fetch.
     */
    where: ShowWhereUniqueInput
  }

  /**
   * Show findUniqueOrThrow
   */
  export type ShowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    /**
     * Filter, which Show to fetch.
     */
    where: ShowWhereUniqueInput
  }

  /**
   * Show findFirst
   */
  export type ShowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    /**
     * Filter, which Show to fetch.
     */
    where?: ShowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shows to fetch.
     */
    orderBy?: ShowOrderByWithRelationInput | ShowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shows.
     */
    cursor?: ShowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shows.
     */
    distinct?: ShowScalarFieldEnum | ShowScalarFieldEnum[]
  }

  /**
   * Show findFirstOrThrow
   */
  export type ShowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    /**
     * Filter, which Show to fetch.
     */
    where?: ShowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shows to fetch.
     */
    orderBy?: ShowOrderByWithRelationInput | ShowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shows.
     */
    cursor?: ShowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shows.
     */
    distinct?: ShowScalarFieldEnum | ShowScalarFieldEnum[]
  }

  /**
   * Show findMany
   */
  export type ShowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    /**
     * Filter, which Shows to fetch.
     */
    where?: ShowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shows to fetch.
     */
    orderBy?: ShowOrderByWithRelationInput | ShowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shows.
     */
    cursor?: ShowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shows.
     */
    skip?: number
    distinct?: ShowScalarFieldEnum | ShowScalarFieldEnum[]
  }

  /**
   * Show create
   */
  export type ShowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    /**
     * The data needed to create a Show.
     */
    data: XOR<ShowCreateInput, ShowUncheckedCreateInput>
  }

  /**
   * Show createMany
   */
  export type ShowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shows.
     */
    data: ShowCreateManyInput | ShowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Show update
   */
  export type ShowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    /**
     * The data needed to update a Show.
     */
    data: XOR<ShowUpdateInput, ShowUncheckedUpdateInput>
    /**
     * Choose, which Show to update.
     */
    where: ShowWhereUniqueInput
  }

  /**
   * Show updateMany
   */
  export type ShowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shows.
     */
    data: XOR<ShowUpdateManyMutationInput, ShowUncheckedUpdateManyInput>
    /**
     * Filter which Shows to update
     */
    where?: ShowWhereInput
    /**
     * Limit how many Shows to update.
     */
    limit?: number
  }

  /**
   * Show upsert
   */
  export type ShowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    /**
     * The filter to search for the Show to update in case it exists.
     */
    where: ShowWhereUniqueInput
    /**
     * In case the Show found by the `where` argument doesn't exist, create a new Show with this data.
     */
    create: XOR<ShowCreateInput, ShowUncheckedCreateInput>
    /**
     * In case the Show was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShowUpdateInput, ShowUncheckedUpdateInput>
  }

  /**
   * Show delete
   */
  export type ShowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
    /**
     * Filter which Show to delete.
     */
    where: ShowWhereUniqueInput
  }

  /**
   * Show deleteMany
   */
  export type ShowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shows to delete
     */
    where?: ShowWhereInput
    /**
     * Limit how many Shows to delete.
     */
    limit?: number
  }

  /**
   * Show.guests
   */
  export type Show$guestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    where?: ShowGuestWhereInput
    orderBy?: ShowGuestOrderByWithRelationInput | ShowGuestOrderByWithRelationInput[]
    cursor?: ShowGuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowGuestScalarFieldEnum | ShowGuestScalarFieldEnum[]
  }

  /**
   * Show.transcript
   */
  export type Show$transcriptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    where?: TranscriptWhereInput
  }

  /**
   * Show.aiShowNote
   */
  export type Show$aiShowNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    where?: AiShowNoteWhereInput
  }

  /**
   * Show.videos
   */
  export type Show$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    where?: ShowVideoWhereInput
    orderBy?: ShowVideoOrderByWithRelationInput | ShowVideoOrderByWithRelationInput[]
    cursor?: ShowVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowVideoScalarFieldEnum | ShowVideoScalarFieldEnum[]
  }

  /**
   * Show.hosts
   */
  export type Show$hostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Show without action
   */
  export type ShowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Show
     */
    select?: ShowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Show
     */
    omit?: ShowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowInclude<ExtArgs> | null
  }


  /**
   * Model Transcript
   */

  export type AggregateTranscript = {
    _count: TranscriptCountAggregateOutputType | null
    _avg: TranscriptAvgAggregateOutputType | null
    _sum: TranscriptSumAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  export type TranscriptAvgAggregateOutputType = {
    show_number: number | null
  }

  export type TranscriptSumAggregateOutputType = {
    show_number: number | null
  }

  export type TranscriptMinAggregateOutputType = {
    id: string | null
    show_number: number | null
  }

  export type TranscriptMaxAggregateOutputType = {
    id: string | null
    show_number: number | null
  }

  export type TranscriptCountAggregateOutputType = {
    id: number
    show_number: number
    _all: number
  }


  export type TranscriptAvgAggregateInputType = {
    show_number?: true
  }

  export type TranscriptSumAggregateInputType = {
    show_number?: true
  }

  export type TranscriptMinAggregateInputType = {
    id?: true
    show_number?: true
  }

  export type TranscriptMaxAggregateInputType = {
    id?: true
    show_number?: true
  }

  export type TranscriptCountAggregateInputType = {
    id?: true
    show_number?: true
    _all?: true
  }

  export type TranscriptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcript to aggregate.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transcripts
    **/
    _count?: true | TranscriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptMaxAggregateInputType
  }

  export type GetTranscriptAggregateType<T extends TranscriptAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscript[P]>
      : GetScalarType<T[P], AggregateTranscript[P]>
  }




  export type TranscriptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptWhereInput
    orderBy?: TranscriptOrderByWithAggregationInput | TranscriptOrderByWithAggregationInput[]
    by: TranscriptScalarFieldEnum[] | TranscriptScalarFieldEnum
    having?: TranscriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptCountAggregateInputType | true
    _avg?: TranscriptAvgAggregateInputType
    _sum?: TranscriptSumAggregateInputType
    _min?: TranscriptMinAggregateInputType
    _max?: TranscriptMaxAggregateInputType
  }

  export type TranscriptGroupByOutputType = {
    id: string
    show_number: number
    _count: TranscriptCountAggregateOutputType | null
    _avg: TranscriptAvgAggregateOutputType | null
    _sum: TranscriptSumAggregateOutputType | null
    _min: TranscriptMinAggregateOutputType | null
    _max: TranscriptMaxAggregateOutputType | null
  }

  type GetTranscriptGroupByPayload<T extends TranscriptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    show_number?: boolean
    show?: boolean | ShowDefaultArgs<ExtArgs>
    utterances?: boolean | Transcript$utterancesArgs<ExtArgs>
    ShowGuest?: boolean | Transcript$ShowGuestArgs<ExtArgs>
    _count?: boolean | TranscriptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcript"]>



  export type TranscriptSelectScalar = {
    id?: boolean
    show_number?: boolean
  }

  export type TranscriptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "show_number", ExtArgs["result"]["transcript"]>
  export type TranscriptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    show?: boolean | ShowDefaultArgs<ExtArgs>
    utterances?: boolean | Transcript$utterancesArgs<ExtArgs>
    ShowGuest?: boolean | Transcript$ShowGuestArgs<ExtArgs>
    _count?: boolean | TranscriptCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TranscriptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transcript"
    objects: {
      show: Prisma.$ShowPayload<ExtArgs>
      utterances: Prisma.$TranscriptUtterancePayload<ExtArgs>[]
      ShowGuest: Prisma.$ShowGuestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      show_number: number
    }, ExtArgs["result"]["transcript"]>
    composites: {}
  }

  type TranscriptGetPayload<S extends boolean | null | undefined | TranscriptDefaultArgs> = $Result.GetResult<Prisma.$TranscriptPayload, S>

  type TranscriptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranscriptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranscriptCountAggregateInputType | true
    }

  export interface TranscriptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transcript'], meta: { name: 'Transcript' } }
    /**
     * Find zero or one Transcript that matches the filter.
     * @param {TranscriptFindUniqueArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptFindUniqueArgs>(args: SelectSubset<T, TranscriptFindUniqueArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transcript that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptFindUniqueOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transcript that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptFindFirstArgs>(args?: SelectSubset<T, TranscriptFindFirstArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transcript that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindFirstOrThrowArgs} args - Arguments to find a Transcript
     * @example
     * // Get one Transcript
     * const transcript = await prisma.transcript.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transcripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transcripts
     * const transcripts = await prisma.transcript.findMany()
     * 
     * // Get first 10 Transcripts
     * const transcripts = await prisma.transcript.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptWithIdOnly = await prisma.transcript.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptFindManyArgs>(args?: SelectSubset<T, TranscriptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transcript.
     * @param {TranscriptCreateArgs} args - Arguments to create a Transcript.
     * @example
     * // Create one Transcript
     * const Transcript = await prisma.transcript.create({
     *   data: {
     *     // ... data to create a Transcript
     *   }
     * })
     * 
     */
    create<T extends TranscriptCreateArgs>(args: SelectSubset<T, TranscriptCreateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transcripts.
     * @param {TranscriptCreateManyArgs} args - Arguments to create many Transcripts.
     * @example
     * // Create many Transcripts
     * const transcript = await prisma.transcript.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptCreateManyArgs>(args?: SelectSubset<T, TranscriptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transcript.
     * @param {TranscriptDeleteArgs} args - Arguments to delete one Transcript.
     * @example
     * // Delete one Transcript
     * const Transcript = await prisma.transcript.delete({
     *   where: {
     *     // ... filter to delete one Transcript
     *   }
     * })
     * 
     */
    delete<T extends TranscriptDeleteArgs>(args: SelectSubset<T, TranscriptDeleteArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transcript.
     * @param {TranscriptUpdateArgs} args - Arguments to update one Transcript.
     * @example
     * // Update one Transcript
     * const transcript = await prisma.transcript.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptUpdateArgs>(args: SelectSubset<T, TranscriptUpdateArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transcripts.
     * @param {TranscriptDeleteManyArgs} args - Arguments to filter Transcripts to delete.
     * @example
     * // Delete a few Transcripts
     * const { count } = await prisma.transcript.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptDeleteManyArgs>(args?: SelectSubset<T, TranscriptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transcripts
     * const transcript = await prisma.transcript.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptUpdateManyArgs>(args: SelectSubset<T, TranscriptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transcript.
     * @param {TranscriptUpsertArgs} args - Arguments to update or create a Transcript.
     * @example
     * // Update or create a Transcript
     * const transcript = await prisma.transcript.upsert({
     *   create: {
     *     // ... data to create a Transcript
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transcript we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptUpsertArgs>(args: SelectSubset<T, TranscriptUpsertArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transcripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptCountArgs} args - Arguments to filter Transcripts to count.
     * @example
     * // Count the number of Transcripts
     * const count = await prisma.transcript.count({
     *   where: {
     *     // ... the filter for the Transcripts we want to count
     *   }
     * })
    **/
    count<T extends TranscriptCountArgs>(
      args?: Subset<T, TranscriptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptAggregateArgs>(args: Subset<T, TranscriptAggregateArgs>): Prisma.PrismaPromise<GetTranscriptAggregateType<T>>

    /**
     * Group by Transcript.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transcript model
   */
  readonly fields: TranscriptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transcript.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    show<T extends ShowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowDefaultArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    utterances<T extends Transcript$utterancesArgs<ExtArgs> = {}>(args?: Subset<T, Transcript$utterancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ShowGuest<T extends Transcript$ShowGuestArgs<ExtArgs> = {}>(args?: Subset<T, Transcript$ShowGuestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transcript model
   */
  interface TranscriptFieldRefs {
    readonly id: FieldRef<"Transcript", 'String'>
    readonly show_number: FieldRef<"Transcript", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Transcript findUnique
   */
  export type TranscriptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findUniqueOrThrow
   */
  export type TranscriptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript findFirst
   */
  export type TranscriptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findFirstOrThrow
   */
  export type TranscriptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcript to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transcripts.
     */
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript findMany
   */
  export type TranscriptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter, which Transcripts to fetch.
     */
    where?: TranscriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transcripts to fetch.
     */
    orderBy?: TranscriptOrderByWithRelationInput | TranscriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transcripts.
     */
    cursor?: TranscriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transcripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transcripts.
     */
    skip?: number
    distinct?: TranscriptScalarFieldEnum | TranscriptScalarFieldEnum[]
  }

  /**
   * Transcript create
   */
  export type TranscriptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to create a Transcript.
     */
    data: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
  }

  /**
   * Transcript createMany
   */
  export type TranscriptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transcripts.
     */
    data: TranscriptCreateManyInput | TranscriptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transcript update
   */
  export type TranscriptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The data needed to update a Transcript.
     */
    data: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
    /**
     * Choose, which Transcript to update.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript updateMany
   */
  export type TranscriptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transcripts.
     */
    data: XOR<TranscriptUpdateManyMutationInput, TranscriptUncheckedUpdateManyInput>
    /**
     * Filter which Transcripts to update
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to update.
     */
    limit?: number
  }

  /**
   * Transcript upsert
   */
  export type TranscriptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * The filter to search for the Transcript to update in case it exists.
     */
    where: TranscriptWhereUniqueInput
    /**
     * In case the Transcript found by the `where` argument doesn't exist, create a new Transcript with this data.
     */
    create: XOR<TranscriptCreateInput, TranscriptUncheckedCreateInput>
    /**
     * In case the Transcript was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptUpdateInput, TranscriptUncheckedUpdateInput>
  }

  /**
   * Transcript delete
   */
  export type TranscriptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
    /**
     * Filter which Transcript to delete.
     */
    where: TranscriptWhereUniqueInput
  }

  /**
   * Transcript deleteMany
   */
  export type TranscriptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transcripts to delete
     */
    where?: TranscriptWhereInput
    /**
     * Limit how many Transcripts to delete.
     */
    limit?: number
  }

  /**
   * Transcript.utterances
   */
  export type Transcript$utterancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    where?: TranscriptUtteranceWhereInput
    orderBy?: TranscriptUtteranceOrderByWithRelationInput | TranscriptUtteranceOrderByWithRelationInput[]
    cursor?: TranscriptUtteranceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptUtteranceScalarFieldEnum | TranscriptUtteranceScalarFieldEnum[]
  }

  /**
   * Transcript.ShowGuest
   */
  export type Transcript$ShowGuestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowGuest
     */
    select?: ShowGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowGuest
     */
    omit?: ShowGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowGuestInclude<ExtArgs> | null
    where?: ShowGuestWhereInput
    orderBy?: ShowGuestOrderByWithRelationInput | ShowGuestOrderByWithRelationInput[]
    cursor?: ShowGuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowGuestScalarFieldEnum | ShowGuestScalarFieldEnum[]
  }

  /**
   * Transcript without action
   */
  export type TranscriptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transcript
     */
    select?: TranscriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transcript
     */
    omit?: TranscriptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptInclude<ExtArgs> | null
  }


  /**
   * Model TranscriptUtterance
   */

  export type AggregateTranscriptUtterance = {
    _count: TranscriptUtteranceCountAggregateOutputType | null
    _avg: TranscriptUtteranceAvgAggregateOutputType | null
    _sum: TranscriptUtteranceSumAggregateOutputType | null
    _min: TranscriptUtteranceMinAggregateOutputType | null
    _max: TranscriptUtteranceMaxAggregateOutputType | null
  }

  export type TranscriptUtteranceAvgAggregateOutputType = {
    start: number | null
    end: number | null
    confidence: number | null
    channel: number | null
    speaker: number | null
  }

  export type TranscriptUtteranceSumAggregateOutputType = {
    start: number | null
    end: number | null
    confidence: number | null
    channel: number | null
    speaker: number | null
  }

  export type TranscriptUtteranceMinAggregateOutputType = {
    id: string | null
    start: number | null
    end: number | null
    confidence: number | null
    channel: number | null
    transcript_value: string | null
    speaker: number | null
    speakerName: string | null
    transcriptId: string | null
  }

  export type TranscriptUtteranceMaxAggregateOutputType = {
    id: string | null
    start: number | null
    end: number | null
    confidence: number | null
    channel: number | null
    transcript_value: string | null
    speaker: number | null
    speakerName: string | null
    transcriptId: string | null
  }

  export type TranscriptUtteranceCountAggregateOutputType = {
    id: number
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: number
    speaker: number
    speakerName: number
    transcriptId: number
    _all: number
  }


  export type TranscriptUtteranceAvgAggregateInputType = {
    start?: true
    end?: true
    confidence?: true
    channel?: true
    speaker?: true
  }

  export type TranscriptUtteranceSumAggregateInputType = {
    start?: true
    end?: true
    confidence?: true
    channel?: true
    speaker?: true
  }

  export type TranscriptUtteranceMinAggregateInputType = {
    id?: true
    start?: true
    end?: true
    confidence?: true
    channel?: true
    transcript_value?: true
    speaker?: true
    speakerName?: true
    transcriptId?: true
  }

  export type TranscriptUtteranceMaxAggregateInputType = {
    id?: true
    start?: true
    end?: true
    confidence?: true
    channel?: true
    transcript_value?: true
    speaker?: true
    speakerName?: true
    transcriptId?: true
  }

  export type TranscriptUtteranceCountAggregateInputType = {
    id?: true
    start?: true
    end?: true
    confidence?: true
    channel?: true
    transcript_value?: true
    speaker?: true
    speakerName?: true
    transcriptId?: true
    _all?: true
  }

  export type TranscriptUtteranceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptUtterance to aggregate.
     */
    where?: TranscriptUtteranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptUtterances to fetch.
     */
    orderBy?: TranscriptUtteranceOrderByWithRelationInput | TranscriptUtteranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptUtteranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptUtterances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptUtterances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranscriptUtterances
    **/
    _count?: true | TranscriptUtteranceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptUtteranceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptUtteranceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptUtteranceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptUtteranceMaxAggregateInputType
  }

  export type GetTranscriptUtteranceAggregateType<T extends TranscriptUtteranceAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscriptUtterance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptUtterance[P]>
      : GetScalarType<T[P], AggregateTranscriptUtterance[P]>
  }




  export type TranscriptUtteranceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptUtteranceWhereInput
    orderBy?: TranscriptUtteranceOrderByWithAggregationInput | TranscriptUtteranceOrderByWithAggregationInput[]
    by: TranscriptUtteranceScalarFieldEnum[] | TranscriptUtteranceScalarFieldEnum
    having?: TranscriptUtteranceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptUtteranceCountAggregateInputType | true
    _avg?: TranscriptUtteranceAvgAggregateInputType
    _sum?: TranscriptUtteranceSumAggregateInputType
    _min?: TranscriptUtteranceMinAggregateInputType
    _max?: TranscriptUtteranceMaxAggregateInputType
  }

  export type TranscriptUtteranceGroupByOutputType = {
    id: string
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: string
    speaker: number
    speakerName: string | null
    transcriptId: string
    _count: TranscriptUtteranceCountAggregateOutputType | null
    _avg: TranscriptUtteranceAvgAggregateOutputType | null
    _sum: TranscriptUtteranceSumAggregateOutputType | null
    _min: TranscriptUtteranceMinAggregateOutputType | null
    _max: TranscriptUtteranceMaxAggregateOutputType | null
  }

  type GetTranscriptUtteranceGroupByPayload<T extends TranscriptUtteranceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptUtteranceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptUtteranceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptUtteranceGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptUtteranceGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptUtteranceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start?: boolean
    end?: boolean
    confidence?: boolean
    channel?: boolean
    transcript_value?: boolean
    speaker?: boolean
    speakerName?: boolean
    transcriptId?: boolean
    words?: boolean | TranscriptUtterance$wordsArgs<ExtArgs>
    transcript?: boolean | TranscriptDefaultArgs<ExtArgs>
    _count?: boolean | TranscriptUtteranceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptUtterance"]>



  export type TranscriptUtteranceSelectScalar = {
    id?: boolean
    start?: boolean
    end?: boolean
    confidence?: boolean
    channel?: boolean
    transcript_value?: boolean
    speaker?: boolean
    speakerName?: boolean
    transcriptId?: boolean
  }

  export type TranscriptUtteranceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "start" | "end" | "confidence" | "channel" | "transcript_value" | "speaker" | "speakerName" | "transcriptId", ExtArgs["result"]["transcriptUtterance"]>
  export type TranscriptUtteranceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    words?: boolean | TranscriptUtterance$wordsArgs<ExtArgs>
    transcript?: boolean | TranscriptDefaultArgs<ExtArgs>
    _count?: boolean | TranscriptUtteranceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TranscriptUtterancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TranscriptUtterance"
    objects: {
      words: Prisma.$TranscriptUtteranceWordPayload<ExtArgs>[]
      transcript: Prisma.$TranscriptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      start: number
      end: number
      confidence: number
      channel: number
      transcript_value: string
      speaker: number
      speakerName: string | null
      transcriptId: string
    }, ExtArgs["result"]["transcriptUtterance"]>
    composites: {}
  }

  type TranscriptUtteranceGetPayload<S extends boolean | null | undefined | TranscriptUtteranceDefaultArgs> = $Result.GetResult<Prisma.$TranscriptUtterancePayload, S>

  type TranscriptUtteranceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranscriptUtteranceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranscriptUtteranceCountAggregateInputType | true
    }

  export interface TranscriptUtteranceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TranscriptUtterance'], meta: { name: 'TranscriptUtterance' } }
    /**
     * Find zero or one TranscriptUtterance that matches the filter.
     * @param {TranscriptUtteranceFindUniqueArgs} args - Arguments to find a TranscriptUtterance
     * @example
     * // Get one TranscriptUtterance
     * const transcriptUtterance = await prisma.transcriptUtterance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptUtteranceFindUniqueArgs>(args: SelectSubset<T, TranscriptUtteranceFindUniqueArgs<ExtArgs>>): Prisma__TranscriptUtteranceClient<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TranscriptUtterance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptUtteranceFindUniqueOrThrowArgs} args - Arguments to find a TranscriptUtterance
     * @example
     * // Get one TranscriptUtterance
     * const transcriptUtterance = await prisma.transcriptUtterance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptUtteranceFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptUtteranceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptUtteranceClient<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptUtterance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceFindFirstArgs} args - Arguments to find a TranscriptUtterance
     * @example
     * // Get one TranscriptUtterance
     * const transcriptUtterance = await prisma.transcriptUtterance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptUtteranceFindFirstArgs>(args?: SelectSubset<T, TranscriptUtteranceFindFirstArgs<ExtArgs>>): Prisma__TranscriptUtteranceClient<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptUtterance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceFindFirstOrThrowArgs} args - Arguments to find a TranscriptUtterance
     * @example
     * // Get one TranscriptUtterance
     * const transcriptUtterance = await prisma.transcriptUtterance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptUtteranceFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptUtteranceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptUtteranceClient<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TranscriptUtterances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptUtterances
     * const transcriptUtterances = await prisma.transcriptUtterance.findMany()
     * 
     * // Get first 10 TranscriptUtterances
     * const transcriptUtterances = await prisma.transcriptUtterance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptUtteranceWithIdOnly = await prisma.transcriptUtterance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptUtteranceFindManyArgs>(args?: SelectSubset<T, TranscriptUtteranceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TranscriptUtterance.
     * @param {TranscriptUtteranceCreateArgs} args - Arguments to create a TranscriptUtterance.
     * @example
     * // Create one TranscriptUtterance
     * const TranscriptUtterance = await prisma.transcriptUtterance.create({
     *   data: {
     *     // ... data to create a TranscriptUtterance
     *   }
     * })
     * 
     */
    create<T extends TranscriptUtteranceCreateArgs>(args: SelectSubset<T, TranscriptUtteranceCreateArgs<ExtArgs>>): Prisma__TranscriptUtteranceClient<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TranscriptUtterances.
     * @param {TranscriptUtteranceCreateManyArgs} args - Arguments to create many TranscriptUtterances.
     * @example
     * // Create many TranscriptUtterances
     * const transcriptUtterance = await prisma.transcriptUtterance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptUtteranceCreateManyArgs>(args?: SelectSubset<T, TranscriptUtteranceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TranscriptUtterance.
     * @param {TranscriptUtteranceDeleteArgs} args - Arguments to delete one TranscriptUtterance.
     * @example
     * // Delete one TranscriptUtterance
     * const TranscriptUtterance = await prisma.transcriptUtterance.delete({
     *   where: {
     *     // ... filter to delete one TranscriptUtterance
     *   }
     * })
     * 
     */
    delete<T extends TranscriptUtteranceDeleteArgs>(args: SelectSubset<T, TranscriptUtteranceDeleteArgs<ExtArgs>>): Prisma__TranscriptUtteranceClient<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TranscriptUtterance.
     * @param {TranscriptUtteranceUpdateArgs} args - Arguments to update one TranscriptUtterance.
     * @example
     * // Update one TranscriptUtterance
     * const transcriptUtterance = await prisma.transcriptUtterance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptUtteranceUpdateArgs>(args: SelectSubset<T, TranscriptUtteranceUpdateArgs<ExtArgs>>): Prisma__TranscriptUtteranceClient<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TranscriptUtterances.
     * @param {TranscriptUtteranceDeleteManyArgs} args - Arguments to filter TranscriptUtterances to delete.
     * @example
     * // Delete a few TranscriptUtterances
     * const { count } = await prisma.transcriptUtterance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptUtteranceDeleteManyArgs>(args?: SelectSubset<T, TranscriptUtteranceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptUtterances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptUtterances
     * const transcriptUtterance = await prisma.transcriptUtterance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptUtteranceUpdateManyArgs>(args: SelectSubset<T, TranscriptUtteranceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TranscriptUtterance.
     * @param {TranscriptUtteranceUpsertArgs} args - Arguments to update or create a TranscriptUtterance.
     * @example
     * // Update or create a TranscriptUtterance
     * const transcriptUtterance = await prisma.transcriptUtterance.upsert({
     *   create: {
     *     // ... data to create a TranscriptUtterance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptUtterance we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptUtteranceUpsertArgs>(args: SelectSubset<T, TranscriptUtteranceUpsertArgs<ExtArgs>>): Prisma__TranscriptUtteranceClient<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TranscriptUtterances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceCountArgs} args - Arguments to filter TranscriptUtterances to count.
     * @example
     * // Count the number of TranscriptUtterances
     * const count = await prisma.transcriptUtterance.count({
     *   where: {
     *     // ... the filter for the TranscriptUtterances we want to count
     *   }
     * })
    **/
    count<T extends TranscriptUtteranceCountArgs>(
      args?: Subset<T, TranscriptUtteranceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptUtteranceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranscriptUtterance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptUtteranceAggregateArgs>(args: Subset<T, TranscriptUtteranceAggregateArgs>): Prisma.PrismaPromise<GetTranscriptUtteranceAggregateType<T>>

    /**
     * Group by TranscriptUtterance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptUtteranceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptUtteranceGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptUtteranceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptUtteranceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptUtteranceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TranscriptUtterance model
   */
  readonly fields: TranscriptUtteranceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptUtterance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptUtteranceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    words<T extends TranscriptUtterance$wordsArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptUtterance$wordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transcript<T extends TranscriptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptDefaultArgs<ExtArgs>>): Prisma__TranscriptClient<$Result.GetResult<Prisma.$TranscriptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TranscriptUtterance model
   */
  interface TranscriptUtteranceFieldRefs {
    readonly id: FieldRef<"TranscriptUtterance", 'String'>
    readonly start: FieldRef<"TranscriptUtterance", 'Float'>
    readonly end: FieldRef<"TranscriptUtterance", 'Float'>
    readonly confidence: FieldRef<"TranscriptUtterance", 'Float'>
    readonly channel: FieldRef<"TranscriptUtterance", 'Int'>
    readonly transcript_value: FieldRef<"TranscriptUtterance", 'String'>
    readonly speaker: FieldRef<"TranscriptUtterance", 'Int'>
    readonly speakerName: FieldRef<"TranscriptUtterance", 'String'>
    readonly transcriptId: FieldRef<"TranscriptUtterance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TranscriptUtterance findUnique
   */
  export type TranscriptUtteranceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtterance to fetch.
     */
    where: TranscriptUtteranceWhereUniqueInput
  }

  /**
   * TranscriptUtterance findUniqueOrThrow
   */
  export type TranscriptUtteranceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtterance to fetch.
     */
    where: TranscriptUtteranceWhereUniqueInput
  }

  /**
   * TranscriptUtterance findFirst
   */
  export type TranscriptUtteranceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtterance to fetch.
     */
    where?: TranscriptUtteranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptUtterances to fetch.
     */
    orderBy?: TranscriptUtteranceOrderByWithRelationInput | TranscriptUtteranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptUtterances.
     */
    cursor?: TranscriptUtteranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptUtterances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptUtterances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptUtterances.
     */
    distinct?: TranscriptUtteranceScalarFieldEnum | TranscriptUtteranceScalarFieldEnum[]
  }

  /**
   * TranscriptUtterance findFirstOrThrow
   */
  export type TranscriptUtteranceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtterance to fetch.
     */
    where?: TranscriptUtteranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptUtterances to fetch.
     */
    orderBy?: TranscriptUtteranceOrderByWithRelationInput | TranscriptUtteranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptUtterances.
     */
    cursor?: TranscriptUtteranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptUtterances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptUtterances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptUtterances.
     */
    distinct?: TranscriptUtteranceScalarFieldEnum | TranscriptUtteranceScalarFieldEnum[]
  }

  /**
   * TranscriptUtterance findMany
   */
  export type TranscriptUtteranceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtterances to fetch.
     */
    where?: TranscriptUtteranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptUtterances to fetch.
     */
    orderBy?: TranscriptUtteranceOrderByWithRelationInput | TranscriptUtteranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranscriptUtterances.
     */
    cursor?: TranscriptUtteranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptUtterances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptUtterances.
     */
    skip?: number
    distinct?: TranscriptUtteranceScalarFieldEnum | TranscriptUtteranceScalarFieldEnum[]
  }

  /**
   * TranscriptUtterance create
   */
  export type TranscriptUtteranceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    /**
     * The data needed to create a TranscriptUtterance.
     */
    data: XOR<TranscriptUtteranceCreateInput, TranscriptUtteranceUncheckedCreateInput>
  }

  /**
   * TranscriptUtterance createMany
   */
  export type TranscriptUtteranceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TranscriptUtterances.
     */
    data: TranscriptUtteranceCreateManyInput | TranscriptUtteranceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranscriptUtterance update
   */
  export type TranscriptUtteranceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    /**
     * The data needed to update a TranscriptUtterance.
     */
    data: XOR<TranscriptUtteranceUpdateInput, TranscriptUtteranceUncheckedUpdateInput>
    /**
     * Choose, which TranscriptUtterance to update.
     */
    where: TranscriptUtteranceWhereUniqueInput
  }

  /**
   * TranscriptUtterance updateMany
   */
  export type TranscriptUtteranceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TranscriptUtterances.
     */
    data: XOR<TranscriptUtteranceUpdateManyMutationInput, TranscriptUtteranceUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptUtterances to update
     */
    where?: TranscriptUtteranceWhereInput
    /**
     * Limit how many TranscriptUtterances to update.
     */
    limit?: number
  }

  /**
   * TranscriptUtterance upsert
   */
  export type TranscriptUtteranceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    /**
     * The filter to search for the TranscriptUtterance to update in case it exists.
     */
    where: TranscriptUtteranceWhereUniqueInput
    /**
     * In case the TranscriptUtterance found by the `where` argument doesn't exist, create a new TranscriptUtterance with this data.
     */
    create: XOR<TranscriptUtteranceCreateInput, TranscriptUtteranceUncheckedCreateInput>
    /**
     * In case the TranscriptUtterance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptUtteranceUpdateInput, TranscriptUtteranceUncheckedUpdateInput>
  }

  /**
   * TranscriptUtterance delete
   */
  export type TranscriptUtteranceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    /**
     * Filter which TranscriptUtterance to delete.
     */
    where: TranscriptUtteranceWhereUniqueInput
  }

  /**
   * TranscriptUtterance deleteMany
   */
  export type TranscriptUtteranceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptUtterances to delete
     */
    where?: TranscriptUtteranceWhereInput
    /**
     * Limit how many TranscriptUtterances to delete.
     */
    limit?: number
  }

  /**
   * TranscriptUtterance.words
   */
  export type TranscriptUtterance$wordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    where?: TranscriptUtteranceWordWhereInput
    orderBy?: TranscriptUtteranceWordOrderByWithRelationInput | TranscriptUtteranceWordOrderByWithRelationInput[]
    cursor?: TranscriptUtteranceWordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TranscriptUtteranceWordScalarFieldEnum | TranscriptUtteranceWordScalarFieldEnum[]
  }

  /**
   * TranscriptUtterance without action
   */
  export type TranscriptUtteranceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
  }


  /**
   * Model TranscriptUtteranceWord
   */

  export type AggregateTranscriptUtteranceWord = {
    _count: TranscriptUtteranceWordCountAggregateOutputType | null
    _avg: TranscriptUtteranceWordAvgAggregateOutputType | null
    _sum: TranscriptUtteranceWordSumAggregateOutputType | null
    _min: TranscriptUtteranceWordMinAggregateOutputType | null
    _max: TranscriptUtteranceWordMaxAggregateOutputType | null
  }

  export type TranscriptUtteranceWordAvgAggregateOutputType = {
    start: number | null
    end: number | null
    confidence: number | null
    speaker: number | null
    speaker_confidence: number | null
  }

  export type TranscriptUtteranceWordSumAggregateOutputType = {
    start: number | null
    end: number | null
    confidence: number | null
    speaker: number | null
    speaker_confidence: number | null
  }

  export type TranscriptUtteranceWordMinAggregateOutputType = {
    id: string | null
    word: string | null
    start: number | null
    end: number | null
    confidence: number | null
    speaker: number | null
    speaker_confidence: number | null
    punctuated_word: string | null
    transcriptUtteranceId: string | null
  }

  export type TranscriptUtteranceWordMaxAggregateOutputType = {
    id: string | null
    word: string | null
    start: number | null
    end: number | null
    confidence: number | null
    speaker: number | null
    speaker_confidence: number | null
    punctuated_word: string | null
    transcriptUtteranceId: string | null
  }

  export type TranscriptUtteranceWordCountAggregateOutputType = {
    id: number
    word: number
    start: number
    end: number
    confidence: number
    speaker: number
    speaker_confidence: number
    punctuated_word: number
    transcriptUtteranceId: number
    _all: number
  }


  export type TranscriptUtteranceWordAvgAggregateInputType = {
    start?: true
    end?: true
    confidence?: true
    speaker?: true
    speaker_confidence?: true
  }

  export type TranscriptUtteranceWordSumAggregateInputType = {
    start?: true
    end?: true
    confidence?: true
    speaker?: true
    speaker_confidence?: true
  }

  export type TranscriptUtteranceWordMinAggregateInputType = {
    id?: true
    word?: true
    start?: true
    end?: true
    confidence?: true
    speaker?: true
    speaker_confidence?: true
    punctuated_word?: true
    transcriptUtteranceId?: true
  }

  export type TranscriptUtteranceWordMaxAggregateInputType = {
    id?: true
    word?: true
    start?: true
    end?: true
    confidence?: true
    speaker?: true
    speaker_confidence?: true
    punctuated_word?: true
    transcriptUtteranceId?: true
  }

  export type TranscriptUtteranceWordCountAggregateInputType = {
    id?: true
    word?: true
    start?: true
    end?: true
    confidence?: true
    speaker?: true
    speaker_confidence?: true
    punctuated_word?: true
    transcriptUtteranceId?: true
    _all?: true
  }

  export type TranscriptUtteranceWordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptUtteranceWord to aggregate.
     */
    where?: TranscriptUtteranceWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptUtteranceWords to fetch.
     */
    orderBy?: TranscriptUtteranceWordOrderByWithRelationInput | TranscriptUtteranceWordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranscriptUtteranceWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptUtteranceWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptUtteranceWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TranscriptUtteranceWords
    **/
    _count?: true | TranscriptUtteranceWordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranscriptUtteranceWordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranscriptUtteranceWordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranscriptUtteranceWordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranscriptUtteranceWordMaxAggregateInputType
  }

  export type GetTranscriptUtteranceWordAggregateType<T extends TranscriptUtteranceWordAggregateArgs> = {
        [P in keyof T & keyof AggregateTranscriptUtteranceWord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranscriptUtteranceWord[P]>
      : GetScalarType<T[P], AggregateTranscriptUtteranceWord[P]>
  }




  export type TranscriptUtteranceWordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranscriptUtteranceWordWhereInput
    orderBy?: TranscriptUtteranceWordOrderByWithAggregationInput | TranscriptUtteranceWordOrderByWithAggregationInput[]
    by: TranscriptUtteranceWordScalarFieldEnum[] | TranscriptUtteranceWordScalarFieldEnum
    having?: TranscriptUtteranceWordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranscriptUtteranceWordCountAggregateInputType | true
    _avg?: TranscriptUtteranceWordAvgAggregateInputType
    _sum?: TranscriptUtteranceWordSumAggregateInputType
    _min?: TranscriptUtteranceWordMinAggregateInputType
    _max?: TranscriptUtteranceWordMaxAggregateInputType
  }

  export type TranscriptUtteranceWordGroupByOutputType = {
    id: string
    word: string
    start: number
    end: number
    confidence: number
    speaker: number
    speaker_confidence: number
    punctuated_word: string
    transcriptUtteranceId: string
    _count: TranscriptUtteranceWordCountAggregateOutputType | null
    _avg: TranscriptUtteranceWordAvgAggregateOutputType | null
    _sum: TranscriptUtteranceWordSumAggregateOutputType | null
    _min: TranscriptUtteranceWordMinAggregateOutputType | null
    _max: TranscriptUtteranceWordMaxAggregateOutputType | null
  }

  type GetTranscriptUtteranceWordGroupByPayload<T extends TranscriptUtteranceWordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranscriptUtteranceWordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranscriptUtteranceWordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranscriptUtteranceWordGroupByOutputType[P]>
            : GetScalarType<T[P], TranscriptUtteranceWordGroupByOutputType[P]>
        }
      >
    >


  export type TranscriptUtteranceWordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    word?: boolean
    start?: boolean
    end?: boolean
    confidence?: boolean
    speaker?: boolean
    speaker_confidence?: boolean
    punctuated_word?: boolean
    transcriptUtteranceId?: boolean
    TranscriptUtterance?: boolean | TranscriptUtteranceWord$TranscriptUtteranceArgs<ExtArgs>
  }, ExtArgs["result"]["transcriptUtteranceWord"]>



  export type TranscriptUtteranceWordSelectScalar = {
    id?: boolean
    word?: boolean
    start?: boolean
    end?: boolean
    confidence?: boolean
    speaker?: boolean
    speaker_confidence?: boolean
    punctuated_word?: boolean
    transcriptUtteranceId?: boolean
  }

  export type TranscriptUtteranceWordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "word" | "start" | "end" | "confidence" | "speaker" | "speaker_confidence" | "punctuated_word" | "transcriptUtteranceId", ExtArgs["result"]["transcriptUtteranceWord"]>
  export type TranscriptUtteranceWordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TranscriptUtterance?: boolean | TranscriptUtteranceWord$TranscriptUtteranceArgs<ExtArgs>
  }

  export type $TranscriptUtteranceWordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TranscriptUtteranceWord"
    objects: {
      TranscriptUtterance: Prisma.$TranscriptUtterancePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      word: string
      start: number
      end: number
      confidence: number
      speaker: number
      speaker_confidence: number
      punctuated_word: string
      transcriptUtteranceId: string
    }, ExtArgs["result"]["transcriptUtteranceWord"]>
    composites: {}
  }

  type TranscriptUtteranceWordGetPayload<S extends boolean | null | undefined | TranscriptUtteranceWordDefaultArgs> = $Result.GetResult<Prisma.$TranscriptUtteranceWordPayload, S>

  type TranscriptUtteranceWordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TranscriptUtteranceWordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TranscriptUtteranceWordCountAggregateInputType | true
    }

  export interface TranscriptUtteranceWordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TranscriptUtteranceWord'], meta: { name: 'TranscriptUtteranceWord' } }
    /**
     * Find zero or one TranscriptUtteranceWord that matches the filter.
     * @param {TranscriptUtteranceWordFindUniqueArgs} args - Arguments to find a TranscriptUtteranceWord
     * @example
     * // Get one TranscriptUtteranceWord
     * const transcriptUtteranceWord = await prisma.transcriptUtteranceWord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranscriptUtteranceWordFindUniqueArgs>(args: SelectSubset<T, TranscriptUtteranceWordFindUniqueArgs<ExtArgs>>): Prisma__TranscriptUtteranceWordClient<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TranscriptUtteranceWord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TranscriptUtteranceWordFindUniqueOrThrowArgs} args - Arguments to find a TranscriptUtteranceWord
     * @example
     * // Get one TranscriptUtteranceWord
     * const transcriptUtteranceWord = await prisma.transcriptUtteranceWord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranscriptUtteranceWordFindUniqueOrThrowArgs>(args: SelectSubset<T, TranscriptUtteranceWordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranscriptUtteranceWordClient<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptUtteranceWord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceWordFindFirstArgs} args - Arguments to find a TranscriptUtteranceWord
     * @example
     * // Get one TranscriptUtteranceWord
     * const transcriptUtteranceWord = await prisma.transcriptUtteranceWord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranscriptUtteranceWordFindFirstArgs>(args?: SelectSubset<T, TranscriptUtteranceWordFindFirstArgs<ExtArgs>>): Prisma__TranscriptUtteranceWordClient<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TranscriptUtteranceWord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceWordFindFirstOrThrowArgs} args - Arguments to find a TranscriptUtteranceWord
     * @example
     * // Get one TranscriptUtteranceWord
     * const transcriptUtteranceWord = await prisma.transcriptUtteranceWord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranscriptUtteranceWordFindFirstOrThrowArgs>(args?: SelectSubset<T, TranscriptUtteranceWordFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranscriptUtteranceWordClient<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TranscriptUtteranceWords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceWordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TranscriptUtteranceWords
     * const transcriptUtteranceWords = await prisma.transcriptUtteranceWord.findMany()
     * 
     * // Get first 10 TranscriptUtteranceWords
     * const transcriptUtteranceWords = await prisma.transcriptUtteranceWord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transcriptUtteranceWordWithIdOnly = await prisma.transcriptUtteranceWord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranscriptUtteranceWordFindManyArgs>(args?: SelectSubset<T, TranscriptUtteranceWordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TranscriptUtteranceWord.
     * @param {TranscriptUtteranceWordCreateArgs} args - Arguments to create a TranscriptUtteranceWord.
     * @example
     * // Create one TranscriptUtteranceWord
     * const TranscriptUtteranceWord = await prisma.transcriptUtteranceWord.create({
     *   data: {
     *     // ... data to create a TranscriptUtteranceWord
     *   }
     * })
     * 
     */
    create<T extends TranscriptUtteranceWordCreateArgs>(args: SelectSubset<T, TranscriptUtteranceWordCreateArgs<ExtArgs>>): Prisma__TranscriptUtteranceWordClient<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TranscriptUtteranceWords.
     * @param {TranscriptUtteranceWordCreateManyArgs} args - Arguments to create many TranscriptUtteranceWords.
     * @example
     * // Create many TranscriptUtteranceWords
     * const transcriptUtteranceWord = await prisma.transcriptUtteranceWord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranscriptUtteranceWordCreateManyArgs>(args?: SelectSubset<T, TranscriptUtteranceWordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TranscriptUtteranceWord.
     * @param {TranscriptUtteranceWordDeleteArgs} args - Arguments to delete one TranscriptUtteranceWord.
     * @example
     * // Delete one TranscriptUtteranceWord
     * const TranscriptUtteranceWord = await prisma.transcriptUtteranceWord.delete({
     *   where: {
     *     // ... filter to delete one TranscriptUtteranceWord
     *   }
     * })
     * 
     */
    delete<T extends TranscriptUtteranceWordDeleteArgs>(args: SelectSubset<T, TranscriptUtteranceWordDeleteArgs<ExtArgs>>): Prisma__TranscriptUtteranceWordClient<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TranscriptUtteranceWord.
     * @param {TranscriptUtteranceWordUpdateArgs} args - Arguments to update one TranscriptUtteranceWord.
     * @example
     * // Update one TranscriptUtteranceWord
     * const transcriptUtteranceWord = await prisma.transcriptUtteranceWord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranscriptUtteranceWordUpdateArgs>(args: SelectSubset<T, TranscriptUtteranceWordUpdateArgs<ExtArgs>>): Prisma__TranscriptUtteranceWordClient<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TranscriptUtteranceWords.
     * @param {TranscriptUtteranceWordDeleteManyArgs} args - Arguments to filter TranscriptUtteranceWords to delete.
     * @example
     * // Delete a few TranscriptUtteranceWords
     * const { count } = await prisma.transcriptUtteranceWord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranscriptUtteranceWordDeleteManyArgs>(args?: SelectSubset<T, TranscriptUtteranceWordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TranscriptUtteranceWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceWordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TranscriptUtteranceWords
     * const transcriptUtteranceWord = await prisma.transcriptUtteranceWord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranscriptUtteranceWordUpdateManyArgs>(args: SelectSubset<T, TranscriptUtteranceWordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TranscriptUtteranceWord.
     * @param {TranscriptUtteranceWordUpsertArgs} args - Arguments to update or create a TranscriptUtteranceWord.
     * @example
     * // Update or create a TranscriptUtteranceWord
     * const transcriptUtteranceWord = await prisma.transcriptUtteranceWord.upsert({
     *   create: {
     *     // ... data to create a TranscriptUtteranceWord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TranscriptUtteranceWord we want to update
     *   }
     * })
     */
    upsert<T extends TranscriptUtteranceWordUpsertArgs>(args: SelectSubset<T, TranscriptUtteranceWordUpsertArgs<ExtArgs>>): Prisma__TranscriptUtteranceWordClient<$Result.GetResult<Prisma.$TranscriptUtteranceWordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TranscriptUtteranceWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceWordCountArgs} args - Arguments to filter TranscriptUtteranceWords to count.
     * @example
     * // Count the number of TranscriptUtteranceWords
     * const count = await prisma.transcriptUtteranceWord.count({
     *   where: {
     *     // ... the filter for the TranscriptUtteranceWords we want to count
     *   }
     * })
    **/
    count<T extends TranscriptUtteranceWordCountArgs>(
      args?: Subset<T, TranscriptUtteranceWordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranscriptUtteranceWordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TranscriptUtteranceWord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceWordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranscriptUtteranceWordAggregateArgs>(args: Subset<T, TranscriptUtteranceWordAggregateArgs>): Prisma.PrismaPromise<GetTranscriptUtteranceWordAggregateType<T>>

    /**
     * Group by TranscriptUtteranceWord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranscriptUtteranceWordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranscriptUtteranceWordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranscriptUtteranceWordGroupByArgs['orderBy'] }
        : { orderBy?: TranscriptUtteranceWordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranscriptUtteranceWordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranscriptUtteranceWordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TranscriptUtteranceWord model
   */
  readonly fields: TranscriptUtteranceWordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TranscriptUtteranceWord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranscriptUtteranceWordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TranscriptUtterance<T extends TranscriptUtteranceWord$TranscriptUtteranceArgs<ExtArgs> = {}>(args?: Subset<T, TranscriptUtteranceWord$TranscriptUtteranceArgs<ExtArgs>>): Prisma__TranscriptUtteranceClient<$Result.GetResult<Prisma.$TranscriptUtterancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TranscriptUtteranceWord model
   */
  interface TranscriptUtteranceWordFieldRefs {
    readonly id: FieldRef<"TranscriptUtteranceWord", 'String'>
    readonly word: FieldRef<"TranscriptUtteranceWord", 'String'>
    readonly start: FieldRef<"TranscriptUtteranceWord", 'Float'>
    readonly end: FieldRef<"TranscriptUtteranceWord", 'Float'>
    readonly confidence: FieldRef<"TranscriptUtteranceWord", 'Float'>
    readonly speaker: FieldRef<"TranscriptUtteranceWord", 'Int'>
    readonly speaker_confidence: FieldRef<"TranscriptUtteranceWord", 'Float'>
    readonly punctuated_word: FieldRef<"TranscriptUtteranceWord", 'String'>
    readonly transcriptUtteranceId: FieldRef<"TranscriptUtteranceWord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TranscriptUtteranceWord findUnique
   */
  export type TranscriptUtteranceWordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtteranceWord to fetch.
     */
    where: TranscriptUtteranceWordWhereUniqueInput
  }

  /**
   * TranscriptUtteranceWord findUniqueOrThrow
   */
  export type TranscriptUtteranceWordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtteranceWord to fetch.
     */
    where: TranscriptUtteranceWordWhereUniqueInput
  }

  /**
   * TranscriptUtteranceWord findFirst
   */
  export type TranscriptUtteranceWordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtteranceWord to fetch.
     */
    where?: TranscriptUtteranceWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptUtteranceWords to fetch.
     */
    orderBy?: TranscriptUtteranceWordOrderByWithRelationInput | TranscriptUtteranceWordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptUtteranceWords.
     */
    cursor?: TranscriptUtteranceWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptUtteranceWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptUtteranceWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptUtteranceWords.
     */
    distinct?: TranscriptUtteranceWordScalarFieldEnum | TranscriptUtteranceWordScalarFieldEnum[]
  }

  /**
   * TranscriptUtteranceWord findFirstOrThrow
   */
  export type TranscriptUtteranceWordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtteranceWord to fetch.
     */
    where?: TranscriptUtteranceWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptUtteranceWords to fetch.
     */
    orderBy?: TranscriptUtteranceWordOrderByWithRelationInput | TranscriptUtteranceWordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TranscriptUtteranceWords.
     */
    cursor?: TranscriptUtteranceWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptUtteranceWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptUtteranceWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TranscriptUtteranceWords.
     */
    distinct?: TranscriptUtteranceWordScalarFieldEnum | TranscriptUtteranceWordScalarFieldEnum[]
  }

  /**
   * TranscriptUtteranceWord findMany
   */
  export type TranscriptUtteranceWordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    /**
     * Filter, which TranscriptUtteranceWords to fetch.
     */
    where?: TranscriptUtteranceWordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TranscriptUtteranceWords to fetch.
     */
    orderBy?: TranscriptUtteranceWordOrderByWithRelationInput | TranscriptUtteranceWordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TranscriptUtteranceWords.
     */
    cursor?: TranscriptUtteranceWordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TranscriptUtteranceWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TranscriptUtteranceWords.
     */
    skip?: number
    distinct?: TranscriptUtteranceWordScalarFieldEnum | TranscriptUtteranceWordScalarFieldEnum[]
  }

  /**
   * TranscriptUtteranceWord create
   */
  export type TranscriptUtteranceWordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    /**
     * The data needed to create a TranscriptUtteranceWord.
     */
    data: XOR<TranscriptUtteranceWordCreateInput, TranscriptUtteranceWordUncheckedCreateInput>
  }

  /**
   * TranscriptUtteranceWord createMany
   */
  export type TranscriptUtteranceWordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TranscriptUtteranceWords.
     */
    data: TranscriptUtteranceWordCreateManyInput | TranscriptUtteranceWordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TranscriptUtteranceWord update
   */
  export type TranscriptUtteranceWordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    /**
     * The data needed to update a TranscriptUtteranceWord.
     */
    data: XOR<TranscriptUtteranceWordUpdateInput, TranscriptUtteranceWordUncheckedUpdateInput>
    /**
     * Choose, which TranscriptUtteranceWord to update.
     */
    where: TranscriptUtteranceWordWhereUniqueInput
  }

  /**
   * TranscriptUtteranceWord updateMany
   */
  export type TranscriptUtteranceWordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TranscriptUtteranceWords.
     */
    data: XOR<TranscriptUtteranceWordUpdateManyMutationInput, TranscriptUtteranceWordUncheckedUpdateManyInput>
    /**
     * Filter which TranscriptUtteranceWords to update
     */
    where?: TranscriptUtteranceWordWhereInput
    /**
     * Limit how many TranscriptUtteranceWords to update.
     */
    limit?: number
  }

  /**
   * TranscriptUtteranceWord upsert
   */
  export type TranscriptUtteranceWordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    /**
     * The filter to search for the TranscriptUtteranceWord to update in case it exists.
     */
    where: TranscriptUtteranceWordWhereUniqueInput
    /**
     * In case the TranscriptUtteranceWord found by the `where` argument doesn't exist, create a new TranscriptUtteranceWord with this data.
     */
    create: XOR<TranscriptUtteranceWordCreateInput, TranscriptUtteranceWordUncheckedCreateInput>
    /**
     * In case the TranscriptUtteranceWord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranscriptUtteranceWordUpdateInput, TranscriptUtteranceWordUncheckedUpdateInput>
  }

  /**
   * TranscriptUtteranceWord delete
   */
  export type TranscriptUtteranceWordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
    /**
     * Filter which TranscriptUtteranceWord to delete.
     */
    where: TranscriptUtteranceWordWhereUniqueInput
  }

  /**
   * TranscriptUtteranceWord deleteMany
   */
  export type TranscriptUtteranceWordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TranscriptUtteranceWords to delete
     */
    where?: TranscriptUtteranceWordWhereInput
    /**
     * Limit how many TranscriptUtteranceWords to delete.
     */
    limit?: number
  }

  /**
   * TranscriptUtteranceWord.TranscriptUtterance
   */
  export type TranscriptUtteranceWord$TranscriptUtteranceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtterance
     */
    select?: TranscriptUtteranceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtterance
     */
    omit?: TranscriptUtteranceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceInclude<ExtArgs> | null
    where?: TranscriptUtteranceWhereInput
  }

  /**
   * TranscriptUtteranceWord without action
   */
  export type TranscriptUtteranceWordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TranscriptUtteranceWord
     */
    select?: TranscriptUtteranceWordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TranscriptUtteranceWord
     */
    omit?: TranscriptUtteranceWordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TranscriptUtteranceWordInclude<ExtArgs> | null
  }


  /**
   * Model AiShowNote
   */

  export type AggregateAiShowNote = {
    _count: AiShowNoteCountAggregateOutputType | null
    _avg: AiShowNoteAvgAggregateOutputType | null
    _sum: AiShowNoteSumAggregateOutputType | null
    _min: AiShowNoteMinAggregateOutputType | null
    _max: AiShowNoteMaxAggregateOutputType | null
  }

  export type AiShowNoteAvgAggregateOutputType = {
    id: number | null
    show_number: number | null
  }

  export type AiShowNoteSumAggregateOutputType = {
    id: number | null
    show_number: number | null
  }

  export type AiShowNoteMinAggregateOutputType = {
    id: number | null
    show_number: number | null
    title: string | null
    description: string | null
    provider: string | null
  }

  export type AiShowNoteMaxAggregateOutputType = {
    id: number | null
    show_number: number | null
    title: string | null
    description: string | null
    provider: string | null
  }

  export type AiShowNoteCountAggregateOutputType = {
    id: number
    show_number: number
    title: number
    description: number
    provider: number
    _all: number
  }


  export type AiShowNoteAvgAggregateInputType = {
    id?: true
    show_number?: true
  }

  export type AiShowNoteSumAggregateInputType = {
    id?: true
    show_number?: true
  }

  export type AiShowNoteMinAggregateInputType = {
    id?: true
    show_number?: true
    title?: true
    description?: true
    provider?: true
  }

  export type AiShowNoteMaxAggregateInputType = {
    id?: true
    show_number?: true
    title?: true
    description?: true
    provider?: true
  }

  export type AiShowNoteCountAggregateInputType = {
    id?: true
    show_number?: true
    title?: true
    description?: true
    provider?: true
    _all?: true
  }

  export type AiShowNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiShowNote to aggregate.
     */
    where?: AiShowNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiShowNotes to fetch.
     */
    orderBy?: AiShowNoteOrderByWithRelationInput | AiShowNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiShowNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiShowNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiShowNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiShowNotes
    **/
    _count?: true | AiShowNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiShowNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiShowNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiShowNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiShowNoteMaxAggregateInputType
  }

  export type GetAiShowNoteAggregateType<T extends AiShowNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateAiShowNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiShowNote[P]>
      : GetScalarType<T[P], AggregateAiShowNote[P]>
  }




  export type AiShowNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiShowNoteWhereInput
    orderBy?: AiShowNoteOrderByWithAggregationInput | AiShowNoteOrderByWithAggregationInput[]
    by: AiShowNoteScalarFieldEnum[] | AiShowNoteScalarFieldEnum
    having?: AiShowNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiShowNoteCountAggregateInputType | true
    _avg?: AiShowNoteAvgAggregateInputType
    _sum?: AiShowNoteSumAggregateInputType
    _min?: AiShowNoteMinAggregateInputType
    _max?: AiShowNoteMaxAggregateInputType
  }

  export type AiShowNoteGroupByOutputType = {
    id: number
    show_number: number
    title: string
    description: string
    provider: string
    _count: AiShowNoteCountAggregateOutputType | null
    _avg: AiShowNoteAvgAggregateOutputType | null
    _sum: AiShowNoteSumAggregateOutputType | null
    _min: AiShowNoteMinAggregateOutputType | null
    _max: AiShowNoteMaxAggregateOutputType | null
  }

  type GetAiShowNoteGroupByPayload<T extends AiShowNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiShowNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiShowNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiShowNoteGroupByOutputType[P]>
            : GetScalarType<T[P], AiShowNoteGroupByOutputType[P]>
        }
      >
    >


  export type AiShowNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    show_number?: boolean
    title?: boolean
    description?: boolean
    provider?: boolean
    show?: boolean | ShowDefaultArgs<ExtArgs>
    summary?: boolean | AiShowNote$summaryArgs<ExtArgs>
    tweets?: boolean | AiShowNote$tweetsArgs<ExtArgs>
    links?: boolean | AiShowNote$linksArgs<ExtArgs>
    guests?: boolean | AiShowNote$guestsArgs<ExtArgs>
    topics?: boolean | AiShowNote$topicsArgs<ExtArgs>
    _count?: boolean | AiShowNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiShowNote"]>



  export type AiShowNoteSelectScalar = {
    id?: boolean
    show_number?: boolean
    title?: boolean
    description?: boolean
    provider?: boolean
  }

  export type AiShowNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "show_number" | "title" | "description" | "provider", ExtArgs["result"]["aiShowNote"]>
  export type AiShowNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    show?: boolean | ShowDefaultArgs<ExtArgs>
    summary?: boolean | AiShowNote$summaryArgs<ExtArgs>
    tweets?: boolean | AiShowNote$tweetsArgs<ExtArgs>
    links?: boolean | AiShowNote$linksArgs<ExtArgs>
    guests?: boolean | AiShowNote$guestsArgs<ExtArgs>
    topics?: boolean | AiShowNote$topicsArgs<ExtArgs>
    _count?: boolean | AiShowNoteCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AiShowNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiShowNote"
    objects: {
      show: Prisma.$ShowPayload<ExtArgs>
      summary: Prisma.$AiSummaryEntryPayload<ExtArgs>[]
      tweets: Prisma.$AiTweetPayload<ExtArgs>[]
      links: Prisma.$LinkPayload<ExtArgs>[]
      guests: Prisma.$AiGuestPayload<ExtArgs>[]
      topics: Prisma.$TopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      show_number: number
      title: string
      description: string
      provider: string
    }, ExtArgs["result"]["aiShowNote"]>
    composites: {}
  }

  type AiShowNoteGetPayload<S extends boolean | null | undefined | AiShowNoteDefaultArgs> = $Result.GetResult<Prisma.$AiShowNotePayload, S>

  type AiShowNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiShowNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiShowNoteCountAggregateInputType | true
    }

  export interface AiShowNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiShowNote'], meta: { name: 'AiShowNote' } }
    /**
     * Find zero or one AiShowNote that matches the filter.
     * @param {AiShowNoteFindUniqueArgs} args - Arguments to find a AiShowNote
     * @example
     * // Get one AiShowNote
     * const aiShowNote = await prisma.aiShowNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiShowNoteFindUniqueArgs>(args: SelectSubset<T, AiShowNoteFindUniqueArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiShowNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiShowNoteFindUniqueOrThrowArgs} args - Arguments to find a AiShowNote
     * @example
     * // Get one AiShowNote
     * const aiShowNote = await prisma.aiShowNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiShowNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, AiShowNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiShowNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiShowNoteFindFirstArgs} args - Arguments to find a AiShowNote
     * @example
     * // Get one AiShowNote
     * const aiShowNote = await prisma.aiShowNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiShowNoteFindFirstArgs>(args?: SelectSubset<T, AiShowNoteFindFirstArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiShowNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiShowNoteFindFirstOrThrowArgs} args - Arguments to find a AiShowNote
     * @example
     * // Get one AiShowNote
     * const aiShowNote = await prisma.aiShowNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiShowNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, AiShowNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiShowNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiShowNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiShowNotes
     * const aiShowNotes = await prisma.aiShowNote.findMany()
     * 
     * // Get first 10 AiShowNotes
     * const aiShowNotes = await prisma.aiShowNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiShowNoteWithIdOnly = await prisma.aiShowNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiShowNoteFindManyArgs>(args?: SelectSubset<T, AiShowNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiShowNote.
     * @param {AiShowNoteCreateArgs} args - Arguments to create a AiShowNote.
     * @example
     * // Create one AiShowNote
     * const AiShowNote = await prisma.aiShowNote.create({
     *   data: {
     *     // ... data to create a AiShowNote
     *   }
     * })
     * 
     */
    create<T extends AiShowNoteCreateArgs>(args: SelectSubset<T, AiShowNoteCreateArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiShowNotes.
     * @param {AiShowNoteCreateManyArgs} args - Arguments to create many AiShowNotes.
     * @example
     * // Create many AiShowNotes
     * const aiShowNote = await prisma.aiShowNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiShowNoteCreateManyArgs>(args?: SelectSubset<T, AiShowNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiShowNote.
     * @param {AiShowNoteDeleteArgs} args - Arguments to delete one AiShowNote.
     * @example
     * // Delete one AiShowNote
     * const AiShowNote = await prisma.aiShowNote.delete({
     *   where: {
     *     // ... filter to delete one AiShowNote
     *   }
     * })
     * 
     */
    delete<T extends AiShowNoteDeleteArgs>(args: SelectSubset<T, AiShowNoteDeleteArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiShowNote.
     * @param {AiShowNoteUpdateArgs} args - Arguments to update one AiShowNote.
     * @example
     * // Update one AiShowNote
     * const aiShowNote = await prisma.aiShowNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiShowNoteUpdateArgs>(args: SelectSubset<T, AiShowNoteUpdateArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiShowNotes.
     * @param {AiShowNoteDeleteManyArgs} args - Arguments to filter AiShowNotes to delete.
     * @example
     * // Delete a few AiShowNotes
     * const { count } = await prisma.aiShowNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiShowNoteDeleteManyArgs>(args?: SelectSubset<T, AiShowNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiShowNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiShowNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiShowNotes
     * const aiShowNote = await prisma.aiShowNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiShowNoteUpdateManyArgs>(args: SelectSubset<T, AiShowNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiShowNote.
     * @param {AiShowNoteUpsertArgs} args - Arguments to update or create a AiShowNote.
     * @example
     * // Update or create a AiShowNote
     * const aiShowNote = await prisma.aiShowNote.upsert({
     *   create: {
     *     // ... data to create a AiShowNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiShowNote we want to update
     *   }
     * })
     */
    upsert<T extends AiShowNoteUpsertArgs>(args: SelectSubset<T, AiShowNoteUpsertArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiShowNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiShowNoteCountArgs} args - Arguments to filter AiShowNotes to count.
     * @example
     * // Count the number of AiShowNotes
     * const count = await prisma.aiShowNote.count({
     *   where: {
     *     // ... the filter for the AiShowNotes we want to count
     *   }
     * })
    **/
    count<T extends AiShowNoteCountArgs>(
      args?: Subset<T, AiShowNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiShowNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiShowNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiShowNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiShowNoteAggregateArgs>(args: Subset<T, AiShowNoteAggregateArgs>): Prisma.PrismaPromise<GetAiShowNoteAggregateType<T>>

    /**
     * Group by AiShowNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiShowNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiShowNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiShowNoteGroupByArgs['orderBy'] }
        : { orderBy?: AiShowNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiShowNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiShowNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiShowNote model
   */
  readonly fields: AiShowNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiShowNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiShowNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    show<T extends ShowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowDefaultArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    summary<T extends AiShowNote$summaryArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNote$summaryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tweets<T extends AiShowNote$tweetsArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNote$tweetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    links<T extends AiShowNote$linksArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNote$linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guests<T extends AiShowNote$guestsArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNote$guestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topics<T extends AiShowNote$topicsArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNote$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiShowNote model
   */
  interface AiShowNoteFieldRefs {
    readonly id: FieldRef<"AiShowNote", 'Int'>
    readonly show_number: FieldRef<"AiShowNote", 'Int'>
    readonly title: FieldRef<"AiShowNote", 'String'>
    readonly description: FieldRef<"AiShowNote", 'String'>
    readonly provider: FieldRef<"AiShowNote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AiShowNote findUnique
   */
  export type AiShowNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    /**
     * Filter, which AiShowNote to fetch.
     */
    where: AiShowNoteWhereUniqueInput
  }

  /**
   * AiShowNote findUniqueOrThrow
   */
  export type AiShowNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    /**
     * Filter, which AiShowNote to fetch.
     */
    where: AiShowNoteWhereUniqueInput
  }

  /**
   * AiShowNote findFirst
   */
  export type AiShowNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    /**
     * Filter, which AiShowNote to fetch.
     */
    where?: AiShowNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiShowNotes to fetch.
     */
    orderBy?: AiShowNoteOrderByWithRelationInput | AiShowNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiShowNotes.
     */
    cursor?: AiShowNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiShowNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiShowNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiShowNotes.
     */
    distinct?: AiShowNoteScalarFieldEnum | AiShowNoteScalarFieldEnum[]
  }

  /**
   * AiShowNote findFirstOrThrow
   */
  export type AiShowNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    /**
     * Filter, which AiShowNote to fetch.
     */
    where?: AiShowNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiShowNotes to fetch.
     */
    orderBy?: AiShowNoteOrderByWithRelationInput | AiShowNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiShowNotes.
     */
    cursor?: AiShowNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiShowNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiShowNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiShowNotes.
     */
    distinct?: AiShowNoteScalarFieldEnum | AiShowNoteScalarFieldEnum[]
  }

  /**
   * AiShowNote findMany
   */
  export type AiShowNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    /**
     * Filter, which AiShowNotes to fetch.
     */
    where?: AiShowNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiShowNotes to fetch.
     */
    orderBy?: AiShowNoteOrderByWithRelationInput | AiShowNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiShowNotes.
     */
    cursor?: AiShowNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiShowNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiShowNotes.
     */
    skip?: number
    distinct?: AiShowNoteScalarFieldEnum | AiShowNoteScalarFieldEnum[]
  }

  /**
   * AiShowNote create
   */
  export type AiShowNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a AiShowNote.
     */
    data: XOR<AiShowNoteCreateInput, AiShowNoteUncheckedCreateInput>
  }

  /**
   * AiShowNote createMany
   */
  export type AiShowNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiShowNotes.
     */
    data: AiShowNoteCreateManyInput | AiShowNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiShowNote update
   */
  export type AiShowNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a AiShowNote.
     */
    data: XOR<AiShowNoteUpdateInput, AiShowNoteUncheckedUpdateInput>
    /**
     * Choose, which AiShowNote to update.
     */
    where: AiShowNoteWhereUniqueInput
  }

  /**
   * AiShowNote updateMany
   */
  export type AiShowNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiShowNotes.
     */
    data: XOR<AiShowNoteUpdateManyMutationInput, AiShowNoteUncheckedUpdateManyInput>
    /**
     * Filter which AiShowNotes to update
     */
    where?: AiShowNoteWhereInput
    /**
     * Limit how many AiShowNotes to update.
     */
    limit?: number
  }

  /**
   * AiShowNote upsert
   */
  export type AiShowNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the AiShowNote to update in case it exists.
     */
    where: AiShowNoteWhereUniqueInput
    /**
     * In case the AiShowNote found by the `where` argument doesn't exist, create a new AiShowNote with this data.
     */
    create: XOR<AiShowNoteCreateInput, AiShowNoteUncheckedCreateInput>
    /**
     * In case the AiShowNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiShowNoteUpdateInput, AiShowNoteUncheckedUpdateInput>
  }

  /**
   * AiShowNote delete
   */
  export type AiShowNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
    /**
     * Filter which AiShowNote to delete.
     */
    where: AiShowNoteWhereUniqueInput
  }

  /**
   * AiShowNote deleteMany
   */
  export type AiShowNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiShowNotes to delete
     */
    where?: AiShowNoteWhereInput
    /**
     * Limit how many AiShowNotes to delete.
     */
    limit?: number
  }

  /**
   * AiShowNote.summary
   */
  export type AiShowNote$summaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    where?: AiSummaryEntryWhereInput
    orderBy?: AiSummaryEntryOrderByWithRelationInput | AiSummaryEntryOrderByWithRelationInput[]
    cursor?: AiSummaryEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiSummaryEntryScalarFieldEnum | AiSummaryEntryScalarFieldEnum[]
  }

  /**
   * AiShowNote.tweets
   */
  export type AiShowNote$tweetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    where?: AiTweetWhereInput
    orderBy?: AiTweetOrderByWithRelationInput | AiTweetOrderByWithRelationInput[]
    cursor?: AiTweetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiTweetScalarFieldEnum | AiTweetScalarFieldEnum[]
  }

  /**
   * AiShowNote.links
   */
  export type AiShowNote$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    where?: LinkWhereInput
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    cursor?: LinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkScalarFieldEnum | LinkScalarFieldEnum[]
  }

  /**
   * AiShowNote.guests
   */
  export type AiShowNote$guestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    where?: AiGuestWhereInput
    orderBy?: AiGuestOrderByWithRelationInput | AiGuestOrderByWithRelationInput[]
    cursor?: AiGuestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiGuestScalarFieldEnum | AiGuestScalarFieldEnum[]
  }

  /**
   * AiShowNote.topics
   */
  export type AiShowNote$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * AiShowNote without action
   */
  export type AiShowNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiShowNote
     */
    select?: AiShowNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiShowNote
     */
    omit?: AiShowNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiShowNoteInclude<ExtArgs> | null
  }


  /**
   * Model AiSummaryEntry
   */

  export type AggregateAiSummaryEntry = {
    _count: AiSummaryEntryCountAggregateOutputType | null
    _avg: AiSummaryEntryAvgAggregateOutputType | null
    _sum: AiSummaryEntrySumAggregateOutputType | null
    _min: AiSummaryEntryMinAggregateOutputType | null
    _max: AiSummaryEntryMaxAggregateOutputType | null
  }

  export type AiSummaryEntryAvgAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type AiSummaryEntrySumAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type AiSummaryEntryMinAggregateOutputType = {
    id: number | null
    time: string | null
    text: string | null
    description: string | null
    showNote: number | null
  }

  export type AiSummaryEntryMaxAggregateOutputType = {
    id: number | null
    time: string | null
    text: string | null
    description: string | null
    showNote: number | null
  }

  export type AiSummaryEntryCountAggregateOutputType = {
    id: number
    time: number
    text: number
    description: number
    showNote: number
    _all: number
  }


  export type AiSummaryEntryAvgAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type AiSummaryEntrySumAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type AiSummaryEntryMinAggregateInputType = {
    id?: true
    time?: true
    text?: true
    description?: true
    showNote?: true
  }

  export type AiSummaryEntryMaxAggregateInputType = {
    id?: true
    time?: true
    text?: true
    description?: true
    showNote?: true
  }

  export type AiSummaryEntryCountAggregateInputType = {
    id?: true
    time?: true
    text?: true
    description?: true
    showNote?: true
    _all?: true
  }

  export type AiSummaryEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSummaryEntry to aggregate.
     */
    where?: AiSummaryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSummaryEntries to fetch.
     */
    orderBy?: AiSummaryEntryOrderByWithRelationInput | AiSummaryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiSummaryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSummaryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSummaryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiSummaryEntries
    **/
    _count?: true | AiSummaryEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiSummaryEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiSummaryEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiSummaryEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiSummaryEntryMaxAggregateInputType
  }

  export type GetAiSummaryEntryAggregateType<T extends AiSummaryEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateAiSummaryEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiSummaryEntry[P]>
      : GetScalarType<T[P], AggregateAiSummaryEntry[P]>
  }




  export type AiSummaryEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSummaryEntryWhereInput
    orderBy?: AiSummaryEntryOrderByWithAggregationInput | AiSummaryEntryOrderByWithAggregationInput[]
    by: AiSummaryEntryScalarFieldEnum[] | AiSummaryEntryScalarFieldEnum
    having?: AiSummaryEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiSummaryEntryCountAggregateInputType | true
    _avg?: AiSummaryEntryAvgAggregateInputType
    _sum?: AiSummaryEntrySumAggregateInputType
    _min?: AiSummaryEntryMinAggregateInputType
    _max?: AiSummaryEntryMaxAggregateInputType
  }

  export type AiSummaryEntryGroupByOutputType = {
    id: number
    time: string
    text: string
    description: string | null
    showNote: number
    _count: AiSummaryEntryCountAggregateOutputType | null
    _avg: AiSummaryEntryAvgAggregateOutputType | null
    _sum: AiSummaryEntrySumAggregateOutputType | null
    _min: AiSummaryEntryMinAggregateOutputType | null
    _max: AiSummaryEntryMaxAggregateOutputType | null
  }

  type GetAiSummaryEntryGroupByPayload<T extends AiSummaryEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiSummaryEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiSummaryEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiSummaryEntryGroupByOutputType[P]>
            : GetScalarType<T[P], AiSummaryEntryGroupByOutputType[P]>
        }
      >
    >


  export type AiSummaryEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    time?: boolean
    text?: boolean
    description?: boolean
    showNote?: boolean
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSummaryEntry"]>



  export type AiSummaryEntrySelectScalar = {
    id?: boolean
    time?: boolean
    text?: boolean
    description?: boolean
    showNote?: boolean
  }

  export type AiSummaryEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "time" | "text" | "description" | "showNote", ExtArgs["result"]["aiSummaryEntry"]>
  export type AiSummaryEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }

  export type $AiSummaryEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiSummaryEntry"
    objects: {
      aiShowNote: Prisma.$AiShowNotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      time: string
      text: string
      description: string | null
      showNote: number
    }, ExtArgs["result"]["aiSummaryEntry"]>
    composites: {}
  }

  type AiSummaryEntryGetPayload<S extends boolean | null | undefined | AiSummaryEntryDefaultArgs> = $Result.GetResult<Prisma.$AiSummaryEntryPayload, S>

  type AiSummaryEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiSummaryEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiSummaryEntryCountAggregateInputType | true
    }

  export interface AiSummaryEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiSummaryEntry'], meta: { name: 'AiSummaryEntry' } }
    /**
     * Find zero or one AiSummaryEntry that matches the filter.
     * @param {AiSummaryEntryFindUniqueArgs} args - Arguments to find a AiSummaryEntry
     * @example
     * // Get one AiSummaryEntry
     * const aiSummaryEntry = await prisma.aiSummaryEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiSummaryEntryFindUniqueArgs>(args: SelectSubset<T, AiSummaryEntryFindUniqueArgs<ExtArgs>>): Prisma__AiSummaryEntryClient<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiSummaryEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiSummaryEntryFindUniqueOrThrowArgs} args - Arguments to find a AiSummaryEntry
     * @example
     * // Get one AiSummaryEntry
     * const aiSummaryEntry = await prisma.aiSummaryEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiSummaryEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, AiSummaryEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiSummaryEntryClient<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiSummaryEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSummaryEntryFindFirstArgs} args - Arguments to find a AiSummaryEntry
     * @example
     * // Get one AiSummaryEntry
     * const aiSummaryEntry = await prisma.aiSummaryEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiSummaryEntryFindFirstArgs>(args?: SelectSubset<T, AiSummaryEntryFindFirstArgs<ExtArgs>>): Prisma__AiSummaryEntryClient<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiSummaryEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSummaryEntryFindFirstOrThrowArgs} args - Arguments to find a AiSummaryEntry
     * @example
     * // Get one AiSummaryEntry
     * const aiSummaryEntry = await prisma.aiSummaryEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiSummaryEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, AiSummaryEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiSummaryEntryClient<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiSummaryEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSummaryEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiSummaryEntries
     * const aiSummaryEntries = await prisma.aiSummaryEntry.findMany()
     * 
     * // Get first 10 AiSummaryEntries
     * const aiSummaryEntries = await prisma.aiSummaryEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiSummaryEntryWithIdOnly = await prisma.aiSummaryEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiSummaryEntryFindManyArgs>(args?: SelectSubset<T, AiSummaryEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiSummaryEntry.
     * @param {AiSummaryEntryCreateArgs} args - Arguments to create a AiSummaryEntry.
     * @example
     * // Create one AiSummaryEntry
     * const AiSummaryEntry = await prisma.aiSummaryEntry.create({
     *   data: {
     *     // ... data to create a AiSummaryEntry
     *   }
     * })
     * 
     */
    create<T extends AiSummaryEntryCreateArgs>(args: SelectSubset<T, AiSummaryEntryCreateArgs<ExtArgs>>): Prisma__AiSummaryEntryClient<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiSummaryEntries.
     * @param {AiSummaryEntryCreateManyArgs} args - Arguments to create many AiSummaryEntries.
     * @example
     * // Create many AiSummaryEntries
     * const aiSummaryEntry = await prisma.aiSummaryEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiSummaryEntryCreateManyArgs>(args?: SelectSubset<T, AiSummaryEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiSummaryEntry.
     * @param {AiSummaryEntryDeleteArgs} args - Arguments to delete one AiSummaryEntry.
     * @example
     * // Delete one AiSummaryEntry
     * const AiSummaryEntry = await prisma.aiSummaryEntry.delete({
     *   where: {
     *     // ... filter to delete one AiSummaryEntry
     *   }
     * })
     * 
     */
    delete<T extends AiSummaryEntryDeleteArgs>(args: SelectSubset<T, AiSummaryEntryDeleteArgs<ExtArgs>>): Prisma__AiSummaryEntryClient<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiSummaryEntry.
     * @param {AiSummaryEntryUpdateArgs} args - Arguments to update one AiSummaryEntry.
     * @example
     * // Update one AiSummaryEntry
     * const aiSummaryEntry = await prisma.aiSummaryEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiSummaryEntryUpdateArgs>(args: SelectSubset<T, AiSummaryEntryUpdateArgs<ExtArgs>>): Prisma__AiSummaryEntryClient<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiSummaryEntries.
     * @param {AiSummaryEntryDeleteManyArgs} args - Arguments to filter AiSummaryEntries to delete.
     * @example
     * // Delete a few AiSummaryEntries
     * const { count } = await prisma.aiSummaryEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiSummaryEntryDeleteManyArgs>(args?: SelectSubset<T, AiSummaryEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiSummaryEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSummaryEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiSummaryEntries
     * const aiSummaryEntry = await prisma.aiSummaryEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiSummaryEntryUpdateManyArgs>(args: SelectSubset<T, AiSummaryEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiSummaryEntry.
     * @param {AiSummaryEntryUpsertArgs} args - Arguments to update or create a AiSummaryEntry.
     * @example
     * // Update or create a AiSummaryEntry
     * const aiSummaryEntry = await prisma.aiSummaryEntry.upsert({
     *   create: {
     *     // ... data to create a AiSummaryEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiSummaryEntry we want to update
     *   }
     * })
     */
    upsert<T extends AiSummaryEntryUpsertArgs>(args: SelectSubset<T, AiSummaryEntryUpsertArgs<ExtArgs>>): Prisma__AiSummaryEntryClient<$Result.GetResult<Prisma.$AiSummaryEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiSummaryEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSummaryEntryCountArgs} args - Arguments to filter AiSummaryEntries to count.
     * @example
     * // Count the number of AiSummaryEntries
     * const count = await prisma.aiSummaryEntry.count({
     *   where: {
     *     // ... the filter for the AiSummaryEntries we want to count
     *   }
     * })
    **/
    count<T extends AiSummaryEntryCountArgs>(
      args?: Subset<T, AiSummaryEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiSummaryEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiSummaryEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSummaryEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiSummaryEntryAggregateArgs>(args: Subset<T, AiSummaryEntryAggregateArgs>): Prisma.PrismaPromise<GetAiSummaryEntryAggregateType<T>>

    /**
     * Group by AiSummaryEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSummaryEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiSummaryEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiSummaryEntryGroupByArgs['orderBy'] }
        : { orderBy?: AiSummaryEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiSummaryEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiSummaryEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiSummaryEntry model
   */
  readonly fields: AiSummaryEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiSummaryEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiSummaryEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiShowNote<T extends AiShowNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNoteDefaultArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiSummaryEntry model
   */
  interface AiSummaryEntryFieldRefs {
    readonly id: FieldRef<"AiSummaryEntry", 'Int'>
    readonly time: FieldRef<"AiSummaryEntry", 'String'>
    readonly text: FieldRef<"AiSummaryEntry", 'String'>
    readonly description: FieldRef<"AiSummaryEntry", 'String'>
    readonly showNote: FieldRef<"AiSummaryEntry", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AiSummaryEntry findUnique
   */
  export type AiSummaryEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    /**
     * Filter, which AiSummaryEntry to fetch.
     */
    where: AiSummaryEntryWhereUniqueInput
  }

  /**
   * AiSummaryEntry findUniqueOrThrow
   */
  export type AiSummaryEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    /**
     * Filter, which AiSummaryEntry to fetch.
     */
    where: AiSummaryEntryWhereUniqueInput
  }

  /**
   * AiSummaryEntry findFirst
   */
  export type AiSummaryEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    /**
     * Filter, which AiSummaryEntry to fetch.
     */
    where?: AiSummaryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSummaryEntries to fetch.
     */
    orderBy?: AiSummaryEntryOrderByWithRelationInput | AiSummaryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSummaryEntries.
     */
    cursor?: AiSummaryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSummaryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSummaryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSummaryEntries.
     */
    distinct?: AiSummaryEntryScalarFieldEnum | AiSummaryEntryScalarFieldEnum[]
  }

  /**
   * AiSummaryEntry findFirstOrThrow
   */
  export type AiSummaryEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    /**
     * Filter, which AiSummaryEntry to fetch.
     */
    where?: AiSummaryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSummaryEntries to fetch.
     */
    orderBy?: AiSummaryEntryOrderByWithRelationInput | AiSummaryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSummaryEntries.
     */
    cursor?: AiSummaryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSummaryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSummaryEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSummaryEntries.
     */
    distinct?: AiSummaryEntryScalarFieldEnum | AiSummaryEntryScalarFieldEnum[]
  }

  /**
   * AiSummaryEntry findMany
   */
  export type AiSummaryEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    /**
     * Filter, which AiSummaryEntries to fetch.
     */
    where?: AiSummaryEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSummaryEntries to fetch.
     */
    orderBy?: AiSummaryEntryOrderByWithRelationInput | AiSummaryEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiSummaryEntries.
     */
    cursor?: AiSummaryEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSummaryEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSummaryEntries.
     */
    skip?: number
    distinct?: AiSummaryEntryScalarFieldEnum | AiSummaryEntryScalarFieldEnum[]
  }

  /**
   * AiSummaryEntry create
   */
  export type AiSummaryEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a AiSummaryEntry.
     */
    data: XOR<AiSummaryEntryCreateInput, AiSummaryEntryUncheckedCreateInput>
  }

  /**
   * AiSummaryEntry createMany
   */
  export type AiSummaryEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiSummaryEntries.
     */
    data: AiSummaryEntryCreateManyInput | AiSummaryEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiSummaryEntry update
   */
  export type AiSummaryEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a AiSummaryEntry.
     */
    data: XOR<AiSummaryEntryUpdateInput, AiSummaryEntryUncheckedUpdateInput>
    /**
     * Choose, which AiSummaryEntry to update.
     */
    where: AiSummaryEntryWhereUniqueInput
  }

  /**
   * AiSummaryEntry updateMany
   */
  export type AiSummaryEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiSummaryEntries.
     */
    data: XOR<AiSummaryEntryUpdateManyMutationInput, AiSummaryEntryUncheckedUpdateManyInput>
    /**
     * Filter which AiSummaryEntries to update
     */
    where?: AiSummaryEntryWhereInput
    /**
     * Limit how many AiSummaryEntries to update.
     */
    limit?: number
  }

  /**
   * AiSummaryEntry upsert
   */
  export type AiSummaryEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the AiSummaryEntry to update in case it exists.
     */
    where: AiSummaryEntryWhereUniqueInput
    /**
     * In case the AiSummaryEntry found by the `where` argument doesn't exist, create a new AiSummaryEntry with this data.
     */
    create: XOR<AiSummaryEntryCreateInput, AiSummaryEntryUncheckedCreateInput>
    /**
     * In case the AiSummaryEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiSummaryEntryUpdateInput, AiSummaryEntryUncheckedUpdateInput>
  }

  /**
   * AiSummaryEntry delete
   */
  export type AiSummaryEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
    /**
     * Filter which AiSummaryEntry to delete.
     */
    where: AiSummaryEntryWhereUniqueInput
  }

  /**
   * AiSummaryEntry deleteMany
   */
  export type AiSummaryEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSummaryEntries to delete
     */
    where?: AiSummaryEntryWhereInput
    /**
     * Limit how many AiSummaryEntries to delete.
     */
    limit?: number
  }

  /**
   * AiSummaryEntry without action
   */
  export type AiSummaryEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSummaryEntry
     */
    select?: AiSummaryEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSummaryEntry
     */
    omit?: AiSummaryEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSummaryEntryInclude<ExtArgs> | null
  }


  /**
   * Model AiTweet
   */

  export type AggregateAiTweet = {
    _count: AiTweetCountAggregateOutputType | null
    _avg: AiTweetAvgAggregateOutputType | null
    _sum: AiTweetSumAggregateOutputType | null
    _min: AiTweetMinAggregateOutputType | null
    _max: AiTweetMaxAggregateOutputType | null
  }

  export type AiTweetAvgAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type AiTweetSumAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type AiTweetMinAggregateOutputType = {
    id: number | null
    content: string | null
    showNote: number | null
  }

  export type AiTweetMaxAggregateOutputType = {
    id: number | null
    content: string | null
    showNote: number | null
  }

  export type AiTweetCountAggregateOutputType = {
    id: number
    content: number
    showNote: number
    _all: number
  }


  export type AiTweetAvgAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type AiTweetSumAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type AiTweetMinAggregateInputType = {
    id?: true
    content?: true
    showNote?: true
  }

  export type AiTweetMaxAggregateInputType = {
    id?: true
    content?: true
    showNote?: true
  }

  export type AiTweetCountAggregateInputType = {
    id?: true
    content?: true
    showNote?: true
    _all?: true
  }

  export type AiTweetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiTweet to aggregate.
     */
    where?: AiTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTweets to fetch.
     */
    orderBy?: AiTweetOrderByWithRelationInput | AiTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiTweets
    **/
    _count?: true | AiTweetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiTweetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiTweetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiTweetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiTweetMaxAggregateInputType
  }

  export type GetAiTweetAggregateType<T extends AiTweetAggregateArgs> = {
        [P in keyof T & keyof AggregateAiTweet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiTweet[P]>
      : GetScalarType<T[P], AggregateAiTweet[P]>
  }




  export type AiTweetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiTweetWhereInput
    orderBy?: AiTweetOrderByWithAggregationInput | AiTweetOrderByWithAggregationInput[]
    by: AiTweetScalarFieldEnum[] | AiTweetScalarFieldEnum
    having?: AiTweetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiTweetCountAggregateInputType | true
    _avg?: AiTweetAvgAggregateInputType
    _sum?: AiTweetSumAggregateInputType
    _min?: AiTweetMinAggregateInputType
    _max?: AiTweetMaxAggregateInputType
  }

  export type AiTweetGroupByOutputType = {
    id: number
    content: string
    showNote: number
    _count: AiTweetCountAggregateOutputType | null
    _avg: AiTweetAvgAggregateOutputType | null
    _sum: AiTweetSumAggregateOutputType | null
    _min: AiTweetMinAggregateOutputType | null
    _max: AiTweetMaxAggregateOutputType | null
  }

  type GetAiTweetGroupByPayload<T extends AiTweetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiTweetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiTweetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiTweetGroupByOutputType[P]>
            : GetScalarType<T[P], AiTweetGroupByOutputType[P]>
        }
      >
    >


  export type AiTweetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    showNote?: boolean
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiTweet"]>



  export type AiTweetSelectScalar = {
    id?: boolean
    content?: boolean
    showNote?: boolean
  }

  export type AiTweetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "showNote", ExtArgs["result"]["aiTweet"]>
  export type AiTweetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }

  export type $AiTweetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiTweet"
    objects: {
      aiShowNote: Prisma.$AiShowNotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      showNote: number
    }, ExtArgs["result"]["aiTweet"]>
    composites: {}
  }

  type AiTweetGetPayload<S extends boolean | null | undefined | AiTweetDefaultArgs> = $Result.GetResult<Prisma.$AiTweetPayload, S>

  type AiTweetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiTweetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiTweetCountAggregateInputType | true
    }

  export interface AiTweetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiTweet'], meta: { name: 'AiTweet' } }
    /**
     * Find zero or one AiTweet that matches the filter.
     * @param {AiTweetFindUniqueArgs} args - Arguments to find a AiTweet
     * @example
     * // Get one AiTweet
     * const aiTweet = await prisma.aiTweet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiTweetFindUniqueArgs>(args: SelectSubset<T, AiTweetFindUniqueArgs<ExtArgs>>): Prisma__AiTweetClient<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiTweet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiTweetFindUniqueOrThrowArgs} args - Arguments to find a AiTweet
     * @example
     * // Get one AiTweet
     * const aiTweet = await prisma.aiTweet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiTweetFindUniqueOrThrowArgs>(args: SelectSubset<T, AiTweetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiTweetClient<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiTweet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTweetFindFirstArgs} args - Arguments to find a AiTweet
     * @example
     * // Get one AiTweet
     * const aiTweet = await prisma.aiTweet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiTweetFindFirstArgs>(args?: SelectSubset<T, AiTweetFindFirstArgs<ExtArgs>>): Prisma__AiTweetClient<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiTweet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTweetFindFirstOrThrowArgs} args - Arguments to find a AiTweet
     * @example
     * // Get one AiTweet
     * const aiTweet = await prisma.aiTweet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiTweetFindFirstOrThrowArgs>(args?: SelectSubset<T, AiTweetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiTweetClient<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiTweets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTweetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiTweets
     * const aiTweets = await prisma.aiTweet.findMany()
     * 
     * // Get first 10 AiTweets
     * const aiTweets = await prisma.aiTweet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiTweetWithIdOnly = await prisma.aiTweet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiTweetFindManyArgs>(args?: SelectSubset<T, AiTweetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiTweet.
     * @param {AiTweetCreateArgs} args - Arguments to create a AiTweet.
     * @example
     * // Create one AiTweet
     * const AiTweet = await prisma.aiTweet.create({
     *   data: {
     *     // ... data to create a AiTweet
     *   }
     * })
     * 
     */
    create<T extends AiTweetCreateArgs>(args: SelectSubset<T, AiTweetCreateArgs<ExtArgs>>): Prisma__AiTweetClient<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiTweets.
     * @param {AiTweetCreateManyArgs} args - Arguments to create many AiTweets.
     * @example
     * // Create many AiTweets
     * const aiTweet = await prisma.aiTweet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiTweetCreateManyArgs>(args?: SelectSubset<T, AiTweetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiTweet.
     * @param {AiTweetDeleteArgs} args - Arguments to delete one AiTweet.
     * @example
     * // Delete one AiTweet
     * const AiTweet = await prisma.aiTweet.delete({
     *   where: {
     *     // ... filter to delete one AiTweet
     *   }
     * })
     * 
     */
    delete<T extends AiTweetDeleteArgs>(args: SelectSubset<T, AiTweetDeleteArgs<ExtArgs>>): Prisma__AiTweetClient<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiTweet.
     * @param {AiTweetUpdateArgs} args - Arguments to update one AiTweet.
     * @example
     * // Update one AiTweet
     * const aiTweet = await prisma.aiTweet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiTweetUpdateArgs>(args: SelectSubset<T, AiTweetUpdateArgs<ExtArgs>>): Prisma__AiTweetClient<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiTweets.
     * @param {AiTweetDeleteManyArgs} args - Arguments to filter AiTweets to delete.
     * @example
     * // Delete a few AiTweets
     * const { count } = await prisma.aiTweet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiTweetDeleteManyArgs>(args?: SelectSubset<T, AiTweetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiTweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTweetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiTweets
     * const aiTweet = await prisma.aiTweet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiTweetUpdateManyArgs>(args: SelectSubset<T, AiTweetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiTweet.
     * @param {AiTweetUpsertArgs} args - Arguments to update or create a AiTweet.
     * @example
     * // Update or create a AiTweet
     * const aiTweet = await prisma.aiTweet.upsert({
     *   create: {
     *     // ... data to create a AiTweet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiTweet we want to update
     *   }
     * })
     */
    upsert<T extends AiTweetUpsertArgs>(args: SelectSubset<T, AiTweetUpsertArgs<ExtArgs>>): Prisma__AiTweetClient<$Result.GetResult<Prisma.$AiTweetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiTweets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTweetCountArgs} args - Arguments to filter AiTweets to count.
     * @example
     * // Count the number of AiTweets
     * const count = await prisma.aiTweet.count({
     *   where: {
     *     // ... the filter for the AiTweets we want to count
     *   }
     * })
    **/
    count<T extends AiTweetCountArgs>(
      args?: Subset<T, AiTweetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiTweetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiTweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTweetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiTweetAggregateArgs>(args: Subset<T, AiTweetAggregateArgs>): Prisma.PrismaPromise<GetAiTweetAggregateType<T>>

    /**
     * Group by AiTweet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiTweetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiTweetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiTweetGroupByArgs['orderBy'] }
        : { orderBy?: AiTweetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiTweetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiTweetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiTweet model
   */
  readonly fields: AiTweetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiTweet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiTweetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiShowNote<T extends AiShowNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNoteDefaultArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiTweet model
   */
  interface AiTweetFieldRefs {
    readonly id: FieldRef<"AiTweet", 'Int'>
    readonly content: FieldRef<"AiTweet", 'String'>
    readonly showNote: FieldRef<"AiTweet", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AiTweet findUnique
   */
  export type AiTweetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    /**
     * Filter, which AiTweet to fetch.
     */
    where: AiTweetWhereUniqueInput
  }

  /**
   * AiTweet findUniqueOrThrow
   */
  export type AiTweetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    /**
     * Filter, which AiTweet to fetch.
     */
    where: AiTweetWhereUniqueInput
  }

  /**
   * AiTweet findFirst
   */
  export type AiTweetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    /**
     * Filter, which AiTweet to fetch.
     */
    where?: AiTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTweets to fetch.
     */
    orderBy?: AiTweetOrderByWithRelationInput | AiTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiTweets.
     */
    cursor?: AiTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiTweets.
     */
    distinct?: AiTweetScalarFieldEnum | AiTweetScalarFieldEnum[]
  }

  /**
   * AiTweet findFirstOrThrow
   */
  export type AiTweetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    /**
     * Filter, which AiTweet to fetch.
     */
    where?: AiTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTweets to fetch.
     */
    orderBy?: AiTweetOrderByWithRelationInput | AiTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiTweets.
     */
    cursor?: AiTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTweets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiTweets.
     */
    distinct?: AiTweetScalarFieldEnum | AiTweetScalarFieldEnum[]
  }

  /**
   * AiTweet findMany
   */
  export type AiTweetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    /**
     * Filter, which AiTweets to fetch.
     */
    where?: AiTweetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiTweets to fetch.
     */
    orderBy?: AiTweetOrderByWithRelationInput | AiTweetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiTweets.
     */
    cursor?: AiTweetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiTweets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiTweets.
     */
    skip?: number
    distinct?: AiTweetScalarFieldEnum | AiTweetScalarFieldEnum[]
  }

  /**
   * AiTweet create
   */
  export type AiTweetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    /**
     * The data needed to create a AiTweet.
     */
    data: XOR<AiTweetCreateInput, AiTweetUncheckedCreateInput>
  }

  /**
   * AiTweet createMany
   */
  export type AiTweetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiTweets.
     */
    data: AiTweetCreateManyInput | AiTweetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiTweet update
   */
  export type AiTweetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    /**
     * The data needed to update a AiTweet.
     */
    data: XOR<AiTweetUpdateInput, AiTweetUncheckedUpdateInput>
    /**
     * Choose, which AiTweet to update.
     */
    where: AiTweetWhereUniqueInput
  }

  /**
   * AiTweet updateMany
   */
  export type AiTweetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiTweets.
     */
    data: XOR<AiTweetUpdateManyMutationInput, AiTweetUncheckedUpdateManyInput>
    /**
     * Filter which AiTweets to update
     */
    where?: AiTweetWhereInput
    /**
     * Limit how many AiTweets to update.
     */
    limit?: number
  }

  /**
   * AiTweet upsert
   */
  export type AiTweetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    /**
     * The filter to search for the AiTweet to update in case it exists.
     */
    where: AiTweetWhereUniqueInput
    /**
     * In case the AiTweet found by the `where` argument doesn't exist, create a new AiTweet with this data.
     */
    create: XOR<AiTweetCreateInput, AiTweetUncheckedCreateInput>
    /**
     * In case the AiTweet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiTweetUpdateInput, AiTweetUncheckedUpdateInput>
  }

  /**
   * AiTweet delete
   */
  export type AiTweetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
    /**
     * Filter which AiTweet to delete.
     */
    where: AiTweetWhereUniqueInput
  }

  /**
   * AiTweet deleteMany
   */
  export type AiTweetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiTweets to delete
     */
    where?: AiTweetWhereInput
    /**
     * Limit how many AiTweets to delete.
     */
    limit?: number
  }

  /**
   * AiTweet without action
   */
  export type AiTweetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiTweet
     */
    select?: AiTweetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiTweet
     */
    omit?: AiTweetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiTweetInclude<ExtArgs> | null
  }


  /**
   * Model Link
   */

  export type AggregateLink = {
    _count: LinkCountAggregateOutputType | null
    _avg: LinkAvgAggregateOutputType | null
    _sum: LinkSumAggregateOutputType | null
    _min: LinkMinAggregateOutputType | null
    _max: LinkMaxAggregateOutputType | null
  }

  export type LinkAvgAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type LinkSumAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type LinkMinAggregateOutputType = {
    id: number | null
    name: string | null
    url: string | null
    timestamp: string | null
    showNote: number | null
  }

  export type LinkMaxAggregateOutputType = {
    id: number | null
    name: string | null
    url: string | null
    timestamp: string | null
    showNote: number | null
  }

  export type LinkCountAggregateOutputType = {
    id: number
    name: number
    url: number
    timestamp: number
    showNote: number
    _all: number
  }


  export type LinkAvgAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type LinkSumAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type LinkMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    timestamp?: true
    showNote?: true
  }

  export type LinkMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    timestamp?: true
    showNote?: true
  }

  export type LinkCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    timestamp?: true
    showNote?: true
    _all?: true
  }

  export type LinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Link to aggregate.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Links
    **/
    _count?: true | LinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkMaxAggregateInputType
  }

  export type GetLinkAggregateType<T extends LinkAggregateArgs> = {
        [P in keyof T & keyof AggregateLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLink[P]>
      : GetScalarType<T[P], AggregateLink[P]>
  }




  export type LinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkWhereInput
    orderBy?: LinkOrderByWithAggregationInput | LinkOrderByWithAggregationInput[]
    by: LinkScalarFieldEnum[] | LinkScalarFieldEnum
    having?: LinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkCountAggregateInputType | true
    _avg?: LinkAvgAggregateInputType
    _sum?: LinkSumAggregateInputType
    _min?: LinkMinAggregateInputType
    _max?: LinkMaxAggregateInputType
  }

  export type LinkGroupByOutputType = {
    id: number
    name: string
    url: string
    timestamp: string | null
    showNote: number
    _count: LinkCountAggregateOutputType | null
    _avg: LinkAvgAggregateOutputType | null
    _sum: LinkSumAggregateOutputType | null
    _min: LinkMinAggregateOutputType | null
    _max: LinkMaxAggregateOutputType | null
  }

  type GetLinkGroupByPayload<T extends LinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkGroupByOutputType[P]>
            : GetScalarType<T[P], LinkGroupByOutputType[P]>
        }
      >
    >


  export type LinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    timestamp?: boolean
    showNote?: boolean
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["link"]>



  export type LinkSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    timestamp?: boolean
    showNote?: boolean
  }

  export type LinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "timestamp" | "showNote", ExtArgs["result"]["link"]>
  export type LinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }

  export type $LinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Link"
    objects: {
      aiShowNote: Prisma.$AiShowNotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      url: string
      timestamp: string | null
      showNote: number
    }, ExtArgs["result"]["link"]>
    composites: {}
  }

  type LinkGetPayload<S extends boolean | null | undefined | LinkDefaultArgs> = $Result.GetResult<Prisma.$LinkPayload, S>

  type LinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinkCountAggregateInputType | true
    }

  export interface LinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Link'], meta: { name: 'Link' } }
    /**
     * Find zero or one Link that matches the filter.
     * @param {LinkFindUniqueArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkFindUniqueArgs>(args: SelectSubset<T, LinkFindUniqueArgs<ExtArgs>>): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Link that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinkFindUniqueOrThrowArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindFirstArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkFindFirstArgs>(args?: SelectSubset<T, LinkFindFirstArgs<ExtArgs>>): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindFirstOrThrowArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Links
     * const links = await prisma.link.findMany()
     * 
     * // Get first 10 Links
     * const links = await prisma.link.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkWithIdOnly = await prisma.link.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkFindManyArgs>(args?: SelectSubset<T, LinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Link.
     * @param {LinkCreateArgs} args - Arguments to create a Link.
     * @example
     * // Create one Link
     * const Link = await prisma.link.create({
     *   data: {
     *     // ... data to create a Link
     *   }
     * })
     * 
     */
    create<T extends LinkCreateArgs>(args: SelectSubset<T, LinkCreateArgs<ExtArgs>>): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Links.
     * @param {LinkCreateManyArgs} args - Arguments to create many Links.
     * @example
     * // Create many Links
     * const link = await prisma.link.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkCreateManyArgs>(args?: SelectSubset<T, LinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Link.
     * @param {LinkDeleteArgs} args - Arguments to delete one Link.
     * @example
     * // Delete one Link
     * const Link = await prisma.link.delete({
     *   where: {
     *     // ... filter to delete one Link
     *   }
     * })
     * 
     */
    delete<T extends LinkDeleteArgs>(args: SelectSubset<T, LinkDeleteArgs<ExtArgs>>): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Link.
     * @param {LinkUpdateArgs} args - Arguments to update one Link.
     * @example
     * // Update one Link
     * const link = await prisma.link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkUpdateArgs>(args: SelectSubset<T, LinkUpdateArgs<ExtArgs>>): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Links.
     * @param {LinkDeleteManyArgs} args - Arguments to filter Links to delete.
     * @example
     * // Delete a few Links
     * const { count } = await prisma.link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkDeleteManyArgs>(args?: SelectSubset<T, LinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Links
     * const link = await prisma.link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkUpdateManyArgs>(args: SelectSubset<T, LinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Link.
     * @param {LinkUpsertArgs} args - Arguments to update or create a Link.
     * @example
     * // Update or create a Link
     * const link = await prisma.link.upsert({
     *   create: {
     *     // ... data to create a Link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Link we want to update
     *   }
     * })
     */
    upsert<T extends LinkUpsertArgs>(args: SelectSubset<T, LinkUpsertArgs<ExtArgs>>): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkCountArgs} args - Arguments to filter Links to count.
     * @example
     * // Count the number of Links
     * const count = await prisma.link.count({
     *   where: {
     *     // ... the filter for the Links we want to count
     *   }
     * })
    **/
    count<T extends LinkCountArgs>(
      args?: Subset<T, LinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkAggregateArgs>(args: Subset<T, LinkAggregateArgs>): Prisma.PrismaPromise<GetLinkAggregateType<T>>

    /**
     * Group by Link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkGroupByArgs['orderBy'] }
        : { orderBy?: LinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Link model
   */
  readonly fields: LinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiShowNote<T extends AiShowNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNoteDefaultArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Link model
   */
  interface LinkFieldRefs {
    readonly id: FieldRef<"Link", 'Int'>
    readonly name: FieldRef<"Link", 'String'>
    readonly url: FieldRef<"Link", 'String'>
    readonly timestamp: FieldRef<"Link", 'String'>
    readonly showNote: FieldRef<"Link", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Link findUnique
   */
  export type LinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Link to fetch.
     */
    where: LinkWhereUniqueInput
  }

  /**
   * Link findUniqueOrThrow
   */
  export type LinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Link to fetch.
     */
    where: LinkWhereUniqueInput
  }

  /**
   * Link findFirst
   */
  export type LinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Link to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Links.
     */
    distinct?: LinkScalarFieldEnum | LinkScalarFieldEnum[]
  }

  /**
   * Link findFirstOrThrow
   */
  export type LinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Link to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Links.
     */
    distinct?: LinkScalarFieldEnum | LinkScalarFieldEnum[]
  }

  /**
   * Link findMany
   */
  export type LinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Links to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    distinct?: LinkScalarFieldEnum | LinkScalarFieldEnum[]
  }

  /**
   * Link create
   */
  export type LinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * The data needed to create a Link.
     */
    data: XOR<LinkCreateInput, LinkUncheckedCreateInput>
  }

  /**
   * Link createMany
   */
  export type LinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Links.
     */
    data: LinkCreateManyInput | LinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Link update
   */
  export type LinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * The data needed to update a Link.
     */
    data: XOR<LinkUpdateInput, LinkUncheckedUpdateInput>
    /**
     * Choose, which Link to update.
     */
    where: LinkWhereUniqueInput
  }

  /**
   * Link updateMany
   */
  export type LinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Links.
     */
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyInput>
    /**
     * Filter which Links to update
     */
    where?: LinkWhereInput
    /**
     * Limit how many Links to update.
     */
    limit?: number
  }

  /**
   * Link upsert
   */
  export type LinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * The filter to search for the Link to update in case it exists.
     */
    where: LinkWhereUniqueInput
    /**
     * In case the Link found by the `where` argument doesn't exist, create a new Link with this data.
     */
    create: XOR<LinkCreateInput, LinkUncheckedCreateInput>
    /**
     * In case the Link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkUpdateInput, LinkUncheckedUpdateInput>
  }

  /**
   * Link delete
   */
  export type LinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter which Link to delete.
     */
    where: LinkWhereUniqueInput
  }

  /**
   * Link deleteMany
   */
  export type LinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Links to delete
     */
    where?: LinkWhereInput
    /**
     * Limit how many Links to delete.
     */
    limit?: number
  }

  /**
   * Link without action
   */
  export type LinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Link
     */
    omit?: LinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkInclude<ExtArgs> | null
  }


  /**
   * Model AiGuest
   */

  export type AggregateAiGuest = {
    _count: AiGuestCountAggregateOutputType | null
    _avg: AiGuestAvgAggregateOutputType | null
    _sum: AiGuestSumAggregateOutputType | null
    _min: AiGuestMinAggregateOutputType | null
    _max: AiGuestMaxAggregateOutputType | null
  }

  export type AiGuestAvgAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type AiGuestSumAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type AiGuestMinAggregateOutputType = {
    id: number | null
    name: string | null
    showNote: number | null
  }

  export type AiGuestMaxAggregateOutputType = {
    id: number | null
    name: string | null
    showNote: number | null
  }

  export type AiGuestCountAggregateOutputType = {
    id: number
    name: number
    showNote: number
    _all: number
  }


  export type AiGuestAvgAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type AiGuestSumAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type AiGuestMinAggregateInputType = {
    id?: true
    name?: true
    showNote?: true
  }

  export type AiGuestMaxAggregateInputType = {
    id?: true
    name?: true
    showNote?: true
  }

  export type AiGuestCountAggregateInputType = {
    id?: true
    name?: true
    showNote?: true
    _all?: true
  }

  export type AiGuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiGuest to aggregate.
     */
    where?: AiGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGuests to fetch.
     */
    orderBy?: AiGuestOrderByWithRelationInput | AiGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiGuests
    **/
    _count?: true | AiGuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiGuestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiGuestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiGuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiGuestMaxAggregateInputType
  }

  export type GetAiGuestAggregateType<T extends AiGuestAggregateArgs> = {
        [P in keyof T & keyof AggregateAiGuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiGuest[P]>
      : GetScalarType<T[P], AggregateAiGuest[P]>
  }




  export type AiGuestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiGuestWhereInput
    orderBy?: AiGuestOrderByWithAggregationInput | AiGuestOrderByWithAggregationInput[]
    by: AiGuestScalarFieldEnum[] | AiGuestScalarFieldEnum
    having?: AiGuestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiGuestCountAggregateInputType | true
    _avg?: AiGuestAvgAggregateInputType
    _sum?: AiGuestSumAggregateInputType
    _min?: AiGuestMinAggregateInputType
    _max?: AiGuestMaxAggregateInputType
  }

  export type AiGuestGroupByOutputType = {
    id: number
    name: string
    showNote: number
    _count: AiGuestCountAggregateOutputType | null
    _avg: AiGuestAvgAggregateOutputType | null
    _sum: AiGuestSumAggregateOutputType | null
    _min: AiGuestMinAggregateOutputType | null
    _max: AiGuestMaxAggregateOutputType | null
  }

  type GetAiGuestGroupByPayload<T extends AiGuestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiGuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiGuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiGuestGroupByOutputType[P]>
            : GetScalarType<T[P], AiGuestGroupByOutputType[P]>
        }
      >
    >


  export type AiGuestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    showNote?: boolean
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiGuest"]>



  export type AiGuestSelectScalar = {
    id?: boolean
    name?: boolean
    showNote?: boolean
  }

  export type AiGuestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "showNote", ExtArgs["result"]["aiGuest"]>
  export type AiGuestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }

  export type $AiGuestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiGuest"
    objects: {
      aiShowNote: Prisma.$AiShowNotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      showNote: number
    }, ExtArgs["result"]["aiGuest"]>
    composites: {}
  }

  type AiGuestGetPayload<S extends boolean | null | undefined | AiGuestDefaultArgs> = $Result.GetResult<Prisma.$AiGuestPayload, S>

  type AiGuestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiGuestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiGuestCountAggregateInputType | true
    }

  export interface AiGuestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiGuest'], meta: { name: 'AiGuest' } }
    /**
     * Find zero or one AiGuest that matches the filter.
     * @param {AiGuestFindUniqueArgs} args - Arguments to find a AiGuest
     * @example
     * // Get one AiGuest
     * const aiGuest = await prisma.aiGuest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiGuestFindUniqueArgs>(args: SelectSubset<T, AiGuestFindUniqueArgs<ExtArgs>>): Prisma__AiGuestClient<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiGuest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiGuestFindUniqueOrThrowArgs} args - Arguments to find a AiGuest
     * @example
     * // Get one AiGuest
     * const aiGuest = await prisma.aiGuest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiGuestFindUniqueOrThrowArgs>(args: SelectSubset<T, AiGuestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiGuestClient<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiGuest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGuestFindFirstArgs} args - Arguments to find a AiGuest
     * @example
     * // Get one AiGuest
     * const aiGuest = await prisma.aiGuest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiGuestFindFirstArgs>(args?: SelectSubset<T, AiGuestFindFirstArgs<ExtArgs>>): Prisma__AiGuestClient<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiGuest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGuestFindFirstOrThrowArgs} args - Arguments to find a AiGuest
     * @example
     * // Get one AiGuest
     * const aiGuest = await prisma.aiGuest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiGuestFindFirstOrThrowArgs>(args?: SelectSubset<T, AiGuestFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiGuestClient<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiGuests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGuestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiGuests
     * const aiGuests = await prisma.aiGuest.findMany()
     * 
     * // Get first 10 AiGuests
     * const aiGuests = await prisma.aiGuest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiGuestWithIdOnly = await prisma.aiGuest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiGuestFindManyArgs>(args?: SelectSubset<T, AiGuestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiGuest.
     * @param {AiGuestCreateArgs} args - Arguments to create a AiGuest.
     * @example
     * // Create one AiGuest
     * const AiGuest = await prisma.aiGuest.create({
     *   data: {
     *     // ... data to create a AiGuest
     *   }
     * })
     * 
     */
    create<T extends AiGuestCreateArgs>(args: SelectSubset<T, AiGuestCreateArgs<ExtArgs>>): Prisma__AiGuestClient<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiGuests.
     * @param {AiGuestCreateManyArgs} args - Arguments to create many AiGuests.
     * @example
     * // Create many AiGuests
     * const aiGuest = await prisma.aiGuest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiGuestCreateManyArgs>(args?: SelectSubset<T, AiGuestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AiGuest.
     * @param {AiGuestDeleteArgs} args - Arguments to delete one AiGuest.
     * @example
     * // Delete one AiGuest
     * const AiGuest = await prisma.aiGuest.delete({
     *   where: {
     *     // ... filter to delete one AiGuest
     *   }
     * })
     * 
     */
    delete<T extends AiGuestDeleteArgs>(args: SelectSubset<T, AiGuestDeleteArgs<ExtArgs>>): Prisma__AiGuestClient<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiGuest.
     * @param {AiGuestUpdateArgs} args - Arguments to update one AiGuest.
     * @example
     * // Update one AiGuest
     * const aiGuest = await prisma.aiGuest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiGuestUpdateArgs>(args: SelectSubset<T, AiGuestUpdateArgs<ExtArgs>>): Prisma__AiGuestClient<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiGuests.
     * @param {AiGuestDeleteManyArgs} args - Arguments to filter AiGuests to delete.
     * @example
     * // Delete a few AiGuests
     * const { count } = await prisma.aiGuest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiGuestDeleteManyArgs>(args?: SelectSubset<T, AiGuestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiGuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGuestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiGuests
     * const aiGuest = await prisma.aiGuest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiGuestUpdateManyArgs>(args: SelectSubset<T, AiGuestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiGuest.
     * @param {AiGuestUpsertArgs} args - Arguments to update or create a AiGuest.
     * @example
     * // Update or create a AiGuest
     * const aiGuest = await prisma.aiGuest.upsert({
     *   create: {
     *     // ... data to create a AiGuest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiGuest we want to update
     *   }
     * })
     */
    upsert<T extends AiGuestUpsertArgs>(args: SelectSubset<T, AiGuestUpsertArgs<ExtArgs>>): Prisma__AiGuestClient<$Result.GetResult<Prisma.$AiGuestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiGuests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGuestCountArgs} args - Arguments to filter AiGuests to count.
     * @example
     * // Count the number of AiGuests
     * const count = await prisma.aiGuest.count({
     *   where: {
     *     // ... the filter for the AiGuests we want to count
     *   }
     * })
    **/
    count<T extends AiGuestCountArgs>(
      args?: Subset<T, AiGuestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiGuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiGuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiGuestAggregateArgs>(args: Subset<T, AiGuestAggregateArgs>): Prisma.PrismaPromise<GetAiGuestAggregateType<T>>

    /**
     * Group by AiGuest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGuestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiGuestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiGuestGroupByArgs['orderBy'] }
        : { orderBy?: AiGuestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiGuestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiGuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiGuest model
   */
  readonly fields: AiGuestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiGuest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiGuestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiShowNote<T extends AiShowNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNoteDefaultArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiGuest model
   */
  interface AiGuestFieldRefs {
    readonly id: FieldRef<"AiGuest", 'Int'>
    readonly name: FieldRef<"AiGuest", 'String'>
    readonly showNote: FieldRef<"AiGuest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AiGuest findUnique
   */
  export type AiGuestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    /**
     * Filter, which AiGuest to fetch.
     */
    where: AiGuestWhereUniqueInput
  }

  /**
   * AiGuest findUniqueOrThrow
   */
  export type AiGuestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    /**
     * Filter, which AiGuest to fetch.
     */
    where: AiGuestWhereUniqueInput
  }

  /**
   * AiGuest findFirst
   */
  export type AiGuestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    /**
     * Filter, which AiGuest to fetch.
     */
    where?: AiGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGuests to fetch.
     */
    orderBy?: AiGuestOrderByWithRelationInput | AiGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiGuests.
     */
    cursor?: AiGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiGuests.
     */
    distinct?: AiGuestScalarFieldEnum | AiGuestScalarFieldEnum[]
  }

  /**
   * AiGuest findFirstOrThrow
   */
  export type AiGuestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    /**
     * Filter, which AiGuest to fetch.
     */
    where?: AiGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGuests to fetch.
     */
    orderBy?: AiGuestOrderByWithRelationInput | AiGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiGuests.
     */
    cursor?: AiGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGuests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiGuests.
     */
    distinct?: AiGuestScalarFieldEnum | AiGuestScalarFieldEnum[]
  }

  /**
   * AiGuest findMany
   */
  export type AiGuestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    /**
     * Filter, which AiGuests to fetch.
     */
    where?: AiGuestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGuests to fetch.
     */
    orderBy?: AiGuestOrderByWithRelationInput | AiGuestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiGuests.
     */
    cursor?: AiGuestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGuests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGuests.
     */
    skip?: number
    distinct?: AiGuestScalarFieldEnum | AiGuestScalarFieldEnum[]
  }

  /**
   * AiGuest create
   */
  export type AiGuestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    /**
     * The data needed to create a AiGuest.
     */
    data: XOR<AiGuestCreateInput, AiGuestUncheckedCreateInput>
  }

  /**
   * AiGuest createMany
   */
  export type AiGuestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiGuests.
     */
    data: AiGuestCreateManyInput | AiGuestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiGuest update
   */
  export type AiGuestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    /**
     * The data needed to update a AiGuest.
     */
    data: XOR<AiGuestUpdateInput, AiGuestUncheckedUpdateInput>
    /**
     * Choose, which AiGuest to update.
     */
    where: AiGuestWhereUniqueInput
  }

  /**
   * AiGuest updateMany
   */
  export type AiGuestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiGuests.
     */
    data: XOR<AiGuestUpdateManyMutationInput, AiGuestUncheckedUpdateManyInput>
    /**
     * Filter which AiGuests to update
     */
    where?: AiGuestWhereInput
    /**
     * Limit how many AiGuests to update.
     */
    limit?: number
  }

  /**
   * AiGuest upsert
   */
  export type AiGuestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    /**
     * The filter to search for the AiGuest to update in case it exists.
     */
    where: AiGuestWhereUniqueInput
    /**
     * In case the AiGuest found by the `where` argument doesn't exist, create a new AiGuest with this data.
     */
    create: XOR<AiGuestCreateInput, AiGuestUncheckedCreateInput>
    /**
     * In case the AiGuest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiGuestUpdateInput, AiGuestUncheckedUpdateInput>
  }

  /**
   * AiGuest delete
   */
  export type AiGuestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
    /**
     * Filter which AiGuest to delete.
     */
    where: AiGuestWhereUniqueInput
  }

  /**
   * AiGuest deleteMany
   */
  export type AiGuestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiGuests to delete
     */
    where?: AiGuestWhereInput
    /**
     * Limit how many AiGuests to delete.
     */
    limit?: number
  }

  /**
   * AiGuest without action
   */
  export type AiGuestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGuest
     */
    select?: AiGuestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiGuest
     */
    omit?: AiGuestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGuestInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type TopicSumAggregateOutputType = {
    id: number | null
    showNote: number | null
  }

  export type TopicMinAggregateOutputType = {
    id: number | null
    name: string | null
    showNote: number | null
  }

  export type TopicMaxAggregateOutputType = {
    id: number | null
    name: string | null
    showNote: number | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    name: number
    showNote: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type TopicSumAggregateInputType = {
    id?: true
    showNote?: true
  }

  export type TopicMinAggregateInputType = {
    id?: true
    name?: true
    showNote?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    name?: true
    showNote?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    name?: true
    showNote?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: number
    name: string
    showNote: number
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    showNote?: boolean
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>



  export type TopicSelectScalar = {
    id?: boolean
    name?: boolean
    showNote?: boolean
  }

  export type TopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "showNote", ExtArgs["result"]["topic"]>
  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiShowNote?: boolean | AiShowNoteDefaultArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      aiShowNote: Prisma.$AiShowNotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      showNote: number
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiShowNote<T extends AiShowNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiShowNoteDefaultArgs<ExtArgs>>): Prisma__AiShowNoteClient<$Result.GetResult<Prisma.$AiShowNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'Int'>
    readonly name: FieldRef<"Topic", 'String'>
    readonly showNote: FieldRef<"Topic", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to delete.
     */
    limit?: number
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    published_at: Date | null
    thumbnail: string | null
    slug: string | null
  }

  export type VideoMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    published_at: Date | null
    thumbnail: string | null
    slug: string | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    title: number
    description: number
    url: number
    published_at: number
    thumbnail: number
    slug: number
    _all: number
  }


  export type VideoMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    published_at?: true
    thumbnail?: true
    slug?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    published_at?: true
    thumbnail?: true
    slug?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    published_at?: true
    thumbnail?: true
    slug?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    id: string
    title: string
    description: string | null
    url: string
    published_at: Date
    thumbnail: string
    slug: string
    _count: VideoCountAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    published_at?: boolean
    thumbnail?: boolean
    slug?: boolean
    playlists?: boolean | Video$playlistsArgs<ExtArgs>
    shows?: boolean | Video$showsArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>



  export type VideoSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    published_at?: boolean
    thumbnail?: boolean
    slug?: boolean
  }

  export type VideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "url" | "published_at" | "thumbnail" | "slug", ExtArgs["result"]["video"]>
  export type VideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playlists?: boolean | Video$playlistsArgs<ExtArgs>
    shows?: boolean | Video$showsArgs<ExtArgs>
    _count?: boolean | VideoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {
      playlists: Prisma.$PlaylistOnVideoPayload<ExtArgs>[]
      shows: Prisma.$ShowVideoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      url: string
      published_at: Date
      thumbnail: string
      slug: string
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFindUniqueArgs>(args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFindFirstArgs>(args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFindManyArgs>(args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends VideoCreateArgs>(args: SelectSubset<T, VideoCreateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCreateManyArgs>(args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends VideoDeleteArgs>(args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoUpdateArgs>(args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoDeleteManyArgs>(args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoUpdateManyArgs>(args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends VideoUpsertArgs>(args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playlists<T extends Video$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, Video$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shows<T extends Video$showsArgs<ExtArgs> = {}>(args?: Subset<T, Video$showsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Video model
   */
  interface VideoFieldRefs {
    readonly id: FieldRef<"Video", 'String'>
    readonly title: FieldRef<"Video", 'String'>
    readonly description: FieldRef<"Video", 'String'>
    readonly url: FieldRef<"Video", 'String'>
    readonly published_at: FieldRef<"Video", 'DateTime'>
    readonly thumbnail: FieldRef<"Video", 'String'>
    readonly slug: FieldRef<"Video", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }

  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }

  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to delete.
     */
    limit?: number
  }

  /**
   * Video.playlists
   */
  export type Video$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    where?: PlaylistOnVideoWhereInput
    orderBy?: PlaylistOnVideoOrderByWithRelationInput | PlaylistOnVideoOrderByWithRelationInput[]
    cursor?: PlaylistOnVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistOnVideoScalarFieldEnum | PlaylistOnVideoScalarFieldEnum[]
  }

  /**
   * Video.shows
   */
  export type Video$showsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    where?: ShowVideoWhereInput
    orderBy?: ShowVideoOrderByWithRelationInput | ShowVideoOrderByWithRelationInput[]
    cursor?: ShowVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShowVideoScalarFieldEnum | ShowVideoScalarFieldEnum[]
  }

  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
  }


  /**
   * Model Playlist
   */

  export type AggregatePlaylist = {
    _count: PlaylistCountAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  export type PlaylistMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    created_at: Date | null
    slug: string | null
    unlisted: boolean | null
  }

  export type PlaylistMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    created_at: Date | null
    slug: string | null
    unlisted: boolean | null
  }

  export type PlaylistCountAggregateOutputType = {
    id: number
    title: number
    description: number
    created_at: number
    slug: number
    unlisted: number
    _all: number
  }


  export type PlaylistMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    created_at?: true
    slug?: true
    unlisted?: true
  }

  export type PlaylistMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    created_at?: true
    slug?: true
    unlisted?: true
  }

  export type PlaylistCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    created_at?: true
    slug?: true
    unlisted?: true
    _all?: true
  }

  export type PlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlist to aggregate.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Playlists
    **/
    _count?: true | PlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistMaxAggregateInputType
  }

  export type GetPlaylistAggregateType<T extends PlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylist[P]>
      : GetScalarType<T[P], AggregatePlaylist[P]>
  }




  export type PlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistWhereInput
    orderBy?: PlaylistOrderByWithAggregationInput | PlaylistOrderByWithAggregationInput[]
    by: PlaylistScalarFieldEnum[] | PlaylistScalarFieldEnum
    having?: PlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaylistCountAggregateInputType | true
    _min?: PlaylistMinAggregateInputType
    _max?: PlaylistMaxAggregateInputType
  }

  export type PlaylistGroupByOutputType = {
    id: string
    title: string
    description: string | null
    created_at: Date
    slug: string
    unlisted: boolean | null
    _count: PlaylistCountAggregateOutputType | null
    _min: PlaylistMinAggregateOutputType | null
    _max: PlaylistMaxAggregateOutputType | null
  }

  type GetPlaylistGroupByPayload<T extends PlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    slug?: boolean
    unlisted?: boolean
    videos?: boolean | Playlist$videosArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlist"]>



  export type PlaylistSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    slug?: boolean
    unlisted?: boolean
  }

  export type PlaylistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "created_at" | "slug" | "unlisted", ExtArgs["result"]["playlist"]>
  export type PlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | Playlist$videosArgs<ExtArgs>
    _count?: boolean | PlaylistCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Playlist"
    objects: {
      videos: Prisma.$PlaylistOnVideoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      created_at: Date
      slug: string
      unlisted: boolean | null
    }, ExtArgs["result"]["playlist"]>
    composites: {}
  }

  type PlaylistGetPayload<S extends boolean | null | undefined | PlaylistDefaultArgs> = $Result.GetResult<Prisma.$PlaylistPayload, S>

  type PlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistCountAggregateInputType | true
    }

  export interface PlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Playlist'], meta: { name: 'Playlist' } }
    /**
     * Find zero or one Playlist that matches the filter.
     * @param {PlaylistFindUniqueArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistFindUniqueArgs>(args: SelectSubset<T, PlaylistFindUniqueArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Playlist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistFindUniqueOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistFindFirstArgs>(args?: SelectSubset<T, PlaylistFindFirstArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Playlist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindFirstOrThrowArgs} args - Arguments to find a Playlist
     * @example
     * // Get one Playlist
     * const playlist = await prisma.playlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Playlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Playlists
     * const playlists = await prisma.playlist.findMany()
     * 
     * // Get first 10 Playlists
     * const playlists = await prisma.playlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playlistWithIdOnly = await prisma.playlist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaylistFindManyArgs>(args?: SelectSubset<T, PlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Playlist.
     * @param {PlaylistCreateArgs} args - Arguments to create a Playlist.
     * @example
     * // Create one Playlist
     * const Playlist = await prisma.playlist.create({
     *   data: {
     *     // ... data to create a Playlist
     *   }
     * })
     * 
     */
    create<T extends PlaylistCreateArgs>(args: SelectSubset<T, PlaylistCreateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Playlists.
     * @param {PlaylistCreateManyArgs} args - Arguments to create many Playlists.
     * @example
     * // Create many Playlists
     * const playlist = await prisma.playlist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistCreateManyArgs>(args?: SelectSubset<T, PlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Playlist.
     * @param {PlaylistDeleteArgs} args - Arguments to delete one Playlist.
     * @example
     * // Delete one Playlist
     * const Playlist = await prisma.playlist.delete({
     *   where: {
     *     // ... filter to delete one Playlist
     *   }
     * })
     * 
     */
    delete<T extends PlaylistDeleteArgs>(args: SelectSubset<T, PlaylistDeleteArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Playlist.
     * @param {PlaylistUpdateArgs} args - Arguments to update one Playlist.
     * @example
     * // Update one Playlist
     * const playlist = await prisma.playlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistUpdateArgs>(args: SelectSubset<T, PlaylistUpdateArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Playlists.
     * @param {PlaylistDeleteManyArgs} args - Arguments to filter Playlists to delete.
     * @example
     * // Delete a few Playlists
     * const { count } = await prisma.playlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistDeleteManyArgs>(args?: SelectSubset<T, PlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Playlists
     * const playlist = await prisma.playlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistUpdateManyArgs>(args: SelectSubset<T, PlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Playlist.
     * @param {PlaylistUpsertArgs} args - Arguments to update or create a Playlist.
     * @example
     * // Update or create a Playlist
     * const playlist = await prisma.playlist.upsert({
     *   create: {
     *     // ... data to create a Playlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Playlist we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistUpsertArgs>(args: SelectSubset<T, PlaylistUpsertArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Playlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistCountArgs} args - Arguments to filter Playlists to count.
     * @example
     * // Count the number of Playlists
     * const count = await prisma.playlist.count({
     *   where: {
     *     // ... the filter for the Playlists we want to count
     *   }
     * })
    **/
    count<T extends PlaylistCountArgs>(
      args?: Subset<T, PlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistAggregateArgs>(args: Subset<T, PlaylistAggregateArgs>): Prisma.PrismaPromise<GetPlaylistAggregateType<T>>

    /**
     * Group by Playlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Playlist model
   */
  readonly fields: PlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Playlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videos<T extends Playlist$videosArgs<ExtArgs> = {}>(args?: Subset<T, Playlist$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Playlist model
   */
  interface PlaylistFieldRefs {
    readonly id: FieldRef<"Playlist", 'String'>
    readonly title: FieldRef<"Playlist", 'String'>
    readonly description: FieldRef<"Playlist", 'String'>
    readonly created_at: FieldRef<"Playlist", 'DateTime'>
    readonly slug: FieldRef<"Playlist", 'String'>
    readonly unlisted: FieldRef<"Playlist", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Playlist findUnique
   */
  export type PlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findUniqueOrThrow
   */
  export type PlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist findFirst
   */
  export type PlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findFirstOrThrow
   */
  export type PlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlist to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Playlists.
     */
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist findMany
   */
  export type PlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter, which Playlists to fetch.
     */
    where?: PlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Playlists to fetch.
     */
    orderBy?: PlaylistOrderByWithRelationInput | PlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Playlists.
     */
    cursor?: PlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Playlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Playlists.
     */
    skip?: number
    distinct?: PlaylistScalarFieldEnum | PlaylistScalarFieldEnum[]
  }

  /**
   * Playlist create
   */
  export type PlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a Playlist.
     */
    data: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
  }

  /**
   * Playlist createMany
   */
  export type PlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Playlists.
     */
    data: PlaylistCreateManyInput | PlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Playlist update
   */
  export type PlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a Playlist.
     */
    data: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
    /**
     * Choose, which Playlist to update.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist updateMany
   */
  export type PlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Playlists.
     */
    data: XOR<PlaylistUpdateManyMutationInput, PlaylistUncheckedUpdateManyInput>
    /**
     * Filter which Playlists to update
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to update.
     */
    limit?: number
  }

  /**
   * Playlist upsert
   */
  export type PlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the Playlist to update in case it exists.
     */
    where: PlaylistWhereUniqueInput
    /**
     * In case the Playlist found by the `where` argument doesn't exist, create a new Playlist with this data.
     */
    create: XOR<PlaylistCreateInput, PlaylistUncheckedCreateInput>
    /**
     * In case the Playlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistUpdateInput, PlaylistUncheckedUpdateInput>
  }

  /**
   * Playlist delete
   */
  export type PlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
    /**
     * Filter which Playlist to delete.
     */
    where: PlaylistWhereUniqueInput
  }

  /**
   * Playlist deleteMany
   */
  export type PlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Playlists to delete
     */
    where?: PlaylistWhereInput
    /**
     * Limit how many Playlists to delete.
     */
    limit?: number
  }

  /**
   * Playlist.videos
   */
  export type Playlist$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    where?: PlaylistOnVideoWhereInput
    orderBy?: PlaylistOnVideoOrderByWithRelationInput | PlaylistOnVideoOrderByWithRelationInput[]
    cursor?: PlaylistOnVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaylistOnVideoScalarFieldEnum | PlaylistOnVideoScalarFieldEnum[]
  }

  /**
   * Playlist without action
   */
  export type PlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Playlist
     */
    select?: PlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Playlist
     */
    omit?: PlaylistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistInclude<ExtArgs> | null
  }


  /**
   * Model PlaylistOnVideo
   */

  export type AggregatePlaylistOnVideo = {
    _count: PlaylistOnVideoCountAggregateOutputType | null
    _avg: PlaylistOnVideoAvgAggregateOutputType | null
    _sum: PlaylistOnVideoSumAggregateOutputType | null
    _min: PlaylistOnVideoMinAggregateOutputType | null
    _max: PlaylistOnVideoMaxAggregateOutputType | null
  }

  export type PlaylistOnVideoAvgAggregateOutputType = {
    order: number | null
  }

  export type PlaylistOnVideoSumAggregateOutputType = {
    order: number | null
  }

  export type PlaylistOnVideoMinAggregateOutputType = {
    video_id: string | null
    playlist_id: string | null
    order: number | null
  }

  export type PlaylistOnVideoMaxAggregateOutputType = {
    video_id: string | null
    playlist_id: string | null
    order: number | null
  }

  export type PlaylistOnVideoCountAggregateOutputType = {
    video_id: number
    playlist_id: number
    order: number
    _all: number
  }


  export type PlaylistOnVideoAvgAggregateInputType = {
    order?: true
  }

  export type PlaylistOnVideoSumAggregateInputType = {
    order?: true
  }

  export type PlaylistOnVideoMinAggregateInputType = {
    video_id?: true
    playlist_id?: true
    order?: true
  }

  export type PlaylistOnVideoMaxAggregateInputType = {
    video_id?: true
    playlist_id?: true
    order?: true
  }

  export type PlaylistOnVideoCountAggregateInputType = {
    video_id?: true
    playlist_id?: true
    order?: true
    _all?: true
  }

  export type PlaylistOnVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistOnVideo to aggregate.
     */
    where?: PlaylistOnVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistOnVideos to fetch.
     */
    orderBy?: PlaylistOnVideoOrderByWithRelationInput | PlaylistOnVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaylistOnVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistOnVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistOnVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaylistOnVideos
    **/
    _count?: true | PlaylistOnVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaylistOnVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaylistOnVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaylistOnVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaylistOnVideoMaxAggregateInputType
  }

  export type GetPlaylistOnVideoAggregateType<T extends PlaylistOnVideoAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaylistOnVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaylistOnVideo[P]>
      : GetScalarType<T[P], AggregatePlaylistOnVideo[P]>
  }




  export type PlaylistOnVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaylistOnVideoWhereInput
    orderBy?: PlaylistOnVideoOrderByWithAggregationInput | PlaylistOnVideoOrderByWithAggregationInput[]
    by: PlaylistOnVideoScalarFieldEnum[] | PlaylistOnVideoScalarFieldEnum
    having?: PlaylistOnVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaylistOnVideoCountAggregateInputType | true
    _avg?: PlaylistOnVideoAvgAggregateInputType
    _sum?: PlaylistOnVideoSumAggregateInputType
    _min?: PlaylistOnVideoMinAggregateInputType
    _max?: PlaylistOnVideoMaxAggregateInputType
  }

  export type PlaylistOnVideoGroupByOutputType = {
    video_id: string
    playlist_id: string
    order: number
    _count: PlaylistOnVideoCountAggregateOutputType | null
    _avg: PlaylistOnVideoAvgAggregateOutputType | null
    _sum: PlaylistOnVideoSumAggregateOutputType | null
    _min: PlaylistOnVideoMinAggregateOutputType | null
    _max: PlaylistOnVideoMaxAggregateOutputType | null
  }

  type GetPlaylistOnVideoGroupByPayload<T extends PlaylistOnVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaylistOnVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaylistOnVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaylistOnVideoGroupByOutputType[P]>
            : GetScalarType<T[P], PlaylistOnVideoGroupByOutputType[P]>
        }
      >
    >


  export type PlaylistOnVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    video_id?: boolean
    playlist_id?: boolean
    order?: boolean
    video?: boolean | VideoDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playlistOnVideo"]>



  export type PlaylistOnVideoSelectScalar = {
    video_id?: boolean
    playlist_id?: boolean
    order?: boolean
  }

  export type PlaylistOnVideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"video_id" | "playlist_id" | "order", ExtArgs["result"]["playlistOnVideo"]>
  export type PlaylistOnVideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    video?: boolean | VideoDefaultArgs<ExtArgs>
    playlist?: boolean | PlaylistDefaultArgs<ExtArgs>
  }

  export type $PlaylistOnVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaylistOnVideo"
    objects: {
      video: Prisma.$VideoPayload<ExtArgs>
      playlist: Prisma.$PlaylistPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      video_id: string
      playlist_id: string
      order: number
    }, ExtArgs["result"]["playlistOnVideo"]>
    composites: {}
  }

  type PlaylistOnVideoGetPayload<S extends boolean | null | undefined | PlaylistOnVideoDefaultArgs> = $Result.GetResult<Prisma.$PlaylistOnVideoPayload, S>

  type PlaylistOnVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaylistOnVideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaylistOnVideoCountAggregateInputType | true
    }

  export interface PlaylistOnVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaylistOnVideo'], meta: { name: 'PlaylistOnVideo' } }
    /**
     * Find zero or one PlaylistOnVideo that matches the filter.
     * @param {PlaylistOnVideoFindUniqueArgs} args - Arguments to find a PlaylistOnVideo
     * @example
     * // Get one PlaylistOnVideo
     * const playlistOnVideo = await prisma.playlistOnVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaylistOnVideoFindUniqueArgs>(args: SelectSubset<T, PlaylistOnVideoFindUniqueArgs<ExtArgs>>): Prisma__PlaylistOnVideoClient<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaylistOnVideo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaylistOnVideoFindUniqueOrThrowArgs} args - Arguments to find a PlaylistOnVideo
     * @example
     * // Get one PlaylistOnVideo
     * const playlistOnVideo = await prisma.playlistOnVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaylistOnVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaylistOnVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaylistOnVideoClient<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistOnVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistOnVideoFindFirstArgs} args - Arguments to find a PlaylistOnVideo
     * @example
     * // Get one PlaylistOnVideo
     * const playlistOnVideo = await prisma.playlistOnVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaylistOnVideoFindFirstArgs>(args?: SelectSubset<T, PlaylistOnVideoFindFirstArgs<ExtArgs>>): Prisma__PlaylistOnVideoClient<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaylistOnVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistOnVideoFindFirstOrThrowArgs} args - Arguments to find a PlaylistOnVideo
     * @example
     * // Get one PlaylistOnVideo
     * const playlistOnVideo = await prisma.playlistOnVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaylistOnVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaylistOnVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaylistOnVideoClient<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaylistOnVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistOnVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaylistOnVideos
     * const playlistOnVideos = await prisma.playlistOnVideo.findMany()
     * 
     * // Get first 10 PlaylistOnVideos
     * const playlistOnVideos = await prisma.playlistOnVideo.findMany({ take: 10 })
     * 
     * // Only select the `video_id`
     * const playlistOnVideoWithVideo_idOnly = await prisma.playlistOnVideo.findMany({ select: { video_id: true } })
     * 
     */
    findMany<T extends PlaylistOnVideoFindManyArgs>(args?: SelectSubset<T, PlaylistOnVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaylistOnVideo.
     * @param {PlaylistOnVideoCreateArgs} args - Arguments to create a PlaylistOnVideo.
     * @example
     * // Create one PlaylistOnVideo
     * const PlaylistOnVideo = await prisma.playlistOnVideo.create({
     *   data: {
     *     // ... data to create a PlaylistOnVideo
     *   }
     * })
     * 
     */
    create<T extends PlaylistOnVideoCreateArgs>(args: SelectSubset<T, PlaylistOnVideoCreateArgs<ExtArgs>>): Prisma__PlaylistOnVideoClient<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaylistOnVideos.
     * @param {PlaylistOnVideoCreateManyArgs} args - Arguments to create many PlaylistOnVideos.
     * @example
     * // Create many PlaylistOnVideos
     * const playlistOnVideo = await prisma.playlistOnVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaylistOnVideoCreateManyArgs>(args?: SelectSubset<T, PlaylistOnVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlaylistOnVideo.
     * @param {PlaylistOnVideoDeleteArgs} args - Arguments to delete one PlaylistOnVideo.
     * @example
     * // Delete one PlaylistOnVideo
     * const PlaylistOnVideo = await prisma.playlistOnVideo.delete({
     *   where: {
     *     // ... filter to delete one PlaylistOnVideo
     *   }
     * })
     * 
     */
    delete<T extends PlaylistOnVideoDeleteArgs>(args: SelectSubset<T, PlaylistOnVideoDeleteArgs<ExtArgs>>): Prisma__PlaylistOnVideoClient<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaylistOnVideo.
     * @param {PlaylistOnVideoUpdateArgs} args - Arguments to update one PlaylistOnVideo.
     * @example
     * // Update one PlaylistOnVideo
     * const playlistOnVideo = await prisma.playlistOnVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaylistOnVideoUpdateArgs>(args: SelectSubset<T, PlaylistOnVideoUpdateArgs<ExtArgs>>): Prisma__PlaylistOnVideoClient<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaylistOnVideos.
     * @param {PlaylistOnVideoDeleteManyArgs} args - Arguments to filter PlaylistOnVideos to delete.
     * @example
     * // Delete a few PlaylistOnVideos
     * const { count } = await prisma.playlistOnVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaylistOnVideoDeleteManyArgs>(args?: SelectSubset<T, PlaylistOnVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaylistOnVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistOnVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaylistOnVideos
     * const playlistOnVideo = await prisma.playlistOnVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaylistOnVideoUpdateManyArgs>(args: SelectSubset<T, PlaylistOnVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlaylistOnVideo.
     * @param {PlaylistOnVideoUpsertArgs} args - Arguments to update or create a PlaylistOnVideo.
     * @example
     * // Update or create a PlaylistOnVideo
     * const playlistOnVideo = await prisma.playlistOnVideo.upsert({
     *   create: {
     *     // ... data to create a PlaylistOnVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaylistOnVideo we want to update
     *   }
     * })
     */
    upsert<T extends PlaylistOnVideoUpsertArgs>(args: SelectSubset<T, PlaylistOnVideoUpsertArgs<ExtArgs>>): Prisma__PlaylistOnVideoClient<$Result.GetResult<Prisma.$PlaylistOnVideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaylistOnVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistOnVideoCountArgs} args - Arguments to filter PlaylistOnVideos to count.
     * @example
     * // Count the number of PlaylistOnVideos
     * const count = await prisma.playlistOnVideo.count({
     *   where: {
     *     // ... the filter for the PlaylistOnVideos we want to count
     *   }
     * })
    **/
    count<T extends PlaylistOnVideoCountArgs>(
      args?: Subset<T, PlaylistOnVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaylistOnVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaylistOnVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistOnVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaylistOnVideoAggregateArgs>(args: Subset<T, PlaylistOnVideoAggregateArgs>): Prisma.PrismaPromise<GetPlaylistOnVideoAggregateType<T>>

    /**
     * Group by PlaylistOnVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaylistOnVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaylistOnVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaylistOnVideoGroupByArgs['orderBy'] }
        : { orderBy?: PlaylistOnVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaylistOnVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaylistOnVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaylistOnVideo model
   */
  readonly fields: PlaylistOnVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaylistOnVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaylistOnVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    playlist<T extends PlaylistDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaylistDefaultArgs<ExtArgs>>): Prisma__PlaylistClient<$Result.GetResult<Prisma.$PlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaylistOnVideo model
   */
  interface PlaylistOnVideoFieldRefs {
    readonly video_id: FieldRef<"PlaylistOnVideo", 'String'>
    readonly playlist_id: FieldRef<"PlaylistOnVideo", 'String'>
    readonly order: FieldRef<"PlaylistOnVideo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlaylistOnVideo findUnique
   */
  export type PlaylistOnVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistOnVideo to fetch.
     */
    where: PlaylistOnVideoWhereUniqueInput
  }

  /**
   * PlaylistOnVideo findUniqueOrThrow
   */
  export type PlaylistOnVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistOnVideo to fetch.
     */
    where: PlaylistOnVideoWhereUniqueInput
  }

  /**
   * PlaylistOnVideo findFirst
   */
  export type PlaylistOnVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistOnVideo to fetch.
     */
    where?: PlaylistOnVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistOnVideos to fetch.
     */
    orderBy?: PlaylistOnVideoOrderByWithRelationInput | PlaylistOnVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistOnVideos.
     */
    cursor?: PlaylistOnVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistOnVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistOnVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistOnVideos.
     */
    distinct?: PlaylistOnVideoScalarFieldEnum | PlaylistOnVideoScalarFieldEnum[]
  }

  /**
   * PlaylistOnVideo findFirstOrThrow
   */
  export type PlaylistOnVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistOnVideo to fetch.
     */
    where?: PlaylistOnVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistOnVideos to fetch.
     */
    orderBy?: PlaylistOnVideoOrderByWithRelationInput | PlaylistOnVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaylistOnVideos.
     */
    cursor?: PlaylistOnVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistOnVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistOnVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaylistOnVideos.
     */
    distinct?: PlaylistOnVideoScalarFieldEnum | PlaylistOnVideoScalarFieldEnum[]
  }

  /**
   * PlaylistOnVideo findMany
   */
  export type PlaylistOnVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    /**
     * Filter, which PlaylistOnVideos to fetch.
     */
    where?: PlaylistOnVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaylistOnVideos to fetch.
     */
    orderBy?: PlaylistOnVideoOrderByWithRelationInput | PlaylistOnVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaylistOnVideos.
     */
    cursor?: PlaylistOnVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaylistOnVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaylistOnVideos.
     */
    skip?: number
    distinct?: PlaylistOnVideoScalarFieldEnum | PlaylistOnVideoScalarFieldEnum[]
  }

  /**
   * PlaylistOnVideo create
   */
  export type PlaylistOnVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaylistOnVideo.
     */
    data: XOR<PlaylistOnVideoCreateInput, PlaylistOnVideoUncheckedCreateInput>
  }

  /**
   * PlaylistOnVideo createMany
   */
  export type PlaylistOnVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaylistOnVideos.
     */
    data: PlaylistOnVideoCreateManyInput | PlaylistOnVideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaylistOnVideo update
   */
  export type PlaylistOnVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaylistOnVideo.
     */
    data: XOR<PlaylistOnVideoUpdateInput, PlaylistOnVideoUncheckedUpdateInput>
    /**
     * Choose, which PlaylistOnVideo to update.
     */
    where: PlaylistOnVideoWhereUniqueInput
  }

  /**
   * PlaylistOnVideo updateMany
   */
  export type PlaylistOnVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaylistOnVideos.
     */
    data: XOR<PlaylistOnVideoUpdateManyMutationInput, PlaylistOnVideoUncheckedUpdateManyInput>
    /**
     * Filter which PlaylistOnVideos to update
     */
    where?: PlaylistOnVideoWhereInput
    /**
     * Limit how many PlaylistOnVideos to update.
     */
    limit?: number
  }

  /**
   * PlaylistOnVideo upsert
   */
  export type PlaylistOnVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaylistOnVideo to update in case it exists.
     */
    where: PlaylistOnVideoWhereUniqueInput
    /**
     * In case the PlaylistOnVideo found by the `where` argument doesn't exist, create a new PlaylistOnVideo with this data.
     */
    create: XOR<PlaylistOnVideoCreateInput, PlaylistOnVideoUncheckedCreateInput>
    /**
     * In case the PlaylistOnVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaylistOnVideoUpdateInput, PlaylistOnVideoUncheckedUpdateInput>
  }

  /**
   * PlaylistOnVideo delete
   */
  export type PlaylistOnVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
    /**
     * Filter which PlaylistOnVideo to delete.
     */
    where: PlaylistOnVideoWhereUniqueInput
  }

  /**
   * PlaylistOnVideo deleteMany
   */
  export type PlaylistOnVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaylistOnVideos to delete
     */
    where?: PlaylistOnVideoWhereInput
    /**
     * Limit how many PlaylistOnVideos to delete.
     */
    limit?: number
  }

  /**
   * PlaylistOnVideo without action
   */
  export type PlaylistOnVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaylistOnVideo
     */
    select?: PlaylistOnVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaylistOnVideo
     */
    omit?: PlaylistOnVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaylistOnVideoInclude<ExtArgs> | null
  }


  /**
   * Model RemotePlaylist
   */

  export type AggregateRemotePlaylist = {
    _count: RemotePlaylistCountAggregateOutputType | null
    _avg: RemotePlaylistAvgAggregateOutputType | null
    _sum: RemotePlaylistSumAggregateOutputType | null
    _min: RemotePlaylistMinAggregateOutputType | null
    _max: RemotePlaylistMaxAggregateOutputType | null
  }

  export type RemotePlaylistAvgAggregateOutputType = {
    videos_count: number | null
  }

  export type RemotePlaylistSumAggregateOutputType = {
    videos_count: number | null
  }

  export type RemotePlaylistMinAggregateOutputType = {
    playlist_id: string | null
    title: string | null
    videos_count: number | null
    created_at: Date | null
  }

  export type RemotePlaylistMaxAggregateOutputType = {
    playlist_id: string | null
    title: string | null
    videos_count: number | null
    created_at: Date | null
  }

  export type RemotePlaylistCountAggregateOutputType = {
    playlist_id: number
    title: number
    videos_count: number
    created_at: number
    _all: number
  }


  export type RemotePlaylistAvgAggregateInputType = {
    videos_count?: true
  }

  export type RemotePlaylistSumAggregateInputType = {
    videos_count?: true
  }

  export type RemotePlaylistMinAggregateInputType = {
    playlist_id?: true
    title?: true
    videos_count?: true
    created_at?: true
  }

  export type RemotePlaylistMaxAggregateInputType = {
    playlist_id?: true
    title?: true
    videos_count?: true
    created_at?: true
  }

  export type RemotePlaylistCountAggregateInputType = {
    playlist_id?: true
    title?: true
    videos_count?: true
    created_at?: true
    _all?: true
  }

  export type RemotePlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemotePlaylist to aggregate.
     */
    where?: RemotePlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemotePlaylists to fetch.
     */
    orderBy?: RemotePlaylistOrderByWithRelationInput | RemotePlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RemotePlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemotePlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemotePlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RemotePlaylists
    **/
    _count?: true | RemotePlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RemotePlaylistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RemotePlaylistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RemotePlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RemotePlaylistMaxAggregateInputType
  }

  export type GetRemotePlaylistAggregateType<T extends RemotePlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregateRemotePlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRemotePlaylist[P]>
      : GetScalarType<T[P], AggregateRemotePlaylist[P]>
  }




  export type RemotePlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RemotePlaylistWhereInput
    orderBy?: RemotePlaylistOrderByWithAggregationInput | RemotePlaylistOrderByWithAggregationInput[]
    by: RemotePlaylistScalarFieldEnum[] | RemotePlaylistScalarFieldEnum
    having?: RemotePlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RemotePlaylistCountAggregateInputType | true
    _avg?: RemotePlaylistAvgAggregateInputType
    _sum?: RemotePlaylistSumAggregateInputType
    _min?: RemotePlaylistMinAggregateInputType
    _max?: RemotePlaylistMaxAggregateInputType
  }

  export type RemotePlaylistGroupByOutputType = {
    playlist_id: string
    title: string
    videos_count: number
    created_at: Date
    _count: RemotePlaylistCountAggregateOutputType | null
    _avg: RemotePlaylistAvgAggregateOutputType | null
    _sum: RemotePlaylistSumAggregateOutputType | null
    _min: RemotePlaylistMinAggregateOutputType | null
    _max: RemotePlaylistMaxAggregateOutputType | null
  }

  type GetRemotePlaylistGroupByPayload<T extends RemotePlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RemotePlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RemotePlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RemotePlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], RemotePlaylistGroupByOutputType[P]>
        }
      >
    >


  export type RemotePlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    playlist_id?: boolean
    title?: boolean
    videos_count?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["remotePlaylist"]>



  export type RemotePlaylistSelectScalar = {
    playlist_id?: boolean
    title?: boolean
    videos_count?: boolean
    created_at?: boolean
  }

  export type RemotePlaylistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"playlist_id" | "title" | "videos_count" | "created_at", ExtArgs["result"]["remotePlaylist"]>

  export type $RemotePlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RemotePlaylist"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      playlist_id: string
      title: string
      videos_count: number
      created_at: Date
    }, ExtArgs["result"]["remotePlaylist"]>
    composites: {}
  }

  type RemotePlaylistGetPayload<S extends boolean | null | undefined | RemotePlaylistDefaultArgs> = $Result.GetResult<Prisma.$RemotePlaylistPayload, S>

  type RemotePlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RemotePlaylistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RemotePlaylistCountAggregateInputType | true
    }

  export interface RemotePlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RemotePlaylist'], meta: { name: 'RemotePlaylist' } }
    /**
     * Find zero or one RemotePlaylist that matches the filter.
     * @param {RemotePlaylistFindUniqueArgs} args - Arguments to find a RemotePlaylist
     * @example
     * // Get one RemotePlaylist
     * const remotePlaylist = await prisma.remotePlaylist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RemotePlaylistFindUniqueArgs>(args: SelectSubset<T, RemotePlaylistFindUniqueArgs<ExtArgs>>): Prisma__RemotePlaylistClient<$Result.GetResult<Prisma.$RemotePlaylistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RemotePlaylist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RemotePlaylistFindUniqueOrThrowArgs} args - Arguments to find a RemotePlaylist
     * @example
     * // Get one RemotePlaylist
     * const remotePlaylist = await prisma.remotePlaylist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RemotePlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, RemotePlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RemotePlaylistClient<$Result.GetResult<Prisma.$RemotePlaylistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemotePlaylist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemotePlaylistFindFirstArgs} args - Arguments to find a RemotePlaylist
     * @example
     * // Get one RemotePlaylist
     * const remotePlaylist = await prisma.remotePlaylist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RemotePlaylistFindFirstArgs>(args?: SelectSubset<T, RemotePlaylistFindFirstArgs<ExtArgs>>): Prisma__RemotePlaylistClient<$Result.GetResult<Prisma.$RemotePlaylistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RemotePlaylist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemotePlaylistFindFirstOrThrowArgs} args - Arguments to find a RemotePlaylist
     * @example
     * // Get one RemotePlaylist
     * const remotePlaylist = await prisma.remotePlaylist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RemotePlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, RemotePlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__RemotePlaylistClient<$Result.GetResult<Prisma.$RemotePlaylistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RemotePlaylists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemotePlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RemotePlaylists
     * const remotePlaylists = await prisma.remotePlaylist.findMany()
     * 
     * // Get first 10 RemotePlaylists
     * const remotePlaylists = await prisma.remotePlaylist.findMany({ take: 10 })
     * 
     * // Only select the `playlist_id`
     * const remotePlaylistWithPlaylist_idOnly = await prisma.remotePlaylist.findMany({ select: { playlist_id: true } })
     * 
     */
    findMany<T extends RemotePlaylistFindManyArgs>(args?: SelectSubset<T, RemotePlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RemotePlaylistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RemotePlaylist.
     * @param {RemotePlaylistCreateArgs} args - Arguments to create a RemotePlaylist.
     * @example
     * // Create one RemotePlaylist
     * const RemotePlaylist = await prisma.remotePlaylist.create({
     *   data: {
     *     // ... data to create a RemotePlaylist
     *   }
     * })
     * 
     */
    create<T extends RemotePlaylistCreateArgs>(args: SelectSubset<T, RemotePlaylistCreateArgs<ExtArgs>>): Prisma__RemotePlaylistClient<$Result.GetResult<Prisma.$RemotePlaylistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RemotePlaylists.
     * @param {RemotePlaylistCreateManyArgs} args - Arguments to create many RemotePlaylists.
     * @example
     * // Create many RemotePlaylists
     * const remotePlaylist = await prisma.remotePlaylist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RemotePlaylistCreateManyArgs>(args?: SelectSubset<T, RemotePlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RemotePlaylist.
     * @param {RemotePlaylistDeleteArgs} args - Arguments to delete one RemotePlaylist.
     * @example
     * // Delete one RemotePlaylist
     * const RemotePlaylist = await prisma.remotePlaylist.delete({
     *   where: {
     *     // ... filter to delete one RemotePlaylist
     *   }
     * })
     * 
     */
    delete<T extends RemotePlaylistDeleteArgs>(args: SelectSubset<T, RemotePlaylistDeleteArgs<ExtArgs>>): Prisma__RemotePlaylistClient<$Result.GetResult<Prisma.$RemotePlaylistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RemotePlaylist.
     * @param {RemotePlaylistUpdateArgs} args - Arguments to update one RemotePlaylist.
     * @example
     * // Update one RemotePlaylist
     * const remotePlaylist = await prisma.remotePlaylist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RemotePlaylistUpdateArgs>(args: SelectSubset<T, RemotePlaylistUpdateArgs<ExtArgs>>): Prisma__RemotePlaylistClient<$Result.GetResult<Prisma.$RemotePlaylistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RemotePlaylists.
     * @param {RemotePlaylistDeleteManyArgs} args - Arguments to filter RemotePlaylists to delete.
     * @example
     * // Delete a few RemotePlaylists
     * const { count } = await prisma.remotePlaylist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RemotePlaylistDeleteManyArgs>(args?: SelectSubset<T, RemotePlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RemotePlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemotePlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RemotePlaylists
     * const remotePlaylist = await prisma.remotePlaylist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RemotePlaylistUpdateManyArgs>(args: SelectSubset<T, RemotePlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RemotePlaylist.
     * @param {RemotePlaylistUpsertArgs} args - Arguments to update or create a RemotePlaylist.
     * @example
     * // Update or create a RemotePlaylist
     * const remotePlaylist = await prisma.remotePlaylist.upsert({
     *   create: {
     *     // ... data to create a RemotePlaylist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RemotePlaylist we want to update
     *   }
     * })
     */
    upsert<T extends RemotePlaylistUpsertArgs>(args: SelectSubset<T, RemotePlaylistUpsertArgs<ExtArgs>>): Prisma__RemotePlaylistClient<$Result.GetResult<Prisma.$RemotePlaylistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RemotePlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemotePlaylistCountArgs} args - Arguments to filter RemotePlaylists to count.
     * @example
     * // Count the number of RemotePlaylists
     * const count = await prisma.remotePlaylist.count({
     *   where: {
     *     // ... the filter for the RemotePlaylists we want to count
     *   }
     * })
    **/
    count<T extends RemotePlaylistCountArgs>(
      args?: Subset<T, RemotePlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RemotePlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RemotePlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemotePlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RemotePlaylistAggregateArgs>(args: Subset<T, RemotePlaylistAggregateArgs>): Prisma.PrismaPromise<GetRemotePlaylistAggregateType<T>>

    /**
     * Group by RemotePlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemotePlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RemotePlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RemotePlaylistGroupByArgs['orderBy'] }
        : { orderBy?: RemotePlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RemotePlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemotePlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RemotePlaylist model
   */
  readonly fields: RemotePlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RemotePlaylist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RemotePlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RemotePlaylist model
   */
  interface RemotePlaylistFieldRefs {
    readonly playlist_id: FieldRef<"RemotePlaylist", 'String'>
    readonly title: FieldRef<"RemotePlaylist", 'String'>
    readonly videos_count: FieldRef<"RemotePlaylist", 'Int'>
    readonly created_at: FieldRef<"RemotePlaylist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RemotePlaylist findUnique
   */
  export type RemotePlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
    /**
     * Filter, which RemotePlaylist to fetch.
     */
    where: RemotePlaylistWhereUniqueInput
  }

  /**
   * RemotePlaylist findUniqueOrThrow
   */
  export type RemotePlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
    /**
     * Filter, which RemotePlaylist to fetch.
     */
    where: RemotePlaylistWhereUniqueInput
  }

  /**
   * RemotePlaylist findFirst
   */
  export type RemotePlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
    /**
     * Filter, which RemotePlaylist to fetch.
     */
    where?: RemotePlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemotePlaylists to fetch.
     */
    orderBy?: RemotePlaylistOrderByWithRelationInput | RemotePlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemotePlaylists.
     */
    cursor?: RemotePlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemotePlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemotePlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemotePlaylists.
     */
    distinct?: RemotePlaylistScalarFieldEnum | RemotePlaylistScalarFieldEnum[]
  }

  /**
   * RemotePlaylist findFirstOrThrow
   */
  export type RemotePlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
    /**
     * Filter, which RemotePlaylist to fetch.
     */
    where?: RemotePlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemotePlaylists to fetch.
     */
    orderBy?: RemotePlaylistOrderByWithRelationInput | RemotePlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RemotePlaylists.
     */
    cursor?: RemotePlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemotePlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemotePlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RemotePlaylists.
     */
    distinct?: RemotePlaylistScalarFieldEnum | RemotePlaylistScalarFieldEnum[]
  }

  /**
   * RemotePlaylist findMany
   */
  export type RemotePlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
    /**
     * Filter, which RemotePlaylists to fetch.
     */
    where?: RemotePlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RemotePlaylists to fetch.
     */
    orderBy?: RemotePlaylistOrderByWithRelationInput | RemotePlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RemotePlaylists.
     */
    cursor?: RemotePlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RemotePlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RemotePlaylists.
     */
    skip?: number
    distinct?: RemotePlaylistScalarFieldEnum | RemotePlaylistScalarFieldEnum[]
  }

  /**
   * RemotePlaylist create
   */
  export type RemotePlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
    /**
     * The data needed to create a RemotePlaylist.
     */
    data: XOR<RemotePlaylistCreateInput, RemotePlaylistUncheckedCreateInput>
  }

  /**
   * RemotePlaylist createMany
   */
  export type RemotePlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RemotePlaylists.
     */
    data: RemotePlaylistCreateManyInput | RemotePlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RemotePlaylist update
   */
  export type RemotePlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
    /**
     * The data needed to update a RemotePlaylist.
     */
    data: XOR<RemotePlaylistUpdateInput, RemotePlaylistUncheckedUpdateInput>
    /**
     * Choose, which RemotePlaylist to update.
     */
    where: RemotePlaylistWhereUniqueInput
  }

  /**
   * RemotePlaylist updateMany
   */
  export type RemotePlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RemotePlaylists.
     */
    data: XOR<RemotePlaylistUpdateManyMutationInput, RemotePlaylistUncheckedUpdateManyInput>
    /**
     * Filter which RemotePlaylists to update
     */
    where?: RemotePlaylistWhereInput
    /**
     * Limit how many RemotePlaylists to update.
     */
    limit?: number
  }

  /**
   * RemotePlaylist upsert
   */
  export type RemotePlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
    /**
     * The filter to search for the RemotePlaylist to update in case it exists.
     */
    where: RemotePlaylistWhereUniqueInput
    /**
     * In case the RemotePlaylist found by the `where` argument doesn't exist, create a new RemotePlaylist with this data.
     */
    create: XOR<RemotePlaylistCreateInput, RemotePlaylistUncheckedCreateInput>
    /**
     * In case the RemotePlaylist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RemotePlaylistUpdateInput, RemotePlaylistUncheckedUpdateInput>
  }

  /**
   * RemotePlaylist delete
   */
  export type RemotePlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
    /**
     * Filter which RemotePlaylist to delete.
     */
    where: RemotePlaylistWhereUniqueInput
  }

  /**
   * RemotePlaylist deleteMany
   */
  export type RemotePlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RemotePlaylists to delete
     */
    where?: RemotePlaylistWhereInput
    /**
     * Limit how many RemotePlaylists to delete.
     */
    limit?: number
  }

  /**
   * RemotePlaylist without action
   */
  export type RemotePlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RemotePlaylist
     */
    select?: RemotePlaylistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RemotePlaylist
     */
    omit?: RemotePlaylistOmit<ExtArgs> | null
  }


  /**
   * Model ShowVideo
   */

  export type AggregateShowVideo = {
    _count: ShowVideoCountAggregateOutputType | null
    _min: ShowVideoMinAggregateOutputType | null
    _max: ShowVideoMaxAggregateOutputType | null
  }

  export type ShowVideoMinAggregateOutputType = {
    showId: string | null
    videoId: string | null
  }

  export type ShowVideoMaxAggregateOutputType = {
    showId: string | null
    videoId: string | null
  }

  export type ShowVideoCountAggregateOutputType = {
    showId: number
    videoId: number
    _all: number
  }


  export type ShowVideoMinAggregateInputType = {
    showId?: true
    videoId?: true
  }

  export type ShowVideoMaxAggregateInputType = {
    showId?: true
    videoId?: true
  }

  export type ShowVideoCountAggregateInputType = {
    showId?: true
    videoId?: true
    _all?: true
  }

  export type ShowVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShowVideo to aggregate.
     */
    where?: ShowVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowVideos to fetch.
     */
    orderBy?: ShowVideoOrderByWithRelationInput | ShowVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShowVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShowVideos
    **/
    _count?: true | ShowVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShowVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShowVideoMaxAggregateInputType
  }

  export type GetShowVideoAggregateType<T extends ShowVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateShowVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShowVideo[P]>
      : GetScalarType<T[P], AggregateShowVideo[P]>
  }




  export type ShowVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShowVideoWhereInput
    orderBy?: ShowVideoOrderByWithAggregationInput | ShowVideoOrderByWithAggregationInput[]
    by: ShowVideoScalarFieldEnum[] | ShowVideoScalarFieldEnum
    having?: ShowVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShowVideoCountAggregateInputType | true
    _min?: ShowVideoMinAggregateInputType
    _max?: ShowVideoMaxAggregateInputType
  }

  export type ShowVideoGroupByOutputType = {
    showId: string
    videoId: string
    _count: ShowVideoCountAggregateOutputType | null
    _min: ShowVideoMinAggregateOutputType | null
    _max: ShowVideoMaxAggregateOutputType | null
  }

  type GetShowVideoGroupByPayload<T extends ShowVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShowVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShowVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShowVideoGroupByOutputType[P]>
            : GetScalarType<T[P], ShowVideoGroupByOutputType[P]>
        }
      >
    >


  export type ShowVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    showId?: boolean
    videoId?: boolean
    show?: boolean | ShowDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["showVideo"]>



  export type ShowVideoSelectScalar = {
    showId?: boolean
    videoId?: boolean
  }

  export type ShowVideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"showId" | "videoId", ExtArgs["result"]["showVideo"]>
  export type ShowVideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    show?: boolean | ShowDefaultArgs<ExtArgs>
    video?: boolean | VideoDefaultArgs<ExtArgs>
  }

  export type $ShowVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShowVideo"
    objects: {
      show: Prisma.$ShowPayload<ExtArgs>
      video: Prisma.$VideoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      showId: string
      videoId: string
    }, ExtArgs["result"]["showVideo"]>
    composites: {}
  }

  type ShowVideoGetPayload<S extends boolean | null | undefined | ShowVideoDefaultArgs> = $Result.GetResult<Prisma.$ShowVideoPayload, S>

  type ShowVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShowVideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShowVideoCountAggregateInputType | true
    }

  export interface ShowVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShowVideo'], meta: { name: 'ShowVideo' } }
    /**
     * Find zero or one ShowVideo that matches the filter.
     * @param {ShowVideoFindUniqueArgs} args - Arguments to find a ShowVideo
     * @example
     * // Get one ShowVideo
     * const showVideo = await prisma.showVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShowVideoFindUniqueArgs>(args: SelectSubset<T, ShowVideoFindUniqueArgs<ExtArgs>>): Prisma__ShowVideoClient<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShowVideo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShowVideoFindUniqueOrThrowArgs} args - Arguments to find a ShowVideo
     * @example
     * // Get one ShowVideo
     * const showVideo = await prisma.showVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShowVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, ShowVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShowVideoClient<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShowVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowVideoFindFirstArgs} args - Arguments to find a ShowVideo
     * @example
     * // Get one ShowVideo
     * const showVideo = await prisma.showVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShowVideoFindFirstArgs>(args?: SelectSubset<T, ShowVideoFindFirstArgs<ExtArgs>>): Prisma__ShowVideoClient<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShowVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowVideoFindFirstOrThrowArgs} args - Arguments to find a ShowVideo
     * @example
     * // Get one ShowVideo
     * const showVideo = await prisma.showVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShowVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, ShowVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShowVideoClient<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShowVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShowVideos
     * const showVideos = await prisma.showVideo.findMany()
     * 
     * // Get first 10 ShowVideos
     * const showVideos = await prisma.showVideo.findMany({ take: 10 })
     * 
     * // Only select the `showId`
     * const showVideoWithShowIdOnly = await prisma.showVideo.findMany({ select: { showId: true } })
     * 
     */
    findMany<T extends ShowVideoFindManyArgs>(args?: SelectSubset<T, ShowVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShowVideo.
     * @param {ShowVideoCreateArgs} args - Arguments to create a ShowVideo.
     * @example
     * // Create one ShowVideo
     * const ShowVideo = await prisma.showVideo.create({
     *   data: {
     *     // ... data to create a ShowVideo
     *   }
     * })
     * 
     */
    create<T extends ShowVideoCreateArgs>(args: SelectSubset<T, ShowVideoCreateArgs<ExtArgs>>): Prisma__ShowVideoClient<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShowVideos.
     * @param {ShowVideoCreateManyArgs} args - Arguments to create many ShowVideos.
     * @example
     * // Create many ShowVideos
     * const showVideo = await prisma.showVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShowVideoCreateManyArgs>(args?: SelectSubset<T, ShowVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShowVideo.
     * @param {ShowVideoDeleteArgs} args - Arguments to delete one ShowVideo.
     * @example
     * // Delete one ShowVideo
     * const ShowVideo = await prisma.showVideo.delete({
     *   where: {
     *     // ... filter to delete one ShowVideo
     *   }
     * })
     * 
     */
    delete<T extends ShowVideoDeleteArgs>(args: SelectSubset<T, ShowVideoDeleteArgs<ExtArgs>>): Prisma__ShowVideoClient<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShowVideo.
     * @param {ShowVideoUpdateArgs} args - Arguments to update one ShowVideo.
     * @example
     * // Update one ShowVideo
     * const showVideo = await prisma.showVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShowVideoUpdateArgs>(args: SelectSubset<T, ShowVideoUpdateArgs<ExtArgs>>): Prisma__ShowVideoClient<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShowVideos.
     * @param {ShowVideoDeleteManyArgs} args - Arguments to filter ShowVideos to delete.
     * @example
     * // Delete a few ShowVideos
     * const { count } = await prisma.showVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShowVideoDeleteManyArgs>(args?: SelectSubset<T, ShowVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShowVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShowVideos
     * const showVideo = await prisma.showVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShowVideoUpdateManyArgs>(args: SelectSubset<T, ShowVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShowVideo.
     * @param {ShowVideoUpsertArgs} args - Arguments to update or create a ShowVideo.
     * @example
     * // Update or create a ShowVideo
     * const showVideo = await prisma.showVideo.upsert({
     *   create: {
     *     // ... data to create a ShowVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShowVideo we want to update
     *   }
     * })
     */
    upsert<T extends ShowVideoUpsertArgs>(args: SelectSubset<T, ShowVideoUpsertArgs<ExtArgs>>): Prisma__ShowVideoClient<$Result.GetResult<Prisma.$ShowVideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShowVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowVideoCountArgs} args - Arguments to filter ShowVideos to count.
     * @example
     * // Count the number of ShowVideos
     * const count = await prisma.showVideo.count({
     *   where: {
     *     // ... the filter for the ShowVideos we want to count
     *   }
     * })
    **/
    count<T extends ShowVideoCountArgs>(
      args?: Subset<T, ShowVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShowVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShowVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShowVideoAggregateArgs>(args: Subset<T, ShowVideoAggregateArgs>): Prisma.PrismaPromise<GetShowVideoAggregateType<T>>

    /**
     * Group by ShowVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShowVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShowVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShowVideoGroupByArgs['orderBy'] }
        : { orderBy?: ShowVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShowVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShowVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShowVideo model
   */
  readonly fields: ShowVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShowVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShowVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    show<T extends ShowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShowDefaultArgs<ExtArgs>>): Prisma__ShowClient<$Result.GetResult<Prisma.$ShowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    video<T extends VideoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoDefaultArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShowVideo model
   */
  interface ShowVideoFieldRefs {
    readonly showId: FieldRef<"ShowVideo", 'String'>
    readonly videoId: FieldRef<"ShowVideo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ShowVideo findUnique
   */
  export type ShowVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    /**
     * Filter, which ShowVideo to fetch.
     */
    where: ShowVideoWhereUniqueInput
  }

  /**
   * ShowVideo findUniqueOrThrow
   */
  export type ShowVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    /**
     * Filter, which ShowVideo to fetch.
     */
    where: ShowVideoWhereUniqueInput
  }

  /**
   * ShowVideo findFirst
   */
  export type ShowVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    /**
     * Filter, which ShowVideo to fetch.
     */
    where?: ShowVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowVideos to fetch.
     */
    orderBy?: ShowVideoOrderByWithRelationInput | ShowVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShowVideos.
     */
    cursor?: ShowVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShowVideos.
     */
    distinct?: ShowVideoScalarFieldEnum | ShowVideoScalarFieldEnum[]
  }

  /**
   * ShowVideo findFirstOrThrow
   */
  export type ShowVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    /**
     * Filter, which ShowVideo to fetch.
     */
    where?: ShowVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowVideos to fetch.
     */
    orderBy?: ShowVideoOrderByWithRelationInput | ShowVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShowVideos.
     */
    cursor?: ShowVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShowVideos.
     */
    distinct?: ShowVideoScalarFieldEnum | ShowVideoScalarFieldEnum[]
  }

  /**
   * ShowVideo findMany
   */
  export type ShowVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    /**
     * Filter, which ShowVideos to fetch.
     */
    where?: ShowVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShowVideos to fetch.
     */
    orderBy?: ShowVideoOrderByWithRelationInput | ShowVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShowVideos.
     */
    cursor?: ShowVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShowVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShowVideos.
     */
    skip?: number
    distinct?: ShowVideoScalarFieldEnum | ShowVideoScalarFieldEnum[]
  }

  /**
   * ShowVideo create
   */
  export type ShowVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a ShowVideo.
     */
    data: XOR<ShowVideoCreateInput, ShowVideoUncheckedCreateInput>
  }

  /**
   * ShowVideo createMany
   */
  export type ShowVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShowVideos.
     */
    data: ShowVideoCreateManyInput | ShowVideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShowVideo update
   */
  export type ShowVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a ShowVideo.
     */
    data: XOR<ShowVideoUpdateInput, ShowVideoUncheckedUpdateInput>
    /**
     * Choose, which ShowVideo to update.
     */
    where: ShowVideoWhereUniqueInput
  }

  /**
   * ShowVideo updateMany
   */
  export type ShowVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShowVideos.
     */
    data: XOR<ShowVideoUpdateManyMutationInput, ShowVideoUncheckedUpdateManyInput>
    /**
     * Filter which ShowVideos to update
     */
    where?: ShowVideoWhereInput
    /**
     * Limit how many ShowVideos to update.
     */
    limit?: number
  }

  /**
   * ShowVideo upsert
   */
  export type ShowVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the ShowVideo to update in case it exists.
     */
    where: ShowVideoWhereUniqueInput
    /**
     * In case the ShowVideo found by the `where` argument doesn't exist, create a new ShowVideo with this data.
     */
    create: XOR<ShowVideoCreateInput, ShowVideoUncheckedCreateInput>
    /**
     * In case the ShowVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShowVideoUpdateInput, ShowVideoUncheckedUpdateInput>
  }

  /**
   * ShowVideo delete
   */
  export type ShowVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
    /**
     * Filter which ShowVideo to delete.
     */
    where: ShowVideoWhereUniqueInput
  }

  /**
   * ShowVideo deleteMany
   */
  export type ShowVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShowVideos to delete
     */
    where?: ShowVideoWhereInput
    /**
     * Limit how many ShowVideos to delete.
     */
    limit?: number
  }

  /**
   * ShowVideo without action
   */
  export type ShowVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShowVideo
     */
    select?: ShowVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShowVideo
     */
    omit?: ShowVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShowVideoInclude<ExtArgs> | null
  }


  /**
   * Model UserSubmission
   */

  export type AggregateUserSubmission = {
    _count: UserSubmissionCountAggregateOutputType | null
    _min: UserSubmissionMinAggregateOutputType | null
    _max: UserSubmissionMaxAggregateOutputType | null
  }

  export type UserSubmissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    body: string | null
    created_at: Date | null
    updated_at: Date | null
    audio_url: string | null
    status: $Enums.UserSubmissionStatus | null
    submission_type: $Enums.UserSubmissionType | null
  }

  export type UserSubmissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    body: string | null
    created_at: Date | null
    updated_at: Date | null
    audio_url: string | null
    status: $Enums.UserSubmissionStatus | null
    submission_type: $Enums.UserSubmissionType | null
  }

  export type UserSubmissionCountAggregateOutputType = {
    id: number
    name: number
    email: number
    body: number
    created_at: number
    updated_at: number
    audio_url: number
    status: number
    submission_type: number
    _all: number
  }


  export type UserSubmissionMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    body?: true
    created_at?: true
    updated_at?: true
    audio_url?: true
    status?: true
    submission_type?: true
  }

  export type UserSubmissionMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    body?: true
    created_at?: true
    updated_at?: true
    audio_url?: true
    status?: true
    submission_type?: true
  }

  export type UserSubmissionCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    body?: true
    created_at?: true
    updated_at?: true
    audio_url?: true
    status?: true
    submission_type?: true
    _all?: true
  }

  export type UserSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubmission to aggregate.
     */
    where?: UserSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubmissions to fetch.
     */
    orderBy?: UserSubmissionOrderByWithRelationInput | UserSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubmissions
    **/
    _count?: true | UserSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubmissionMaxAggregateInputType
  }

  export type GetUserSubmissionAggregateType<T extends UserSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubmission[P]>
      : GetScalarType<T[P], AggregateUserSubmission[P]>
  }




  export type UserSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubmissionWhereInput
    orderBy?: UserSubmissionOrderByWithAggregationInput | UserSubmissionOrderByWithAggregationInput[]
    by: UserSubmissionScalarFieldEnum[] | UserSubmissionScalarFieldEnum
    having?: UserSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubmissionCountAggregateInputType | true
    _min?: UserSubmissionMinAggregateInputType
    _max?: UserSubmissionMaxAggregateInputType
  }

  export type UserSubmissionGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    body: string
    created_at: Date
    updated_at: Date
    audio_url: string | null
    status: $Enums.UserSubmissionStatus
    submission_type: $Enums.UserSubmissionType
    _count: UserSubmissionCountAggregateOutputType | null
    _min: UserSubmissionMinAggregateOutputType | null
    _max: UserSubmissionMaxAggregateOutputType | null
  }

  type GetUserSubmissionGroupByPayload<T extends UserSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    body?: boolean
    created_at?: boolean
    updated_at?: boolean
    audio_url?: boolean
    status?: boolean
    submission_type?: boolean
  }, ExtArgs["result"]["userSubmission"]>



  export type UserSubmissionSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    body?: boolean
    created_at?: boolean
    updated_at?: boolean
    audio_url?: boolean
    status?: boolean
    submission_type?: boolean
  }

  export type UserSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "body" | "created_at" | "updated_at" | "audio_url" | "status" | "submission_type", ExtArgs["result"]["userSubmission"]>

  export type $UserSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubmission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      body: string
      created_at: Date
      updated_at: Date
      audio_url: string | null
      status: $Enums.UserSubmissionStatus
      submission_type: $Enums.UserSubmissionType
    }, ExtArgs["result"]["userSubmission"]>
    composites: {}
  }

  type UserSubmissionGetPayload<S extends boolean | null | undefined | UserSubmissionDefaultArgs> = $Result.GetResult<Prisma.$UserSubmissionPayload, S>

  type UserSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSubmissionCountAggregateInputType | true
    }

  export interface UserSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubmission'], meta: { name: 'UserSubmission' } }
    /**
     * Find zero or one UserSubmission that matches the filter.
     * @param {UserSubmissionFindUniqueArgs} args - Arguments to find a UserSubmission
     * @example
     * // Get one UserSubmission
     * const userSubmission = await prisma.userSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubmissionFindUniqueArgs>(args: SelectSubset<T, UserSubmissionFindUniqueArgs<ExtArgs>>): Prisma__UserSubmissionClient<$Result.GetResult<Prisma.$UserSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSubmissionFindUniqueOrThrowArgs} args - Arguments to find a UserSubmission
     * @example
     * // Get one UserSubmission
     * const userSubmission = await prisma.userSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubmissionClient<$Result.GetResult<Prisma.$UserSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubmissionFindFirstArgs} args - Arguments to find a UserSubmission
     * @example
     * // Get one UserSubmission
     * const userSubmission = await prisma.userSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubmissionFindFirstArgs>(args?: SelectSubset<T, UserSubmissionFindFirstArgs<ExtArgs>>): Prisma__UserSubmissionClient<$Result.GetResult<Prisma.$UserSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubmissionFindFirstOrThrowArgs} args - Arguments to find a UserSubmission
     * @example
     * // Get one UserSubmission
     * const userSubmission = await prisma.userSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubmissionClient<$Result.GetResult<Prisma.$UserSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubmissions
     * const userSubmissions = await prisma.userSubmission.findMany()
     * 
     * // Get first 10 UserSubmissions
     * const userSubmissions = await prisma.userSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSubmissionWithIdOnly = await prisma.userSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSubmissionFindManyArgs>(args?: SelectSubset<T, UserSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSubmission.
     * @param {UserSubmissionCreateArgs} args - Arguments to create a UserSubmission.
     * @example
     * // Create one UserSubmission
     * const UserSubmission = await prisma.userSubmission.create({
     *   data: {
     *     // ... data to create a UserSubmission
     *   }
     * })
     * 
     */
    create<T extends UserSubmissionCreateArgs>(args: SelectSubset<T, UserSubmissionCreateArgs<ExtArgs>>): Prisma__UserSubmissionClient<$Result.GetResult<Prisma.$UserSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSubmissions.
     * @param {UserSubmissionCreateManyArgs} args - Arguments to create many UserSubmissions.
     * @example
     * // Create many UserSubmissions
     * const userSubmission = await prisma.userSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubmissionCreateManyArgs>(args?: SelectSubset<T, UserSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSubmission.
     * @param {UserSubmissionDeleteArgs} args - Arguments to delete one UserSubmission.
     * @example
     * // Delete one UserSubmission
     * const UserSubmission = await prisma.userSubmission.delete({
     *   where: {
     *     // ... filter to delete one UserSubmission
     *   }
     * })
     * 
     */
    delete<T extends UserSubmissionDeleteArgs>(args: SelectSubset<T, UserSubmissionDeleteArgs<ExtArgs>>): Prisma__UserSubmissionClient<$Result.GetResult<Prisma.$UserSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSubmission.
     * @param {UserSubmissionUpdateArgs} args - Arguments to update one UserSubmission.
     * @example
     * // Update one UserSubmission
     * const userSubmission = await prisma.userSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubmissionUpdateArgs>(args: SelectSubset<T, UserSubmissionUpdateArgs<ExtArgs>>): Prisma__UserSubmissionClient<$Result.GetResult<Prisma.$UserSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSubmissions.
     * @param {UserSubmissionDeleteManyArgs} args - Arguments to filter UserSubmissions to delete.
     * @example
     * // Delete a few UserSubmissions
     * const { count } = await prisma.userSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubmissionDeleteManyArgs>(args?: SelectSubset<T, UserSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubmissions
     * const userSubmission = await prisma.userSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubmissionUpdateManyArgs>(args: SelectSubset<T, UserSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSubmission.
     * @param {UserSubmissionUpsertArgs} args - Arguments to update or create a UserSubmission.
     * @example
     * // Update or create a UserSubmission
     * const userSubmission = await prisma.userSubmission.upsert({
     *   create: {
     *     // ... data to create a UserSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubmission we want to update
     *   }
     * })
     */
    upsert<T extends UserSubmissionUpsertArgs>(args: SelectSubset<T, UserSubmissionUpsertArgs<ExtArgs>>): Prisma__UserSubmissionClient<$Result.GetResult<Prisma.$UserSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubmissionCountArgs} args - Arguments to filter UserSubmissions to count.
     * @example
     * // Count the number of UserSubmissions
     * const count = await prisma.userSubmission.count({
     *   where: {
     *     // ... the filter for the UserSubmissions we want to count
     *   }
     * })
    **/
    count<T extends UserSubmissionCountArgs>(
      args?: Subset<T, UserSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubmissionAggregateArgs>(args: Subset<T, UserSubmissionAggregateArgs>): Prisma.PrismaPromise<GetUserSubmissionAggregateType<T>>

    /**
     * Group by UserSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubmission model
   */
  readonly fields: UserSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubmission model
   */
  interface UserSubmissionFieldRefs {
    readonly id: FieldRef<"UserSubmission", 'String'>
    readonly name: FieldRef<"UserSubmission", 'String'>
    readonly email: FieldRef<"UserSubmission", 'String'>
    readonly body: FieldRef<"UserSubmission", 'String'>
    readonly created_at: FieldRef<"UserSubmission", 'DateTime'>
    readonly updated_at: FieldRef<"UserSubmission", 'DateTime'>
    readonly audio_url: FieldRef<"UserSubmission", 'String'>
    readonly status: FieldRef<"UserSubmission", 'UserSubmissionStatus'>
    readonly submission_type: FieldRef<"UserSubmission", 'UserSubmissionType'>
  }
    

  // Custom InputTypes
  /**
   * UserSubmission findUnique
   */
  export type UserSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which UserSubmission to fetch.
     */
    where: UserSubmissionWhereUniqueInput
  }

  /**
   * UserSubmission findUniqueOrThrow
   */
  export type UserSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which UserSubmission to fetch.
     */
    where: UserSubmissionWhereUniqueInput
  }

  /**
   * UserSubmission findFirst
   */
  export type UserSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which UserSubmission to fetch.
     */
    where?: UserSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubmissions to fetch.
     */
    orderBy?: UserSubmissionOrderByWithRelationInput | UserSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubmissions.
     */
    cursor?: UserSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubmissions.
     */
    distinct?: UserSubmissionScalarFieldEnum | UserSubmissionScalarFieldEnum[]
  }

  /**
   * UserSubmission findFirstOrThrow
   */
  export type UserSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which UserSubmission to fetch.
     */
    where?: UserSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubmissions to fetch.
     */
    orderBy?: UserSubmissionOrderByWithRelationInput | UserSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubmissions.
     */
    cursor?: UserSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubmissions.
     */
    distinct?: UserSubmissionScalarFieldEnum | UserSubmissionScalarFieldEnum[]
  }

  /**
   * UserSubmission findMany
   */
  export type UserSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which UserSubmissions to fetch.
     */
    where?: UserSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubmissions to fetch.
     */
    orderBy?: UserSubmissionOrderByWithRelationInput | UserSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubmissions.
     */
    cursor?: UserSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubmissions.
     */
    skip?: number
    distinct?: UserSubmissionScalarFieldEnum | UserSubmissionScalarFieldEnum[]
  }

  /**
   * UserSubmission create
   */
  export type UserSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to create a UserSubmission.
     */
    data: XOR<UserSubmissionCreateInput, UserSubmissionUncheckedCreateInput>
  }

  /**
   * UserSubmission createMany
   */
  export type UserSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubmissions.
     */
    data: UserSubmissionCreateManyInput | UserSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubmission update
   */
  export type UserSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to update a UserSubmission.
     */
    data: XOR<UserSubmissionUpdateInput, UserSubmissionUncheckedUpdateInput>
    /**
     * Choose, which UserSubmission to update.
     */
    where: UserSubmissionWhereUniqueInput
  }

  /**
   * UserSubmission updateMany
   */
  export type UserSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubmissions.
     */
    data: XOR<UserSubmissionUpdateManyMutationInput, UserSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubmissions to update
     */
    where?: UserSubmissionWhereInput
    /**
     * Limit how many UserSubmissions to update.
     */
    limit?: number
  }

  /**
   * UserSubmission upsert
   */
  export type UserSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
    /**
     * The filter to search for the UserSubmission to update in case it exists.
     */
    where: UserSubmissionWhereUniqueInput
    /**
     * In case the UserSubmission found by the `where` argument doesn't exist, create a new UserSubmission with this data.
     */
    create: XOR<UserSubmissionCreateInput, UserSubmissionUncheckedCreateInput>
    /**
     * In case the UserSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubmissionUpdateInput, UserSubmissionUncheckedUpdateInput>
  }

  /**
   * UserSubmission delete
   */
  export type UserSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
    /**
     * Filter which UserSubmission to delete.
     */
    where: UserSubmissionWhereUniqueInput
  }

  /**
   * UserSubmission deleteMany
   */
  export type UserSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubmissions to delete
     */
    where?: UserSubmissionWhereInput
    /**
     * Limit how many UserSubmissions to delete.
     */
    limit?: number
  }

  /**
   * UserSubmission without action
   */
  export type UserSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubmission
     */
    select?: UserSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubmission
     */
    omit?: UserSubmissionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    avatar_url: 'avatar_url',
    created_at: 'created_at',
    email: 'email',
    github_id: 'github_id',
    updated_at: 'updated_at',
    username: 'username',
    theme: 'theme',
    name: 'name',
    twitter: 'twitter'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    access_token: 'access_token',
    session_token: 'session_token',
    created_at: 'created_at',
    updated_at: 'updated_at',
    ip: 'ip',
    country: 'country'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ShowGuestScalarFieldEnum: {
    id: 'id',
    showId: 'showId',
    guestId: 'guestId',
    transcriptId: 'transcriptId'
  };

  export type ShowGuestScalarFieldEnum = (typeof ShowGuestScalarFieldEnum)[keyof typeof ShowGuestScalarFieldEnum]


  export const GuestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    name_slug: 'name_slug',
    twitter: 'twitter',
    github: 'github',
    of: 'of',
    url: 'url'
  };

  export type GuestScalarFieldEnum = (typeof GuestScalarFieldEnum)[keyof typeof GuestScalarFieldEnum]


  export const SocialLinkScalarFieldEnum: {
    id: 'id',
    link: 'link',
    guest_id: 'guest_id'
  };

  export type SocialLinkScalarFieldEnum = (typeof SocialLinkScalarFieldEnum)[keyof typeof SocialLinkScalarFieldEnum]


  export const ShowScalarFieldEnum: {
    id: 'id',
    number: 'number',
    title: 'title',
    date: 'date',
    url: 'url',
    youtube_url: 'youtube_url',
    spotify_id: 'spotify_id',
    show_notes: 'show_notes',
    hash: 'hash',
    slug: 'slug',
    md_file: 'md_file',
    created_at: 'created_at',
    updated_at: 'updated_at',
    show_type: 'show_type'
  };

  export type ShowScalarFieldEnum = (typeof ShowScalarFieldEnum)[keyof typeof ShowScalarFieldEnum]


  export const TranscriptScalarFieldEnum: {
    id: 'id',
    show_number: 'show_number'
  };

  export type TranscriptScalarFieldEnum = (typeof TranscriptScalarFieldEnum)[keyof typeof TranscriptScalarFieldEnum]


  export const TranscriptUtteranceScalarFieldEnum: {
    id: 'id',
    start: 'start',
    end: 'end',
    confidence: 'confidence',
    channel: 'channel',
    transcript_value: 'transcript_value',
    speaker: 'speaker',
    speakerName: 'speakerName',
    transcriptId: 'transcriptId'
  };

  export type TranscriptUtteranceScalarFieldEnum = (typeof TranscriptUtteranceScalarFieldEnum)[keyof typeof TranscriptUtteranceScalarFieldEnum]


  export const TranscriptUtteranceWordScalarFieldEnum: {
    id: 'id',
    word: 'word',
    start: 'start',
    end: 'end',
    confidence: 'confidence',
    speaker: 'speaker',
    speaker_confidence: 'speaker_confidence',
    punctuated_word: 'punctuated_word',
    transcriptUtteranceId: 'transcriptUtteranceId'
  };

  export type TranscriptUtteranceWordScalarFieldEnum = (typeof TranscriptUtteranceWordScalarFieldEnum)[keyof typeof TranscriptUtteranceWordScalarFieldEnum]


  export const AiShowNoteScalarFieldEnum: {
    id: 'id',
    show_number: 'show_number',
    title: 'title',
    description: 'description',
    provider: 'provider'
  };

  export type AiShowNoteScalarFieldEnum = (typeof AiShowNoteScalarFieldEnum)[keyof typeof AiShowNoteScalarFieldEnum]


  export const AiSummaryEntryScalarFieldEnum: {
    id: 'id',
    time: 'time',
    text: 'text',
    description: 'description',
    showNote: 'showNote'
  };

  export type AiSummaryEntryScalarFieldEnum = (typeof AiSummaryEntryScalarFieldEnum)[keyof typeof AiSummaryEntryScalarFieldEnum]


  export const AiTweetScalarFieldEnum: {
    id: 'id',
    content: 'content',
    showNote: 'showNote'
  };

  export type AiTweetScalarFieldEnum = (typeof AiTweetScalarFieldEnum)[keyof typeof AiTweetScalarFieldEnum]


  export const LinkScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    timestamp: 'timestamp',
    showNote: 'showNote'
  };

  export type LinkScalarFieldEnum = (typeof LinkScalarFieldEnum)[keyof typeof LinkScalarFieldEnum]


  export const AiGuestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    showNote: 'showNote'
  };

  export type AiGuestScalarFieldEnum = (typeof AiGuestScalarFieldEnum)[keyof typeof AiGuestScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    showNote: 'showNote'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    url: 'url',
    published_at: 'published_at',
    thumbnail: 'thumbnail',
    slug: 'slug'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const PlaylistScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    created_at: 'created_at',
    slug: 'slug',
    unlisted: 'unlisted'
  };

  export type PlaylistScalarFieldEnum = (typeof PlaylistScalarFieldEnum)[keyof typeof PlaylistScalarFieldEnum]


  export const PlaylistOnVideoScalarFieldEnum: {
    video_id: 'video_id',
    playlist_id: 'playlist_id',
    order: 'order'
  };

  export type PlaylistOnVideoScalarFieldEnum = (typeof PlaylistOnVideoScalarFieldEnum)[keyof typeof PlaylistOnVideoScalarFieldEnum]


  export const RemotePlaylistScalarFieldEnum: {
    playlist_id: 'playlist_id',
    title: 'title',
    videos_count: 'videos_count',
    created_at: 'created_at'
  };

  export type RemotePlaylistScalarFieldEnum = (typeof RemotePlaylistScalarFieldEnum)[keyof typeof RemotePlaylistScalarFieldEnum]


  export const ShowVideoScalarFieldEnum: {
    showId: 'showId',
    videoId: 'videoId'
  };

  export type ShowVideoScalarFieldEnum = (typeof ShowVideoScalarFieldEnum)[keyof typeof ShowVideoScalarFieldEnum]


  export const UserSubmissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    body: 'body',
    created_at: 'created_at',
    updated_at: 'updated_at',
    audio_url: 'audio_url',
    status: 'status',
    submission_type: 'submission_type'
  };

  export type UserSubmissionScalarFieldEnum = (typeof UserSubmissionScalarFieldEnum)[keyof typeof UserSubmissionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    avatar_url: 'avatar_url',
    email: 'email',
    username: 'username',
    theme: 'theme',
    name: 'name',
    twitter: 'twitter'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RoleOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  export const UserRoleOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleOrderByRelevanceFieldEnum = (typeof UserRoleOrderByRelevanceFieldEnum)[keyof typeof UserRoleOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    user_id: 'user_id',
    access_token: 'access_token',
    session_token: 'session_token',
    ip: 'ip',
    country: 'country'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const ShowGuestOrderByRelevanceFieldEnum: {
    id: 'id',
    showId: 'showId',
    guestId: 'guestId',
    transcriptId: 'transcriptId'
  };

  export type ShowGuestOrderByRelevanceFieldEnum = (typeof ShowGuestOrderByRelevanceFieldEnum)[keyof typeof ShowGuestOrderByRelevanceFieldEnum]


  export const GuestOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    name_slug: 'name_slug',
    twitter: 'twitter',
    github: 'github',
    of: 'of',
    url: 'url'
  };

  export type GuestOrderByRelevanceFieldEnum = (typeof GuestOrderByRelevanceFieldEnum)[keyof typeof GuestOrderByRelevanceFieldEnum]


  export const SocialLinkOrderByRelevanceFieldEnum: {
    id: 'id',
    link: 'link',
    guest_id: 'guest_id'
  };

  export type SocialLinkOrderByRelevanceFieldEnum = (typeof SocialLinkOrderByRelevanceFieldEnum)[keyof typeof SocialLinkOrderByRelevanceFieldEnum]


  export const ShowOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    url: 'url',
    youtube_url: 'youtube_url',
    spotify_id: 'spotify_id',
    show_notes: 'show_notes',
    hash: 'hash',
    slug: 'slug',
    md_file: 'md_file'
  };

  export type ShowOrderByRelevanceFieldEnum = (typeof ShowOrderByRelevanceFieldEnum)[keyof typeof ShowOrderByRelevanceFieldEnum]


  export const TranscriptOrderByRelevanceFieldEnum: {
    id: 'id'
  };

  export type TranscriptOrderByRelevanceFieldEnum = (typeof TranscriptOrderByRelevanceFieldEnum)[keyof typeof TranscriptOrderByRelevanceFieldEnum]


  export const TranscriptUtteranceOrderByRelevanceFieldEnum: {
    id: 'id',
    transcript_value: 'transcript_value',
    speakerName: 'speakerName',
    transcriptId: 'transcriptId'
  };

  export type TranscriptUtteranceOrderByRelevanceFieldEnum = (typeof TranscriptUtteranceOrderByRelevanceFieldEnum)[keyof typeof TranscriptUtteranceOrderByRelevanceFieldEnum]


  export const TranscriptUtteranceWordOrderByRelevanceFieldEnum: {
    id: 'id',
    word: 'word',
    punctuated_word: 'punctuated_word',
    transcriptUtteranceId: 'transcriptUtteranceId'
  };

  export type TranscriptUtteranceWordOrderByRelevanceFieldEnum = (typeof TranscriptUtteranceWordOrderByRelevanceFieldEnum)[keyof typeof TranscriptUtteranceWordOrderByRelevanceFieldEnum]


  export const AiShowNoteOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    provider: 'provider'
  };

  export type AiShowNoteOrderByRelevanceFieldEnum = (typeof AiShowNoteOrderByRelevanceFieldEnum)[keyof typeof AiShowNoteOrderByRelevanceFieldEnum]


  export const AiSummaryEntryOrderByRelevanceFieldEnum: {
    time: 'time',
    text: 'text',
    description: 'description'
  };

  export type AiSummaryEntryOrderByRelevanceFieldEnum = (typeof AiSummaryEntryOrderByRelevanceFieldEnum)[keyof typeof AiSummaryEntryOrderByRelevanceFieldEnum]


  export const AiTweetOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type AiTweetOrderByRelevanceFieldEnum = (typeof AiTweetOrderByRelevanceFieldEnum)[keyof typeof AiTweetOrderByRelevanceFieldEnum]


  export const LinkOrderByRelevanceFieldEnum: {
    name: 'name',
    url: 'url',
    timestamp: 'timestamp'
  };

  export type LinkOrderByRelevanceFieldEnum = (typeof LinkOrderByRelevanceFieldEnum)[keyof typeof LinkOrderByRelevanceFieldEnum]


  export const AiGuestOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type AiGuestOrderByRelevanceFieldEnum = (typeof AiGuestOrderByRelevanceFieldEnum)[keyof typeof AiGuestOrderByRelevanceFieldEnum]


  export const TopicOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type TopicOrderByRelevanceFieldEnum = (typeof TopicOrderByRelevanceFieldEnum)[keyof typeof TopicOrderByRelevanceFieldEnum]


  export const VideoOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    url: 'url',
    thumbnail: 'thumbnail',
    slug: 'slug'
  };

  export type VideoOrderByRelevanceFieldEnum = (typeof VideoOrderByRelevanceFieldEnum)[keyof typeof VideoOrderByRelevanceFieldEnum]


  export const PlaylistOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    slug: 'slug'
  };

  export type PlaylistOrderByRelevanceFieldEnum = (typeof PlaylistOrderByRelevanceFieldEnum)[keyof typeof PlaylistOrderByRelevanceFieldEnum]


  export const PlaylistOnVideoOrderByRelevanceFieldEnum: {
    video_id: 'video_id',
    playlist_id: 'playlist_id'
  };

  export type PlaylistOnVideoOrderByRelevanceFieldEnum = (typeof PlaylistOnVideoOrderByRelevanceFieldEnum)[keyof typeof PlaylistOnVideoOrderByRelevanceFieldEnum]


  export const RemotePlaylistOrderByRelevanceFieldEnum: {
    playlist_id: 'playlist_id',
    title: 'title'
  };

  export type RemotePlaylistOrderByRelevanceFieldEnum = (typeof RemotePlaylistOrderByRelevanceFieldEnum)[keyof typeof RemotePlaylistOrderByRelevanceFieldEnum]


  export const ShowVideoOrderByRelevanceFieldEnum: {
    showId: 'showId',
    videoId: 'videoId'
  };

  export type ShowVideoOrderByRelevanceFieldEnum = (typeof ShowVideoOrderByRelevanceFieldEnum)[keyof typeof ShowVideoOrderByRelevanceFieldEnum]


  export const UserSubmissionOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    body: 'body',
    audio_url: 'audio_url'
  };

  export type UserSubmissionOrderByRelevanceFieldEnum = (typeof UserSubmissionOrderByRelevanceFieldEnum)[keyof typeof UserSubmissionOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'ShowType'
   */
  export type EnumShowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShowType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserSubmissionStatus'
   */
  export type EnumUserSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserSubmissionStatus'>
    


  /**
   * Reference to a field of type 'UserSubmissionType'
   */
  export type EnumUserSubmissionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserSubmissionType'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    avatar_url?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    email?: StringNullableFilter<"User"> | string | null
    github_id?: IntFilter<"User"> | number
    updated_at?: DateTimeFilter<"User"> | Date | string
    username?: StringNullableFilter<"User"> | string | null
    theme?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    twitter?: StringNullableFilter<"User"> | string | null
    session?: SessionListRelationFilter
    roles?: UserRoleListRelationFilter
    hostedShows?: ShowListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    email?: SortOrderInput | SortOrder
    github_id?: SortOrder
    updated_at?: SortOrder
    username?: SortOrderInput | SortOrder
    theme?: SortOrder
    name?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    session?: SessionOrderByRelationAggregateInput
    roles?: UserRoleOrderByRelationAggregateInput
    hostedShows?: ShowOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    github_id?: number
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    avatar_url?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    username?: StringNullableFilter<"User"> | string | null
    theme?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    twitter?: StringNullableFilter<"User"> | string | null
    session?: SessionListRelationFilter
    roles?: UserRoleListRelationFilter
    hostedShows?: ShowListRelationFilter
  }, "id" | "email" | "github_id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    email?: SortOrderInput | SortOrder
    github_id?: SortOrder
    updated_at?: SortOrder
    username?: SortOrderInput | SortOrder
    theme?: SortOrder
    name?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    avatar_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    github_id?: IntWithAggregatesFilter<"User"> | number
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    theme?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    userRoles?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    userRoles?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    _relevance?: UserRoleOrderByRelevanceInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    user_id?: StringNullableFilter<"Session"> | string | null
    access_token?: StringNullableFilter<"Session"> | string | null
    session_token?: StringFilter<"Session"> | string
    created_at?: DateTimeFilter<"Session"> | Date | string
    updated_at?: DateTimeFilter<"Session"> | Date | string
    ip?: StringNullableFilter<"Session"> | string | null
    country?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    session_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    access_token?: string
    session_token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    user_id?: StringNullableFilter<"Session"> | string | null
    created_at?: DateTimeFilter<"Session"> | Date | string
    updated_at?: DateTimeFilter<"Session"> | Date | string
    ip?: StringNullableFilter<"Session"> | string | null
    country?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "access_token" | "session_token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    session_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    user_id?: StringNullableWithAggregatesFilter<"Session"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Session"> | string | null
    session_token?: StringWithAggregatesFilter<"Session"> | string
    created_at?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ip?: StringNullableWithAggregatesFilter<"Session"> | string | null
    country?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type ShowGuestWhereInput = {
    AND?: ShowGuestWhereInput | ShowGuestWhereInput[]
    OR?: ShowGuestWhereInput[]
    NOT?: ShowGuestWhereInput | ShowGuestWhereInput[]
    id?: StringFilter<"ShowGuest"> | string
    showId?: StringFilter<"ShowGuest"> | string
    guestId?: StringFilter<"ShowGuest"> | string
    transcriptId?: StringNullableFilter<"ShowGuest"> | string | null
    Show?: XOR<ShowScalarRelationFilter, ShowWhereInput>
    Guest?: XOR<GuestScalarRelationFilter, GuestWhereInput>
    Transcript?: XOR<TranscriptNullableScalarRelationFilter, TranscriptWhereInput> | null
  }

  export type ShowGuestOrderByWithRelationInput = {
    id?: SortOrder
    showId?: SortOrder
    guestId?: SortOrder
    transcriptId?: SortOrderInput | SortOrder
    Show?: ShowOrderByWithRelationInput
    Guest?: GuestOrderByWithRelationInput
    Transcript?: TranscriptOrderByWithRelationInput
    _relevance?: ShowGuestOrderByRelevanceInput
  }

  export type ShowGuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    showId_guestId?: ShowGuestShowIdGuestIdCompoundUniqueInput
    AND?: ShowGuestWhereInput | ShowGuestWhereInput[]
    OR?: ShowGuestWhereInput[]
    NOT?: ShowGuestWhereInput | ShowGuestWhereInput[]
    showId?: StringFilter<"ShowGuest"> | string
    guestId?: StringFilter<"ShowGuest"> | string
    transcriptId?: StringNullableFilter<"ShowGuest"> | string | null
    Show?: XOR<ShowScalarRelationFilter, ShowWhereInput>
    Guest?: XOR<GuestScalarRelationFilter, GuestWhereInput>
    Transcript?: XOR<TranscriptNullableScalarRelationFilter, TranscriptWhereInput> | null
  }, "id" | "showId_guestId">

  export type ShowGuestOrderByWithAggregationInput = {
    id?: SortOrder
    showId?: SortOrder
    guestId?: SortOrder
    transcriptId?: SortOrderInput | SortOrder
    _count?: ShowGuestCountOrderByAggregateInput
    _max?: ShowGuestMaxOrderByAggregateInput
    _min?: ShowGuestMinOrderByAggregateInput
  }

  export type ShowGuestScalarWhereWithAggregatesInput = {
    AND?: ShowGuestScalarWhereWithAggregatesInput | ShowGuestScalarWhereWithAggregatesInput[]
    OR?: ShowGuestScalarWhereWithAggregatesInput[]
    NOT?: ShowGuestScalarWhereWithAggregatesInput | ShowGuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShowGuest"> | string
    showId?: StringWithAggregatesFilter<"ShowGuest"> | string
    guestId?: StringWithAggregatesFilter<"ShowGuest"> | string
    transcriptId?: StringNullableWithAggregatesFilter<"ShowGuest"> | string | null
  }

  export type GuestWhereInput = {
    AND?: GuestWhereInput | GuestWhereInput[]
    OR?: GuestWhereInput[]
    NOT?: GuestWhereInput | GuestWhereInput[]
    id?: StringFilter<"Guest"> | string
    name?: StringFilter<"Guest"> | string
    name_slug?: StringFilter<"Guest"> | string
    twitter?: StringNullableFilter<"Guest"> | string | null
    github?: StringNullableFilter<"Guest"> | string | null
    of?: StringNullableFilter<"Guest"> | string | null
    url?: StringNullableFilter<"Guest"> | string | null
    social?: SocialLinkListRelationFilter
    shows?: ShowGuestListRelationFilter
  }

  export type GuestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    name_slug?: SortOrder
    twitter?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    of?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    social?: SocialLinkOrderByRelationAggregateInput
    shows?: ShowGuestOrderByRelationAggregateInput
    _relevance?: GuestOrderByRelevanceInput
  }

  export type GuestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_slug?: string
    twitter?: string
    github?: string
    AND?: GuestWhereInput | GuestWhereInput[]
    OR?: GuestWhereInput[]
    NOT?: GuestWhereInput | GuestWhereInput[]
    name?: StringFilter<"Guest"> | string
    of?: StringNullableFilter<"Guest"> | string | null
    url?: StringNullableFilter<"Guest"> | string | null
    social?: SocialLinkListRelationFilter
    shows?: ShowGuestListRelationFilter
  }, "id" | "name_slug" | "twitter" | "github">

  export type GuestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    name_slug?: SortOrder
    twitter?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    of?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    _count?: GuestCountOrderByAggregateInput
    _max?: GuestMaxOrderByAggregateInput
    _min?: GuestMinOrderByAggregateInput
  }

  export type GuestScalarWhereWithAggregatesInput = {
    AND?: GuestScalarWhereWithAggregatesInput | GuestScalarWhereWithAggregatesInput[]
    OR?: GuestScalarWhereWithAggregatesInput[]
    NOT?: GuestScalarWhereWithAggregatesInput | GuestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guest"> | string
    name?: StringWithAggregatesFilter<"Guest"> | string
    name_slug?: StringWithAggregatesFilter<"Guest"> | string
    twitter?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    github?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    of?: StringNullableWithAggregatesFilter<"Guest"> | string | null
    url?: StringNullableWithAggregatesFilter<"Guest"> | string | null
  }

  export type SocialLinkWhereInput = {
    AND?: SocialLinkWhereInput | SocialLinkWhereInput[]
    OR?: SocialLinkWhereInput[]
    NOT?: SocialLinkWhereInput | SocialLinkWhereInput[]
    id?: StringFilter<"SocialLink"> | string
    link?: StringFilter<"SocialLink"> | string
    guest_id?: StringFilter<"SocialLink"> | string
    guest?: XOR<GuestScalarRelationFilter, GuestWhereInput>
  }

  export type SocialLinkOrderByWithRelationInput = {
    id?: SortOrder
    link?: SortOrder
    guest_id?: SortOrder
    guest?: GuestOrderByWithRelationInput
    _relevance?: SocialLinkOrderByRelevanceInput
  }

  export type SocialLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    link_guest_id?: SocialLinkLinkGuest_idCompoundUniqueInput
    AND?: SocialLinkWhereInput | SocialLinkWhereInput[]
    OR?: SocialLinkWhereInput[]
    NOT?: SocialLinkWhereInput | SocialLinkWhereInput[]
    link?: StringFilter<"SocialLink"> | string
    guest_id?: StringFilter<"SocialLink"> | string
    guest?: XOR<GuestScalarRelationFilter, GuestWhereInput>
  }, "id" | "link_guest_id">

  export type SocialLinkOrderByWithAggregationInput = {
    id?: SortOrder
    link?: SortOrder
    guest_id?: SortOrder
    _count?: SocialLinkCountOrderByAggregateInput
    _max?: SocialLinkMaxOrderByAggregateInput
    _min?: SocialLinkMinOrderByAggregateInput
  }

  export type SocialLinkScalarWhereWithAggregatesInput = {
    AND?: SocialLinkScalarWhereWithAggregatesInput | SocialLinkScalarWhereWithAggregatesInput[]
    OR?: SocialLinkScalarWhereWithAggregatesInput[]
    NOT?: SocialLinkScalarWhereWithAggregatesInput | SocialLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialLink"> | string
    link?: StringWithAggregatesFilter<"SocialLink"> | string
    guest_id?: StringWithAggregatesFilter<"SocialLink"> | string
  }

  export type ShowWhereInput = {
    AND?: ShowWhereInput | ShowWhereInput[]
    OR?: ShowWhereInput[]
    NOT?: ShowWhereInput | ShowWhereInput[]
    id?: StringFilter<"Show"> | string
    number?: IntFilter<"Show"> | number
    title?: StringFilter<"Show"> | string
    date?: DateTimeFilter<"Show"> | Date | string
    url?: StringFilter<"Show"> | string
    youtube_url?: StringNullableFilter<"Show"> | string | null
    spotify_id?: StringNullableFilter<"Show"> | string | null
    show_notes?: StringFilter<"Show"> | string
    hash?: StringFilter<"Show"> | string
    slug?: StringFilter<"Show"> | string
    md_file?: StringFilter<"Show"> | string
    created_at?: DateTimeFilter<"Show"> | Date | string
    updated_at?: DateTimeFilter<"Show"> | Date | string
    show_type?: EnumShowTypeFilter<"Show"> | $Enums.ShowType
    guests?: ShowGuestListRelationFilter
    transcript?: XOR<TranscriptNullableScalarRelationFilter, TranscriptWhereInput> | null
    aiShowNote?: XOR<AiShowNoteNullableScalarRelationFilter, AiShowNoteWhereInput> | null
    videos?: ShowVideoListRelationFilter
    hosts?: UserListRelationFilter
  }

  export type ShowOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    url?: SortOrder
    youtube_url?: SortOrderInput | SortOrder
    spotify_id?: SortOrderInput | SortOrder
    show_notes?: SortOrder
    hash?: SortOrder
    slug?: SortOrder
    md_file?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    show_type?: SortOrder
    guests?: ShowGuestOrderByRelationAggregateInput
    transcript?: TranscriptOrderByWithRelationInput
    aiShowNote?: AiShowNoteOrderByWithRelationInput
    videos?: ShowVideoOrderByRelationAggregateInput
    hosts?: UserOrderByRelationAggregateInput
    _relevance?: ShowOrderByRelevanceInput
  }

  export type ShowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: number
    hash?: string
    md_file?: string
    AND?: ShowWhereInput | ShowWhereInput[]
    OR?: ShowWhereInput[]
    NOT?: ShowWhereInput | ShowWhereInput[]
    title?: StringFilter<"Show"> | string
    date?: DateTimeFilter<"Show"> | Date | string
    url?: StringFilter<"Show"> | string
    youtube_url?: StringNullableFilter<"Show"> | string | null
    spotify_id?: StringNullableFilter<"Show"> | string | null
    show_notes?: StringFilter<"Show"> | string
    slug?: StringFilter<"Show"> | string
    created_at?: DateTimeFilter<"Show"> | Date | string
    updated_at?: DateTimeFilter<"Show"> | Date | string
    show_type?: EnumShowTypeFilter<"Show"> | $Enums.ShowType
    guests?: ShowGuestListRelationFilter
    transcript?: XOR<TranscriptNullableScalarRelationFilter, TranscriptWhereInput> | null
    aiShowNote?: XOR<AiShowNoteNullableScalarRelationFilter, AiShowNoteWhereInput> | null
    videos?: ShowVideoListRelationFilter
    hosts?: UserListRelationFilter
  }, "id" | "number" | "hash" | "md_file">

  export type ShowOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    url?: SortOrder
    youtube_url?: SortOrderInput | SortOrder
    spotify_id?: SortOrderInput | SortOrder
    show_notes?: SortOrder
    hash?: SortOrder
    slug?: SortOrder
    md_file?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    show_type?: SortOrder
    _count?: ShowCountOrderByAggregateInput
    _avg?: ShowAvgOrderByAggregateInput
    _max?: ShowMaxOrderByAggregateInput
    _min?: ShowMinOrderByAggregateInput
    _sum?: ShowSumOrderByAggregateInput
  }

  export type ShowScalarWhereWithAggregatesInput = {
    AND?: ShowScalarWhereWithAggregatesInput | ShowScalarWhereWithAggregatesInput[]
    OR?: ShowScalarWhereWithAggregatesInput[]
    NOT?: ShowScalarWhereWithAggregatesInput | ShowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Show"> | string
    number?: IntWithAggregatesFilter<"Show"> | number
    title?: StringWithAggregatesFilter<"Show"> | string
    date?: DateTimeWithAggregatesFilter<"Show"> | Date | string
    url?: StringWithAggregatesFilter<"Show"> | string
    youtube_url?: StringNullableWithAggregatesFilter<"Show"> | string | null
    spotify_id?: StringNullableWithAggregatesFilter<"Show"> | string | null
    show_notes?: StringWithAggregatesFilter<"Show"> | string
    hash?: StringWithAggregatesFilter<"Show"> | string
    slug?: StringWithAggregatesFilter<"Show"> | string
    md_file?: StringWithAggregatesFilter<"Show"> | string
    created_at?: DateTimeWithAggregatesFilter<"Show"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Show"> | Date | string
    show_type?: EnumShowTypeWithAggregatesFilter<"Show"> | $Enums.ShowType
  }

  export type TranscriptWhereInput = {
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    id?: StringFilter<"Transcript"> | string
    show_number?: IntFilter<"Transcript"> | number
    show?: XOR<ShowScalarRelationFilter, ShowWhereInput>
    utterances?: TranscriptUtteranceListRelationFilter
    ShowGuest?: ShowGuestListRelationFilter
  }

  export type TranscriptOrderByWithRelationInput = {
    id?: SortOrder
    show_number?: SortOrder
    show?: ShowOrderByWithRelationInput
    utterances?: TranscriptUtteranceOrderByRelationAggregateInput
    ShowGuest?: ShowGuestOrderByRelationAggregateInput
    _relevance?: TranscriptOrderByRelevanceInput
  }

  export type TranscriptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    show_number?: number
    AND?: TranscriptWhereInput | TranscriptWhereInput[]
    OR?: TranscriptWhereInput[]
    NOT?: TranscriptWhereInput | TranscriptWhereInput[]
    show?: XOR<ShowScalarRelationFilter, ShowWhereInput>
    utterances?: TranscriptUtteranceListRelationFilter
    ShowGuest?: ShowGuestListRelationFilter
  }, "id" | "show_number">

  export type TranscriptOrderByWithAggregationInput = {
    id?: SortOrder
    show_number?: SortOrder
    _count?: TranscriptCountOrderByAggregateInput
    _avg?: TranscriptAvgOrderByAggregateInput
    _max?: TranscriptMaxOrderByAggregateInput
    _min?: TranscriptMinOrderByAggregateInput
    _sum?: TranscriptSumOrderByAggregateInput
  }

  export type TranscriptScalarWhereWithAggregatesInput = {
    AND?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    OR?: TranscriptScalarWhereWithAggregatesInput[]
    NOT?: TranscriptScalarWhereWithAggregatesInput | TranscriptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transcript"> | string
    show_number?: IntWithAggregatesFilter<"Transcript"> | number
  }

  export type TranscriptUtteranceWhereInput = {
    AND?: TranscriptUtteranceWhereInput | TranscriptUtteranceWhereInput[]
    OR?: TranscriptUtteranceWhereInput[]
    NOT?: TranscriptUtteranceWhereInput | TranscriptUtteranceWhereInput[]
    id?: StringFilter<"TranscriptUtterance"> | string
    start?: FloatFilter<"TranscriptUtterance"> | number
    end?: FloatFilter<"TranscriptUtterance"> | number
    confidence?: FloatFilter<"TranscriptUtterance"> | number
    channel?: IntFilter<"TranscriptUtterance"> | number
    transcript_value?: StringFilter<"TranscriptUtterance"> | string
    speaker?: IntFilter<"TranscriptUtterance"> | number
    speakerName?: StringNullableFilter<"TranscriptUtterance"> | string | null
    transcriptId?: StringFilter<"TranscriptUtterance"> | string
    words?: TranscriptUtteranceWordListRelationFilter
    transcript?: XOR<TranscriptScalarRelationFilter, TranscriptWhereInput>
  }

  export type TranscriptUtteranceOrderByWithRelationInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    channel?: SortOrder
    transcript_value?: SortOrder
    speaker?: SortOrder
    speakerName?: SortOrderInput | SortOrder
    transcriptId?: SortOrder
    words?: TranscriptUtteranceWordOrderByRelationAggregateInput
    transcript?: TranscriptOrderByWithRelationInput
    _relevance?: TranscriptUtteranceOrderByRelevanceInput
  }

  export type TranscriptUtteranceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranscriptUtteranceWhereInput | TranscriptUtteranceWhereInput[]
    OR?: TranscriptUtteranceWhereInput[]
    NOT?: TranscriptUtteranceWhereInput | TranscriptUtteranceWhereInput[]
    start?: FloatFilter<"TranscriptUtterance"> | number
    end?: FloatFilter<"TranscriptUtterance"> | number
    confidence?: FloatFilter<"TranscriptUtterance"> | number
    channel?: IntFilter<"TranscriptUtterance"> | number
    transcript_value?: StringFilter<"TranscriptUtterance"> | string
    speaker?: IntFilter<"TranscriptUtterance"> | number
    speakerName?: StringNullableFilter<"TranscriptUtterance"> | string | null
    transcriptId?: StringFilter<"TranscriptUtterance"> | string
    words?: TranscriptUtteranceWordListRelationFilter
    transcript?: XOR<TranscriptScalarRelationFilter, TranscriptWhereInput>
  }, "id">

  export type TranscriptUtteranceOrderByWithAggregationInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    channel?: SortOrder
    transcript_value?: SortOrder
    speaker?: SortOrder
    speakerName?: SortOrderInput | SortOrder
    transcriptId?: SortOrder
    _count?: TranscriptUtteranceCountOrderByAggregateInput
    _avg?: TranscriptUtteranceAvgOrderByAggregateInput
    _max?: TranscriptUtteranceMaxOrderByAggregateInput
    _min?: TranscriptUtteranceMinOrderByAggregateInput
    _sum?: TranscriptUtteranceSumOrderByAggregateInput
  }

  export type TranscriptUtteranceScalarWhereWithAggregatesInput = {
    AND?: TranscriptUtteranceScalarWhereWithAggregatesInput | TranscriptUtteranceScalarWhereWithAggregatesInput[]
    OR?: TranscriptUtteranceScalarWhereWithAggregatesInput[]
    NOT?: TranscriptUtteranceScalarWhereWithAggregatesInput | TranscriptUtteranceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TranscriptUtterance"> | string
    start?: FloatWithAggregatesFilter<"TranscriptUtterance"> | number
    end?: FloatWithAggregatesFilter<"TranscriptUtterance"> | number
    confidence?: FloatWithAggregatesFilter<"TranscriptUtterance"> | number
    channel?: IntWithAggregatesFilter<"TranscriptUtterance"> | number
    transcript_value?: StringWithAggregatesFilter<"TranscriptUtterance"> | string
    speaker?: IntWithAggregatesFilter<"TranscriptUtterance"> | number
    speakerName?: StringNullableWithAggregatesFilter<"TranscriptUtterance"> | string | null
    transcriptId?: StringWithAggregatesFilter<"TranscriptUtterance"> | string
  }

  export type TranscriptUtteranceWordWhereInput = {
    AND?: TranscriptUtteranceWordWhereInput | TranscriptUtteranceWordWhereInput[]
    OR?: TranscriptUtteranceWordWhereInput[]
    NOT?: TranscriptUtteranceWordWhereInput | TranscriptUtteranceWordWhereInput[]
    id?: StringFilter<"TranscriptUtteranceWord"> | string
    word?: StringFilter<"TranscriptUtteranceWord"> | string
    start?: FloatFilter<"TranscriptUtteranceWord"> | number
    end?: FloatFilter<"TranscriptUtteranceWord"> | number
    confidence?: FloatFilter<"TranscriptUtteranceWord"> | number
    speaker?: IntFilter<"TranscriptUtteranceWord"> | number
    speaker_confidence?: FloatFilter<"TranscriptUtteranceWord"> | number
    punctuated_word?: StringFilter<"TranscriptUtteranceWord"> | string
    transcriptUtteranceId?: StringFilter<"TranscriptUtteranceWord"> | string
    TranscriptUtterance?: XOR<TranscriptUtteranceNullableScalarRelationFilter, TranscriptUtteranceWhereInput> | null
  }

  export type TranscriptUtteranceWordOrderByWithRelationInput = {
    id?: SortOrder
    word?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    speaker?: SortOrder
    speaker_confidence?: SortOrder
    punctuated_word?: SortOrder
    transcriptUtteranceId?: SortOrder
    TranscriptUtterance?: TranscriptUtteranceOrderByWithRelationInput
    _relevance?: TranscriptUtteranceWordOrderByRelevanceInput
  }

  export type TranscriptUtteranceWordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TranscriptUtteranceWordWhereInput | TranscriptUtteranceWordWhereInput[]
    OR?: TranscriptUtteranceWordWhereInput[]
    NOT?: TranscriptUtteranceWordWhereInput | TranscriptUtteranceWordWhereInput[]
    word?: StringFilter<"TranscriptUtteranceWord"> | string
    start?: FloatFilter<"TranscriptUtteranceWord"> | number
    end?: FloatFilter<"TranscriptUtteranceWord"> | number
    confidence?: FloatFilter<"TranscriptUtteranceWord"> | number
    speaker?: IntFilter<"TranscriptUtteranceWord"> | number
    speaker_confidence?: FloatFilter<"TranscriptUtteranceWord"> | number
    punctuated_word?: StringFilter<"TranscriptUtteranceWord"> | string
    transcriptUtteranceId?: StringFilter<"TranscriptUtteranceWord"> | string
    TranscriptUtterance?: XOR<TranscriptUtteranceNullableScalarRelationFilter, TranscriptUtteranceWhereInput> | null
  }, "id">

  export type TranscriptUtteranceWordOrderByWithAggregationInput = {
    id?: SortOrder
    word?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    speaker?: SortOrder
    speaker_confidence?: SortOrder
    punctuated_word?: SortOrder
    transcriptUtteranceId?: SortOrder
    _count?: TranscriptUtteranceWordCountOrderByAggregateInput
    _avg?: TranscriptUtteranceWordAvgOrderByAggregateInput
    _max?: TranscriptUtteranceWordMaxOrderByAggregateInput
    _min?: TranscriptUtteranceWordMinOrderByAggregateInput
    _sum?: TranscriptUtteranceWordSumOrderByAggregateInput
  }

  export type TranscriptUtteranceWordScalarWhereWithAggregatesInput = {
    AND?: TranscriptUtteranceWordScalarWhereWithAggregatesInput | TranscriptUtteranceWordScalarWhereWithAggregatesInput[]
    OR?: TranscriptUtteranceWordScalarWhereWithAggregatesInput[]
    NOT?: TranscriptUtteranceWordScalarWhereWithAggregatesInput | TranscriptUtteranceWordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TranscriptUtteranceWord"> | string
    word?: StringWithAggregatesFilter<"TranscriptUtteranceWord"> | string
    start?: FloatWithAggregatesFilter<"TranscriptUtteranceWord"> | number
    end?: FloatWithAggregatesFilter<"TranscriptUtteranceWord"> | number
    confidence?: FloatWithAggregatesFilter<"TranscriptUtteranceWord"> | number
    speaker?: IntWithAggregatesFilter<"TranscriptUtteranceWord"> | number
    speaker_confidence?: FloatWithAggregatesFilter<"TranscriptUtteranceWord"> | number
    punctuated_word?: StringWithAggregatesFilter<"TranscriptUtteranceWord"> | string
    transcriptUtteranceId?: StringWithAggregatesFilter<"TranscriptUtteranceWord"> | string
  }

  export type AiShowNoteWhereInput = {
    AND?: AiShowNoteWhereInput | AiShowNoteWhereInput[]
    OR?: AiShowNoteWhereInput[]
    NOT?: AiShowNoteWhereInput | AiShowNoteWhereInput[]
    id?: IntFilter<"AiShowNote"> | number
    show_number?: IntFilter<"AiShowNote"> | number
    title?: StringFilter<"AiShowNote"> | string
    description?: StringFilter<"AiShowNote"> | string
    provider?: StringFilter<"AiShowNote"> | string
    show?: XOR<ShowScalarRelationFilter, ShowWhereInput>
    summary?: AiSummaryEntryListRelationFilter
    tweets?: AiTweetListRelationFilter
    links?: LinkListRelationFilter
    guests?: AiGuestListRelationFilter
    topics?: TopicListRelationFilter
  }

  export type AiShowNoteOrderByWithRelationInput = {
    id?: SortOrder
    show_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    provider?: SortOrder
    show?: ShowOrderByWithRelationInput
    summary?: AiSummaryEntryOrderByRelationAggregateInput
    tweets?: AiTweetOrderByRelationAggregateInput
    links?: LinkOrderByRelationAggregateInput
    guests?: AiGuestOrderByRelationAggregateInput
    topics?: TopicOrderByRelationAggregateInput
    _relevance?: AiShowNoteOrderByRelevanceInput
  }

  export type AiShowNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    show_number?: number
    AND?: AiShowNoteWhereInput | AiShowNoteWhereInput[]
    OR?: AiShowNoteWhereInput[]
    NOT?: AiShowNoteWhereInput | AiShowNoteWhereInput[]
    title?: StringFilter<"AiShowNote"> | string
    description?: StringFilter<"AiShowNote"> | string
    provider?: StringFilter<"AiShowNote"> | string
    show?: XOR<ShowScalarRelationFilter, ShowWhereInput>
    summary?: AiSummaryEntryListRelationFilter
    tweets?: AiTweetListRelationFilter
    links?: LinkListRelationFilter
    guests?: AiGuestListRelationFilter
    topics?: TopicListRelationFilter
  }, "id" | "show_number">

  export type AiShowNoteOrderByWithAggregationInput = {
    id?: SortOrder
    show_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    provider?: SortOrder
    _count?: AiShowNoteCountOrderByAggregateInput
    _avg?: AiShowNoteAvgOrderByAggregateInput
    _max?: AiShowNoteMaxOrderByAggregateInput
    _min?: AiShowNoteMinOrderByAggregateInput
    _sum?: AiShowNoteSumOrderByAggregateInput
  }

  export type AiShowNoteScalarWhereWithAggregatesInput = {
    AND?: AiShowNoteScalarWhereWithAggregatesInput | AiShowNoteScalarWhereWithAggregatesInput[]
    OR?: AiShowNoteScalarWhereWithAggregatesInput[]
    NOT?: AiShowNoteScalarWhereWithAggregatesInput | AiShowNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AiShowNote"> | number
    show_number?: IntWithAggregatesFilter<"AiShowNote"> | number
    title?: StringWithAggregatesFilter<"AiShowNote"> | string
    description?: StringWithAggregatesFilter<"AiShowNote"> | string
    provider?: StringWithAggregatesFilter<"AiShowNote"> | string
  }

  export type AiSummaryEntryWhereInput = {
    AND?: AiSummaryEntryWhereInput | AiSummaryEntryWhereInput[]
    OR?: AiSummaryEntryWhereInput[]
    NOT?: AiSummaryEntryWhereInput | AiSummaryEntryWhereInput[]
    id?: IntFilter<"AiSummaryEntry"> | number
    time?: StringFilter<"AiSummaryEntry"> | string
    text?: StringFilter<"AiSummaryEntry"> | string
    description?: StringNullableFilter<"AiSummaryEntry"> | string | null
    showNote?: IntFilter<"AiSummaryEntry"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }

  export type AiSummaryEntryOrderByWithRelationInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    description?: SortOrderInput | SortOrder
    showNote?: SortOrder
    aiShowNote?: AiShowNoteOrderByWithRelationInput
    _relevance?: AiSummaryEntryOrderByRelevanceInput
  }

  export type AiSummaryEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AiSummaryEntryWhereInput | AiSummaryEntryWhereInput[]
    OR?: AiSummaryEntryWhereInput[]
    NOT?: AiSummaryEntryWhereInput | AiSummaryEntryWhereInput[]
    time?: StringFilter<"AiSummaryEntry"> | string
    text?: StringFilter<"AiSummaryEntry"> | string
    description?: StringNullableFilter<"AiSummaryEntry"> | string | null
    showNote?: IntFilter<"AiSummaryEntry"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }, "id">

  export type AiSummaryEntryOrderByWithAggregationInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    description?: SortOrderInput | SortOrder
    showNote?: SortOrder
    _count?: AiSummaryEntryCountOrderByAggregateInput
    _avg?: AiSummaryEntryAvgOrderByAggregateInput
    _max?: AiSummaryEntryMaxOrderByAggregateInput
    _min?: AiSummaryEntryMinOrderByAggregateInput
    _sum?: AiSummaryEntrySumOrderByAggregateInput
  }

  export type AiSummaryEntryScalarWhereWithAggregatesInput = {
    AND?: AiSummaryEntryScalarWhereWithAggregatesInput | AiSummaryEntryScalarWhereWithAggregatesInput[]
    OR?: AiSummaryEntryScalarWhereWithAggregatesInput[]
    NOT?: AiSummaryEntryScalarWhereWithAggregatesInput | AiSummaryEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AiSummaryEntry"> | number
    time?: StringWithAggregatesFilter<"AiSummaryEntry"> | string
    text?: StringWithAggregatesFilter<"AiSummaryEntry"> | string
    description?: StringNullableWithAggregatesFilter<"AiSummaryEntry"> | string | null
    showNote?: IntWithAggregatesFilter<"AiSummaryEntry"> | number
  }

  export type AiTweetWhereInput = {
    AND?: AiTweetWhereInput | AiTweetWhereInput[]
    OR?: AiTweetWhereInput[]
    NOT?: AiTweetWhereInput | AiTweetWhereInput[]
    id?: IntFilter<"AiTweet"> | number
    content?: StringFilter<"AiTweet"> | string
    showNote?: IntFilter<"AiTweet"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }

  export type AiTweetOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    showNote?: SortOrder
    aiShowNote?: AiShowNoteOrderByWithRelationInput
    _relevance?: AiTweetOrderByRelevanceInput
  }

  export type AiTweetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AiTweetWhereInput | AiTweetWhereInput[]
    OR?: AiTweetWhereInput[]
    NOT?: AiTweetWhereInput | AiTweetWhereInput[]
    content?: StringFilter<"AiTweet"> | string
    showNote?: IntFilter<"AiTweet"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }, "id">

  export type AiTweetOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    showNote?: SortOrder
    _count?: AiTweetCountOrderByAggregateInput
    _avg?: AiTweetAvgOrderByAggregateInput
    _max?: AiTweetMaxOrderByAggregateInput
    _min?: AiTweetMinOrderByAggregateInput
    _sum?: AiTweetSumOrderByAggregateInput
  }

  export type AiTweetScalarWhereWithAggregatesInput = {
    AND?: AiTweetScalarWhereWithAggregatesInput | AiTweetScalarWhereWithAggregatesInput[]
    OR?: AiTweetScalarWhereWithAggregatesInput[]
    NOT?: AiTweetScalarWhereWithAggregatesInput | AiTweetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AiTweet"> | number
    content?: StringWithAggregatesFilter<"AiTweet"> | string
    showNote?: IntWithAggregatesFilter<"AiTweet"> | number
  }

  export type LinkWhereInput = {
    AND?: LinkWhereInput | LinkWhereInput[]
    OR?: LinkWhereInput[]
    NOT?: LinkWhereInput | LinkWhereInput[]
    id?: IntFilter<"Link"> | number
    name?: StringFilter<"Link"> | string
    url?: StringFilter<"Link"> | string
    timestamp?: StringNullableFilter<"Link"> | string | null
    showNote?: IntFilter<"Link"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }

  export type LinkOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    showNote?: SortOrder
    aiShowNote?: AiShowNoteOrderByWithRelationInput
    _relevance?: LinkOrderByRelevanceInput
  }

  export type LinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LinkWhereInput | LinkWhereInput[]
    OR?: LinkWhereInput[]
    NOT?: LinkWhereInput | LinkWhereInput[]
    name?: StringFilter<"Link"> | string
    url?: StringFilter<"Link"> | string
    timestamp?: StringNullableFilter<"Link"> | string | null
    showNote?: IntFilter<"Link"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }, "id">

  export type LinkOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    showNote?: SortOrder
    _count?: LinkCountOrderByAggregateInput
    _avg?: LinkAvgOrderByAggregateInput
    _max?: LinkMaxOrderByAggregateInput
    _min?: LinkMinOrderByAggregateInput
    _sum?: LinkSumOrderByAggregateInput
  }

  export type LinkScalarWhereWithAggregatesInput = {
    AND?: LinkScalarWhereWithAggregatesInput | LinkScalarWhereWithAggregatesInput[]
    OR?: LinkScalarWhereWithAggregatesInput[]
    NOT?: LinkScalarWhereWithAggregatesInput | LinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Link"> | number
    name?: StringWithAggregatesFilter<"Link"> | string
    url?: StringWithAggregatesFilter<"Link"> | string
    timestamp?: StringNullableWithAggregatesFilter<"Link"> | string | null
    showNote?: IntWithAggregatesFilter<"Link"> | number
  }

  export type AiGuestWhereInput = {
    AND?: AiGuestWhereInput | AiGuestWhereInput[]
    OR?: AiGuestWhereInput[]
    NOT?: AiGuestWhereInput | AiGuestWhereInput[]
    id?: IntFilter<"AiGuest"> | number
    name?: StringFilter<"AiGuest"> | string
    showNote?: IntFilter<"AiGuest"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }

  export type AiGuestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
    aiShowNote?: AiShowNoteOrderByWithRelationInput
    _relevance?: AiGuestOrderByRelevanceInput
  }

  export type AiGuestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AiGuestWhereInput | AiGuestWhereInput[]
    OR?: AiGuestWhereInput[]
    NOT?: AiGuestWhereInput | AiGuestWhereInput[]
    name?: StringFilter<"AiGuest"> | string
    showNote?: IntFilter<"AiGuest"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }, "id">

  export type AiGuestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
    _count?: AiGuestCountOrderByAggregateInput
    _avg?: AiGuestAvgOrderByAggregateInput
    _max?: AiGuestMaxOrderByAggregateInput
    _min?: AiGuestMinOrderByAggregateInput
    _sum?: AiGuestSumOrderByAggregateInput
  }

  export type AiGuestScalarWhereWithAggregatesInput = {
    AND?: AiGuestScalarWhereWithAggregatesInput | AiGuestScalarWhereWithAggregatesInput[]
    OR?: AiGuestScalarWhereWithAggregatesInput[]
    NOT?: AiGuestScalarWhereWithAggregatesInput | AiGuestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AiGuest"> | number
    name?: StringWithAggregatesFilter<"AiGuest"> | string
    showNote?: IntWithAggregatesFilter<"AiGuest"> | number
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: IntFilter<"Topic"> | number
    name?: StringFilter<"Topic"> | string
    showNote?: IntFilter<"Topic"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
    aiShowNote?: AiShowNoteOrderByWithRelationInput
    _relevance?: TopicOrderByRelevanceInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    name?: StringFilter<"Topic"> | string
    showNote?: IntFilter<"Topic"> | number
    aiShowNote?: XOR<AiShowNoteScalarRelationFilter, AiShowNoteWhereInput>
  }, "id">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _avg?: TopicAvgOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
    _sum?: TopicSumOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Topic"> | number
    name?: StringWithAggregatesFilter<"Topic"> | string
    showNote?: IntWithAggregatesFilter<"Topic"> | number
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    id?: StringFilter<"Video"> | string
    title?: StringFilter<"Video"> | string
    description?: StringNullableFilter<"Video"> | string | null
    url?: StringFilter<"Video"> | string
    published_at?: DateTimeFilter<"Video"> | Date | string
    thumbnail?: StringFilter<"Video"> | string
    slug?: StringFilter<"Video"> | string
    playlists?: PlaylistOnVideoListRelationFilter
    shows?: ShowVideoListRelationFilter
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    published_at?: SortOrder
    thumbnail?: SortOrder
    slug?: SortOrder
    playlists?: PlaylistOnVideoOrderByRelationAggregateInput
    shows?: ShowVideoOrderByRelationAggregateInput
    _relevance?: VideoOrderByRelevanceInput
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    title?: StringFilter<"Video"> | string
    description?: StringNullableFilter<"Video"> | string | null
    url?: StringFilter<"Video"> | string
    published_at?: DateTimeFilter<"Video"> | Date | string
    thumbnail?: StringFilter<"Video"> | string
    playlists?: PlaylistOnVideoListRelationFilter
    shows?: ShowVideoListRelationFilter
  }, "id" | "slug">

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    published_at?: SortOrder
    thumbnail?: SortOrder
    slug?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Video"> | string
    title?: StringWithAggregatesFilter<"Video"> | string
    description?: StringNullableWithAggregatesFilter<"Video"> | string | null
    url?: StringWithAggregatesFilter<"Video"> | string
    published_at?: DateTimeWithAggregatesFilter<"Video"> | Date | string
    thumbnail?: StringWithAggregatesFilter<"Video"> | string
    slug?: StringWithAggregatesFilter<"Video"> | string
  }

  export type PlaylistWhereInput = {
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    id?: StringFilter<"Playlist"> | string
    title?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    created_at?: DateTimeFilter<"Playlist"> | Date | string
    slug?: StringFilter<"Playlist"> | string
    unlisted?: BoolNullableFilter<"Playlist"> | boolean | null
    videos?: PlaylistOnVideoListRelationFilter
  }

  export type PlaylistOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    slug?: SortOrder
    unlisted?: SortOrderInput | SortOrder
    videos?: PlaylistOnVideoOrderByRelationAggregateInput
    _relevance?: PlaylistOrderByRelevanceInput
  }

  export type PlaylistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PlaylistWhereInput | PlaylistWhereInput[]
    OR?: PlaylistWhereInput[]
    NOT?: PlaylistWhereInput | PlaylistWhereInput[]
    title?: StringFilter<"Playlist"> | string
    description?: StringNullableFilter<"Playlist"> | string | null
    created_at?: DateTimeFilter<"Playlist"> | Date | string
    unlisted?: BoolNullableFilter<"Playlist"> | boolean | null
    videos?: PlaylistOnVideoListRelationFilter
  }, "id" | "slug">

  export type PlaylistOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    slug?: SortOrder
    unlisted?: SortOrderInput | SortOrder
    _count?: PlaylistCountOrderByAggregateInput
    _max?: PlaylistMaxOrderByAggregateInput
    _min?: PlaylistMinOrderByAggregateInput
  }

  export type PlaylistScalarWhereWithAggregatesInput = {
    AND?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    OR?: PlaylistScalarWhereWithAggregatesInput[]
    NOT?: PlaylistScalarWhereWithAggregatesInput | PlaylistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Playlist"> | string
    title?: StringWithAggregatesFilter<"Playlist"> | string
    description?: StringNullableWithAggregatesFilter<"Playlist"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Playlist"> | Date | string
    slug?: StringWithAggregatesFilter<"Playlist"> | string
    unlisted?: BoolNullableWithAggregatesFilter<"Playlist"> | boolean | null
  }

  export type PlaylistOnVideoWhereInput = {
    AND?: PlaylistOnVideoWhereInput | PlaylistOnVideoWhereInput[]
    OR?: PlaylistOnVideoWhereInput[]
    NOT?: PlaylistOnVideoWhereInput | PlaylistOnVideoWhereInput[]
    video_id?: StringFilter<"PlaylistOnVideo"> | string
    playlist_id?: StringFilter<"PlaylistOnVideo"> | string
    order?: IntFilter<"PlaylistOnVideo"> | number
    video?: XOR<VideoScalarRelationFilter, VideoWhereInput>
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput>
  }

  export type PlaylistOnVideoOrderByWithRelationInput = {
    video_id?: SortOrder
    playlist_id?: SortOrder
    order?: SortOrder
    video?: VideoOrderByWithRelationInput
    playlist?: PlaylistOrderByWithRelationInput
    _relevance?: PlaylistOnVideoOrderByRelevanceInput
  }

  export type PlaylistOnVideoWhereUniqueInput = Prisma.AtLeast<{
    video_id_playlist_id?: PlaylistOnVideoVideo_idPlaylist_idCompoundUniqueInput
    AND?: PlaylistOnVideoWhereInput | PlaylistOnVideoWhereInput[]
    OR?: PlaylistOnVideoWhereInput[]
    NOT?: PlaylistOnVideoWhereInput | PlaylistOnVideoWhereInput[]
    video_id?: StringFilter<"PlaylistOnVideo"> | string
    playlist_id?: StringFilter<"PlaylistOnVideo"> | string
    order?: IntFilter<"PlaylistOnVideo"> | number
    video?: XOR<VideoScalarRelationFilter, VideoWhereInput>
    playlist?: XOR<PlaylistScalarRelationFilter, PlaylistWhereInput>
  }, "video_id_playlist_id" | "video_id_playlist_id">

  export type PlaylistOnVideoOrderByWithAggregationInput = {
    video_id?: SortOrder
    playlist_id?: SortOrder
    order?: SortOrder
    _count?: PlaylistOnVideoCountOrderByAggregateInput
    _avg?: PlaylistOnVideoAvgOrderByAggregateInput
    _max?: PlaylistOnVideoMaxOrderByAggregateInput
    _min?: PlaylistOnVideoMinOrderByAggregateInput
    _sum?: PlaylistOnVideoSumOrderByAggregateInput
  }

  export type PlaylistOnVideoScalarWhereWithAggregatesInput = {
    AND?: PlaylistOnVideoScalarWhereWithAggregatesInput | PlaylistOnVideoScalarWhereWithAggregatesInput[]
    OR?: PlaylistOnVideoScalarWhereWithAggregatesInput[]
    NOT?: PlaylistOnVideoScalarWhereWithAggregatesInput | PlaylistOnVideoScalarWhereWithAggregatesInput[]
    video_id?: StringWithAggregatesFilter<"PlaylistOnVideo"> | string
    playlist_id?: StringWithAggregatesFilter<"PlaylistOnVideo"> | string
    order?: IntWithAggregatesFilter<"PlaylistOnVideo"> | number
  }

  export type RemotePlaylistWhereInput = {
    AND?: RemotePlaylistWhereInput | RemotePlaylistWhereInput[]
    OR?: RemotePlaylistWhereInput[]
    NOT?: RemotePlaylistWhereInput | RemotePlaylistWhereInput[]
    playlist_id?: StringFilter<"RemotePlaylist"> | string
    title?: StringFilter<"RemotePlaylist"> | string
    videos_count?: IntFilter<"RemotePlaylist"> | number
    created_at?: DateTimeFilter<"RemotePlaylist"> | Date | string
  }

  export type RemotePlaylistOrderByWithRelationInput = {
    playlist_id?: SortOrder
    title?: SortOrder
    videos_count?: SortOrder
    created_at?: SortOrder
    _relevance?: RemotePlaylistOrderByRelevanceInput
  }

  export type RemotePlaylistWhereUniqueInput = Prisma.AtLeast<{
    playlist_id?: string
    AND?: RemotePlaylistWhereInput | RemotePlaylistWhereInput[]
    OR?: RemotePlaylistWhereInput[]
    NOT?: RemotePlaylistWhereInput | RemotePlaylistWhereInput[]
    title?: StringFilter<"RemotePlaylist"> | string
    videos_count?: IntFilter<"RemotePlaylist"> | number
    created_at?: DateTimeFilter<"RemotePlaylist"> | Date | string
  }, "playlist_id">

  export type RemotePlaylistOrderByWithAggregationInput = {
    playlist_id?: SortOrder
    title?: SortOrder
    videos_count?: SortOrder
    created_at?: SortOrder
    _count?: RemotePlaylistCountOrderByAggregateInput
    _avg?: RemotePlaylistAvgOrderByAggregateInput
    _max?: RemotePlaylistMaxOrderByAggregateInput
    _min?: RemotePlaylistMinOrderByAggregateInput
    _sum?: RemotePlaylistSumOrderByAggregateInput
  }

  export type RemotePlaylistScalarWhereWithAggregatesInput = {
    AND?: RemotePlaylistScalarWhereWithAggregatesInput | RemotePlaylistScalarWhereWithAggregatesInput[]
    OR?: RemotePlaylistScalarWhereWithAggregatesInput[]
    NOT?: RemotePlaylistScalarWhereWithAggregatesInput | RemotePlaylistScalarWhereWithAggregatesInput[]
    playlist_id?: StringWithAggregatesFilter<"RemotePlaylist"> | string
    title?: StringWithAggregatesFilter<"RemotePlaylist"> | string
    videos_count?: IntWithAggregatesFilter<"RemotePlaylist"> | number
    created_at?: DateTimeWithAggregatesFilter<"RemotePlaylist"> | Date | string
  }

  export type ShowVideoWhereInput = {
    AND?: ShowVideoWhereInput | ShowVideoWhereInput[]
    OR?: ShowVideoWhereInput[]
    NOT?: ShowVideoWhereInput | ShowVideoWhereInput[]
    showId?: StringFilter<"ShowVideo"> | string
    videoId?: StringFilter<"ShowVideo"> | string
    show?: XOR<ShowScalarRelationFilter, ShowWhereInput>
    video?: XOR<VideoScalarRelationFilter, VideoWhereInput>
  }

  export type ShowVideoOrderByWithRelationInput = {
    showId?: SortOrder
    videoId?: SortOrder
    show?: ShowOrderByWithRelationInput
    video?: VideoOrderByWithRelationInput
    _relevance?: ShowVideoOrderByRelevanceInput
  }

  export type ShowVideoWhereUniqueInput = Prisma.AtLeast<{
    showId_videoId?: ShowVideoShowIdVideoIdCompoundUniqueInput
    AND?: ShowVideoWhereInput | ShowVideoWhereInput[]
    OR?: ShowVideoWhereInput[]
    NOT?: ShowVideoWhereInput | ShowVideoWhereInput[]
    showId?: StringFilter<"ShowVideo"> | string
    videoId?: StringFilter<"ShowVideo"> | string
    show?: XOR<ShowScalarRelationFilter, ShowWhereInput>
    video?: XOR<VideoScalarRelationFilter, VideoWhereInput>
  }, "showId_videoId">

  export type ShowVideoOrderByWithAggregationInput = {
    showId?: SortOrder
    videoId?: SortOrder
    _count?: ShowVideoCountOrderByAggregateInput
    _max?: ShowVideoMaxOrderByAggregateInput
    _min?: ShowVideoMinOrderByAggregateInput
  }

  export type ShowVideoScalarWhereWithAggregatesInput = {
    AND?: ShowVideoScalarWhereWithAggregatesInput | ShowVideoScalarWhereWithAggregatesInput[]
    OR?: ShowVideoScalarWhereWithAggregatesInput[]
    NOT?: ShowVideoScalarWhereWithAggregatesInput | ShowVideoScalarWhereWithAggregatesInput[]
    showId?: StringWithAggregatesFilter<"ShowVideo"> | string
    videoId?: StringWithAggregatesFilter<"ShowVideo"> | string
  }

  export type UserSubmissionWhereInput = {
    AND?: UserSubmissionWhereInput | UserSubmissionWhereInput[]
    OR?: UserSubmissionWhereInput[]
    NOT?: UserSubmissionWhereInput | UserSubmissionWhereInput[]
    id?: StringFilter<"UserSubmission"> | string
    name?: StringNullableFilter<"UserSubmission"> | string | null
    email?: StringNullableFilter<"UserSubmission"> | string | null
    body?: StringFilter<"UserSubmission"> | string
    created_at?: DateTimeFilter<"UserSubmission"> | Date | string
    updated_at?: DateTimeFilter<"UserSubmission"> | Date | string
    audio_url?: StringNullableFilter<"UserSubmission"> | string | null
    status?: EnumUserSubmissionStatusFilter<"UserSubmission"> | $Enums.UserSubmissionStatus
    submission_type?: EnumUserSubmissionTypeFilter<"UserSubmission"> | $Enums.UserSubmissionType
  }

  export type UserSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    audio_url?: SortOrderInput | SortOrder
    status?: SortOrder
    submission_type?: SortOrder
    _relevance?: UserSubmissionOrderByRelevanceInput
  }

  export type UserSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSubmissionWhereInput | UserSubmissionWhereInput[]
    OR?: UserSubmissionWhereInput[]
    NOT?: UserSubmissionWhereInput | UserSubmissionWhereInput[]
    name?: StringNullableFilter<"UserSubmission"> | string | null
    email?: StringNullableFilter<"UserSubmission"> | string | null
    body?: StringFilter<"UserSubmission"> | string
    created_at?: DateTimeFilter<"UserSubmission"> | Date | string
    updated_at?: DateTimeFilter<"UserSubmission"> | Date | string
    audio_url?: StringNullableFilter<"UserSubmission"> | string | null
    status?: EnumUserSubmissionStatusFilter<"UserSubmission"> | $Enums.UserSubmissionStatus
    submission_type?: EnumUserSubmissionTypeFilter<"UserSubmission"> | $Enums.UserSubmissionType
  }, "id">

  export type UserSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    audio_url?: SortOrderInput | SortOrder
    status?: SortOrder
    submission_type?: SortOrder
    _count?: UserSubmissionCountOrderByAggregateInput
    _max?: UserSubmissionMaxOrderByAggregateInput
    _min?: UserSubmissionMinOrderByAggregateInput
  }

  export type UserSubmissionScalarWhereWithAggregatesInput = {
    AND?: UserSubmissionScalarWhereWithAggregatesInput | UserSubmissionScalarWhereWithAggregatesInput[]
    OR?: UserSubmissionScalarWhereWithAggregatesInput[]
    NOT?: UserSubmissionScalarWhereWithAggregatesInput | UserSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSubmission"> | string
    name?: StringNullableWithAggregatesFilter<"UserSubmission"> | string | null
    email?: StringNullableWithAggregatesFilter<"UserSubmission"> | string | null
    body?: StringWithAggregatesFilter<"UserSubmission"> | string
    created_at?: DateTimeWithAggregatesFilter<"UserSubmission"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UserSubmission"> | Date | string
    audio_url?: StringNullableWithAggregatesFilter<"UserSubmission"> | string | null
    status?: EnumUserSubmissionStatusWithAggregatesFilter<"UserSubmission"> | $Enums.UserSubmissionStatus
    submission_type?: EnumUserSubmissionTypeWithAggregatesFilter<"UserSubmission"> | $Enums.UserSubmissionType
  }

  export type UserCreateInput = {
    id?: string
    avatar_url?: string | null
    created_at?: Date | string
    email?: string | null
    github_id: number
    updated_at?: Date | string
    username?: string | null
    theme?: string
    name?: string | null
    twitter?: string | null
    session?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
    hostedShows?: ShowCreateNestedManyWithoutHostsInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    avatar_url?: string | null
    created_at?: Date | string
    email?: string | null
    github_id: number
    updated_at?: Date | string
    username?: string | null
    theme?: string
    name?: string | null
    twitter?: string | null
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedShows?: ShowUncheckedCreateNestedManyWithoutHostsInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedShows?: ShowUpdateManyWithoutHostsNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedShows?: ShowUncheckedUpdateManyWithoutHostsNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    avatar_url?: string | null
    created_at?: Date | string
    email?: string | null
    github_id: number
    updated_at?: Date | string
    username?: string | null
    theme?: string
    name?: string | null
    twitter?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    access_token?: string | null
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string
    ip?: string | null
    country?: string | null
    user?: UserCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    user_id?: string | null
    access_token?: string | null
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string
    ip?: string | null
    country?: string | null
  }

  export type SessionUpdateInput = {
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id?: number
    user_id?: string | null
    access_token?: string | null
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string
    ip?: string | null
    country?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShowGuestCreateInput = {
    id?: string
    Show: ShowCreateNestedOneWithoutGuestsInput
    Guest: GuestCreateNestedOneWithoutShowsInput
    Transcript?: TranscriptCreateNestedOneWithoutShowGuestInput
  }

  export type ShowGuestUncheckedCreateInput = {
    id?: string
    showId: string
    guestId: string
    transcriptId?: string | null
  }

  export type ShowGuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Show?: ShowUpdateOneRequiredWithoutGuestsNestedInput
    Guest?: GuestUpdateOneRequiredWithoutShowsNestedInput
    Transcript?: TranscriptUpdateOneWithoutShowGuestNestedInput
  }

  export type ShowGuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    showId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShowGuestCreateManyInput = {
    id?: string
    showId: string
    guestId: string
    transcriptId?: string | null
  }

  export type ShowGuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ShowGuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    showId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuestCreateInput = {
    id?: string
    name: string
    name_slug: string
    twitter?: string | null
    github?: string | null
    of?: string | null
    url?: string | null
    social?: SocialLinkCreateNestedManyWithoutGuestInput
    shows?: ShowGuestCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateInput = {
    id?: string
    name: string
    name_slug: string
    twitter?: string | null
    github?: string | null
    of?: string | null
    url?: string | null
    social?: SocialLinkUncheckedCreateNestedManyWithoutGuestInput
    shows?: ShowGuestUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_slug?: StringFieldUpdateOperationsInput | string
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    of?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    social?: SocialLinkUpdateManyWithoutGuestNestedInput
    shows?: ShowGuestUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_slug?: StringFieldUpdateOperationsInput | string
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    of?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    social?: SocialLinkUncheckedUpdateManyWithoutGuestNestedInput
    shows?: ShowGuestUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type GuestCreateManyInput = {
    id?: string
    name: string
    name_slug: string
    twitter?: string | null
    github?: string | null
    of?: string | null
    url?: string | null
  }

  export type GuestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_slug?: StringFieldUpdateOperationsInput | string
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    of?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GuestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_slug?: StringFieldUpdateOperationsInput | string
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    of?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SocialLinkCreateInput = {
    id?: string
    link: string
    guest: GuestCreateNestedOneWithoutSocialInput
  }

  export type SocialLinkUncheckedCreateInput = {
    id?: string
    link: string
    guest_id: string
  }

  export type SocialLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    guest?: GuestUpdateOneRequiredWithoutSocialNestedInput
  }

  export type SocialLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    guest_id?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkCreateManyInput = {
    id?: string
    link: string
    guest_id: string
  }

  export type SocialLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    guest_id?: StringFieldUpdateOperationsInput | string
  }

  export type ShowCreateInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestCreateNestedManyWithoutShowInput
    transcript?: TranscriptCreateNestedOneWithoutShowInput
    aiShowNote?: AiShowNoteCreateNestedOneWithoutShowInput
    videos?: ShowVideoCreateNestedManyWithoutShowInput
    hosts?: UserCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowUncheckedCreateInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestUncheckedCreateNestedManyWithoutShowInput
    transcript?: TranscriptUncheckedCreateNestedOneWithoutShowInput
    aiShowNote?: AiShowNoteUncheckedCreateNestedOneWithoutShowInput
    videos?: ShowVideoUncheckedCreateNestedManyWithoutShowInput
    hosts?: UserUncheckedCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUpdateManyWithoutShowNestedInput
    transcript?: TranscriptUpdateOneWithoutShowNestedInput
    aiShowNote?: AiShowNoteUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUpdateManyWithoutShowNestedInput
    hosts?: UserUpdateManyWithoutHostedShowsNestedInput
  }

  export type ShowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUncheckedUpdateManyWithoutShowNestedInput
    transcript?: TranscriptUncheckedUpdateOneWithoutShowNestedInput
    aiShowNote?: AiShowNoteUncheckedUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUncheckedUpdateManyWithoutShowNestedInput
    hosts?: UserUncheckedUpdateManyWithoutHostedShowsNestedInput
  }

  export type ShowCreateManyInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
  }

  export type ShowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
  }

  export type ShowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
  }

  export type TranscriptCreateInput = {
    id?: string
    show: ShowCreateNestedOneWithoutTranscriptInput
    utterances?: TranscriptUtteranceCreateNestedManyWithoutTranscriptInput
    ShowGuest?: ShowGuestCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptUncheckedCreateInput = {
    id?: string
    show_number: number
    utterances?: TranscriptUtteranceUncheckedCreateNestedManyWithoutTranscriptInput
    ShowGuest?: ShowGuestUncheckedCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    show?: ShowUpdateOneRequiredWithoutTranscriptNestedInput
    utterances?: TranscriptUtteranceUpdateManyWithoutTranscriptNestedInput
    ShowGuest?: ShowGuestUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    show_number?: IntFieldUpdateOperationsInput | number
    utterances?: TranscriptUtteranceUncheckedUpdateManyWithoutTranscriptNestedInput
    ShowGuest?: ShowGuestUncheckedUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptCreateManyInput = {
    id?: string
    show_number: number
  }

  export type TranscriptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    show_number?: IntFieldUpdateOperationsInput | number
  }

  export type TranscriptUtteranceCreateInput = {
    id?: string
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: string
    speaker: number
    speakerName?: string | null
    words?: TranscriptUtteranceWordCreateNestedManyWithoutTranscriptUtteranceInput
    transcript: TranscriptCreateNestedOneWithoutUtterancesInput
  }

  export type TranscriptUtteranceUncheckedCreateInput = {
    id?: string
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: string
    speaker: number
    speakerName?: string | null
    transcriptId: string
    words?: TranscriptUtteranceWordUncheckedCreateNestedManyWithoutTranscriptUtteranceInput
  }

  export type TranscriptUtteranceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    channel?: IntFieldUpdateOperationsInput | number
    transcript_value?: StringFieldUpdateOperationsInput | string
    speaker?: IntFieldUpdateOperationsInput | number
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    words?: TranscriptUtteranceWordUpdateManyWithoutTranscriptUtteranceNestedInput
    transcript?: TranscriptUpdateOneRequiredWithoutUtterancesNestedInput
  }

  export type TranscriptUtteranceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    channel?: IntFieldUpdateOperationsInput | number
    transcript_value?: StringFieldUpdateOperationsInput | string
    speaker?: IntFieldUpdateOperationsInput | number
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: StringFieldUpdateOperationsInput | string
    words?: TranscriptUtteranceWordUncheckedUpdateManyWithoutTranscriptUtteranceNestedInput
  }

  export type TranscriptUtteranceCreateManyInput = {
    id?: string
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: string
    speaker: number
    speakerName?: string | null
    transcriptId: string
  }

  export type TranscriptUtteranceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    channel?: IntFieldUpdateOperationsInput | number
    transcript_value?: StringFieldUpdateOperationsInput | string
    speaker?: IntFieldUpdateOperationsInput | number
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranscriptUtteranceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    channel?: IntFieldUpdateOperationsInput | number
    transcript_value?: StringFieldUpdateOperationsInput | string
    speaker?: IntFieldUpdateOperationsInput | number
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptUtteranceWordCreateInput = {
    id?: string
    word: string
    start: number
    end: number
    confidence: number
    speaker: number
    speaker_confidence: number
    punctuated_word: string
    TranscriptUtterance?: TranscriptUtteranceCreateNestedOneWithoutWordsInput
  }

  export type TranscriptUtteranceWordUncheckedCreateInput = {
    id?: string
    word: string
    start: number
    end: number
    confidence: number
    speaker: number
    speaker_confidence: number
    punctuated_word: string
    transcriptUtteranceId: string
  }

  export type TranscriptUtteranceWordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    speaker?: IntFieldUpdateOperationsInput | number
    speaker_confidence?: FloatFieldUpdateOperationsInput | number
    punctuated_word?: StringFieldUpdateOperationsInput | string
    TranscriptUtterance?: TranscriptUtteranceUpdateOneWithoutWordsNestedInput
  }

  export type TranscriptUtteranceWordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    speaker?: IntFieldUpdateOperationsInput | number
    speaker_confidence?: FloatFieldUpdateOperationsInput | number
    punctuated_word?: StringFieldUpdateOperationsInput | string
    transcriptUtteranceId?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptUtteranceWordCreateManyInput = {
    id?: string
    word: string
    start: number
    end: number
    confidence: number
    speaker: number
    speaker_confidence: number
    punctuated_word: string
    transcriptUtteranceId: string
  }

  export type TranscriptUtteranceWordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    speaker?: IntFieldUpdateOperationsInput | number
    speaker_confidence?: FloatFieldUpdateOperationsInput | number
    punctuated_word?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptUtteranceWordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    speaker?: IntFieldUpdateOperationsInput | number
    speaker_confidence?: FloatFieldUpdateOperationsInput | number
    punctuated_word?: StringFieldUpdateOperationsInput | string
    transcriptUtteranceId?: StringFieldUpdateOperationsInput | string
  }

  export type AiShowNoteCreateInput = {
    title: string
    description: string
    provider?: string
    show: ShowCreateNestedOneWithoutAiShowNoteInput
    summary?: AiSummaryEntryCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetCreateNestedManyWithoutAiShowNoteInput
    links?: LinkCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteUncheckedCreateInput = {
    id?: number
    show_number: number
    title: string
    description: string
    provider?: string
    summary?: AiSummaryEntryUncheckedCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetUncheckedCreateNestedManyWithoutAiShowNoteInput
    links?: LinkUncheckedCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestUncheckedCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicUncheckedCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    show?: ShowUpdateOneRequiredWithoutAiShowNoteNestedInput
    summary?: AiSummaryEntryUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    show_number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    summary?: AiSummaryEntryUncheckedUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUncheckedUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUncheckedUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUncheckedUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUncheckedUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteCreateManyInput = {
    id?: number
    show_number: number
    title: string
    description: string
    provider?: string
  }

  export type AiShowNoteUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type AiShowNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    show_number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type AiSummaryEntryCreateInput = {
    time: string
    text: string
    description?: string | null
    aiShowNote: AiShowNoteCreateNestedOneWithoutSummaryInput
  }

  export type AiSummaryEntryUncheckedCreateInput = {
    id?: number
    time: string
    text: string
    description?: string | null
    showNote: number
  }

  export type AiSummaryEntryUpdateInput = {
    time?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiShowNote?: AiShowNoteUpdateOneRequiredWithoutSummaryNestedInput
  }

  export type AiSummaryEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type AiSummaryEntryCreateManyInput = {
    id?: number
    time: string
    text: string
    description?: string | null
    showNote: number
  }

  export type AiSummaryEntryUpdateManyMutationInput = {
    time?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiSummaryEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type AiTweetCreateInput = {
    content: string
    aiShowNote: AiShowNoteCreateNestedOneWithoutTweetsInput
  }

  export type AiTweetUncheckedCreateInput = {
    id?: number
    content: string
    showNote: number
  }

  export type AiTweetUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    aiShowNote?: AiShowNoteUpdateOneRequiredWithoutTweetsNestedInput
  }

  export type AiTweetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type AiTweetCreateManyInput = {
    id?: number
    content: string
    showNote: number
  }

  export type AiTweetUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type AiTweetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type LinkCreateInput = {
    name: string
    url: string
    timestamp?: string | null
    aiShowNote: AiShowNoteCreateNestedOneWithoutLinksInput
  }

  export type LinkUncheckedCreateInput = {
    id?: number
    name: string
    url: string
    timestamp?: string | null
    showNote: number
  }

  export type LinkUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
    aiShowNote?: AiShowNoteUpdateOneRequiredWithoutLinksNestedInput
  }

  export type LinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type LinkCreateManyInput = {
    id?: number
    name: string
    url: string
    timestamp?: string | null
    showNote: number
  }

  export type LinkUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type AiGuestCreateInput = {
    name: string
    aiShowNote: AiShowNoteCreateNestedOneWithoutGuestsInput
  }

  export type AiGuestUncheckedCreateInput = {
    id?: number
    name: string
    showNote: number
  }

  export type AiGuestUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    aiShowNote?: AiShowNoteUpdateOneRequiredWithoutGuestsNestedInput
  }

  export type AiGuestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type AiGuestCreateManyInput = {
    id?: number
    name: string
    showNote: number
  }

  export type AiGuestUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AiGuestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type TopicCreateInput = {
    name: string
    aiShowNote: AiShowNoteCreateNestedOneWithoutTopicsInput
  }

  export type TopicUncheckedCreateInput = {
    id?: number
    name: string
    showNote: number
  }

  export type TopicUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    aiShowNote?: AiShowNoteUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type TopicCreateManyInput = {
    id?: number
    name: string
    showNote: number
  }

  export type TopicUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    showNote?: IntFieldUpdateOperationsInput | number
  }

  export type VideoCreateInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    published_at: Date | string
    thumbnail: string
    slug: string
    playlists?: PlaylistOnVideoCreateNestedManyWithoutVideoInput
    shows?: ShowVideoCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    published_at: Date | string
    thumbnail: string
    slug: string
    playlists?: PlaylistOnVideoUncheckedCreateNestedManyWithoutVideoInput
    shows?: ShowVideoUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    published_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    playlists?: PlaylistOnVideoUpdateManyWithoutVideoNestedInput
    shows?: ShowVideoUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    published_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    playlists?: PlaylistOnVideoUncheckedUpdateManyWithoutVideoNestedInput
    shows?: ShowVideoUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type VideoCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    published_at: Date | string
    thumbnail: string
    slug: string
  }

  export type VideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    published_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    published_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistCreateInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    slug: string
    unlisted?: boolean | null
    videos?: PlaylistOnVideoCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    slug: string
    unlisted?: boolean | null
    videos?: PlaylistOnVideoUncheckedCreateNestedManyWithoutPlaylistInput
  }

  export type PlaylistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    unlisted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    videos?: PlaylistOnVideoUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    unlisted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    videos?: PlaylistOnVideoUncheckedUpdateManyWithoutPlaylistNestedInput
  }

  export type PlaylistCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    slug: string
    unlisted?: boolean | null
  }

  export type PlaylistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    unlisted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PlaylistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    unlisted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PlaylistOnVideoCreateInput = {
    order: number
    video: VideoCreateNestedOneWithoutPlaylistsInput
    playlist: PlaylistCreateNestedOneWithoutVideosInput
  }

  export type PlaylistOnVideoUncheckedCreateInput = {
    video_id: string
    playlist_id: string
    order: number
  }

  export type PlaylistOnVideoUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    video?: VideoUpdateOneRequiredWithoutPlaylistsNestedInput
    playlist?: PlaylistUpdateOneRequiredWithoutVideosNestedInput
  }

  export type PlaylistOnVideoUncheckedUpdateInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    playlist_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PlaylistOnVideoCreateManyInput = {
    video_id: string
    playlist_id: string
    order: number
  }

  export type PlaylistOnVideoUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PlaylistOnVideoUncheckedUpdateManyInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    playlist_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RemotePlaylistCreateInput = {
    playlist_id: string
    title: string
    videos_count: number
    created_at: Date | string
  }

  export type RemotePlaylistUncheckedCreateInput = {
    playlist_id: string
    title: string
    videos_count: number
    created_at: Date | string
  }

  export type RemotePlaylistUpdateInput = {
    playlist_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videos_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemotePlaylistUncheckedUpdateInput = {
    playlist_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videos_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemotePlaylistCreateManyInput = {
    playlist_id: string
    title: string
    videos_count: number
    created_at: Date | string
  }

  export type RemotePlaylistUpdateManyMutationInput = {
    playlist_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videos_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RemotePlaylistUncheckedUpdateManyInput = {
    playlist_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videos_count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShowVideoCreateInput = {
    show: ShowCreateNestedOneWithoutVideosInput
    video: VideoCreateNestedOneWithoutShowsInput
  }

  export type ShowVideoUncheckedCreateInput = {
    showId: string
    videoId: string
  }

  export type ShowVideoUpdateInput = {
    show?: ShowUpdateOneRequiredWithoutVideosNestedInput
    video?: VideoUpdateOneRequiredWithoutShowsNestedInput
  }

  export type ShowVideoUncheckedUpdateInput = {
    showId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
  }

  export type ShowVideoCreateManyInput = {
    showId: string
    videoId: string
  }

  export type ShowVideoUpdateManyMutationInput = {

  }

  export type ShowVideoUncheckedUpdateManyInput = {
    showId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSubmissionCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    body: string
    created_at?: Date | string
    updated_at?: Date | string
    audio_url?: string | null
    status?: $Enums.UserSubmissionStatus
    submission_type?: $Enums.UserSubmissionType
  }

  export type UserSubmissionUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    body: string
    created_at?: Date | string
    updated_at?: Date | string
    audio_url?: string | null
    status?: $Enums.UserSubmissionStatus
    submission_type?: $Enums.UserSubmissionType
  }

  export type UserSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audio_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserSubmissionStatusFieldUpdateOperationsInput | $Enums.UserSubmissionStatus
    submission_type?: EnumUserSubmissionTypeFieldUpdateOperationsInput | $Enums.UserSubmissionType
  }

  export type UserSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audio_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserSubmissionStatusFieldUpdateOperationsInput | $Enums.UserSubmissionStatus
    submission_type?: EnumUserSubmissionTypeFieldUpdateOperationsInput | $Enums.UserSubmissionType
  }

  export type UserSubmissionCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    body: string
    created_at?: Date | string
    updated_at?: Date | string
    audio_url?: string | null
    status?: $Enums.UserSubmissionStatus
    submission_type?: $Enums.UserSubmissionType
  }

  export type UserSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audio_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserSubmissionStatusFieldUpdateOperationsInput | $Enums.UserSubmissionStatus
    submission_type?: EnumUserSubmissionTypeFieldUpdateOperationsInput | $Enums.UserSubmissionType
  }

  export type UserSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audio_url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserSubmissionStatusFieldUpdateOperationsInput | $Enums.UserSubmissionStatus
    submission_type?: EnumUserSubmissionTypeFieldUpdateOperationsInput | $Enums.UserSubmissionType
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type ShowListRelationFilter = {
    every?: ShowWhereInput
    some?: ShowWhereInput
    none?: ShowWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    avatar_url?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    github_id?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
    theme?: SortOrder
    name?: SortOrder
    twitter?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    github_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    avatar_url?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    github_id?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
    theme?: SortOrder
    name?: SortOrder
    twitter?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    avatar_url?: SortOrder
    created_at?: SortOrder
    email?: SortOrder
    github_id?: SortOrder
    updated_at?: SortOrder
    username?: SortOrder
    theme?: SortOrder
    name?: SortOrder
    twitter?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    github_id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleOrderByRelevanceInput = {
    fields: UserRoleOrderByRelevanceFieldEnum | UserRoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    access_token?: SortOrder
    session_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ip?: SortOrder
    country?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    access_token?: SortOrder
    session_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ip?: SortOrder
    country?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    access_token?: SortOrder
    session_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ip?: SortOrder
    country?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ShowScalarRelationFilter = {
    is?: ShowWhereInput
    isNot?: ShowWhereInput
  }

  export type GuestScalarRelationFilter = {
    is?: GuestWhereInput
    isNot?: GuestWhereInput
  }

  export type TranscriptNullableScalarRelationFilter = {
    is?: TranscriptWhereInput | null
    isNot?: TranscriptWhereInput | null
  }

  export type ShowGuestOrderByRelevanceInput = {
    fields: ShowGuestOrderByRelevanceFieldEnum | ShowGuestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShowGuestShowIdGuestIdCompoundUniqueInput = {
    showId: string
    guestId: string
  }

  export type ShowGuestCountOrderByAggregateInput = {
    id?: SortOrder
    showId?: SortOrder
    guestId?: SortOrder
    transcriptId?: SortOrder
  }

  export type ShowGuestMaxOrderByAggregateInput = {
    id?: SortOrder
    showId?: SortOrder
    guestId?: SortOrder
    transcriptId?: SortOrder
  }

  export type ShowGuestMinOrderByAggregateInput = {
    id?: SortOrder
    showId?: SortOrder
    guestId?: SortOrder
    transcriptId?: SortOrder
  }

  export type SocialLinkListRelationFilter = {
    every?: SocialLinkWhereInput
    some?: SocialLinkWhereInput
    none?: SocialLinkWhereInput
  }

  export type ShowGuestListRelationFilter = {
    every?: ShowGuestWhereInput
    some?: ShowGuestWhereInput
    none?: ShowGuestWhereInput
  }

  export type SocialLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShowGuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuestOrderByRelevanceInput = {
    fields: GuestOrderByRelevanceFieldEnum | GuestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GuestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_slug?: SortOrder
    twitter?: SortOrder
    github?: SortOrder
    of?: SortOrder
    url?: SortOrder
  }

  export type GuestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_slug?: SortOrder
    twitter?: SortOrder
    github?: SortOrder
    of?: SortOrder
    url?: SortOrder
  }

  export type GuestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    name_slug?: SortOrder
    twitter?: SortOrder
    github?: SortOrder
    of?: SortOrder
    url?: SortOrder
  }

  export type SocialLinkOrderByRelevanceInput = {
    fields: SocialLinkOrderByRelevanceFieldEnum | SocialLinkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SocialLinkLinkGuest_idCompoundUniqueInput = {
    link: string
    guest_id: string
  }

  export type SocialLinkCountOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    guest_id?: SortOrder
  }

  export type SocialLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    guest_id?: SortOrder
  }

  export type SocialLinkMinOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    guest_id?: SortOrder
  }

  export type EnumShowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowType | EnumShowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShowType[]
    notIn?: $Enums.ShowType[]
    not?: NestedEnumShowTypeFilter<$PrismaModel> | $Enums.ShowType
  }

  export type AiShowNoteNullableScalarRelationFilter = {
    is?: AiShowNoteWhereInput | null
    isNot?: AiShowNoteWhereInput | null
  }

  export type ShowVideoListRelationFilter = {
    every?: ShowVideoWhereInput
    some?: ShowVideoWhereInput
    none?: ShowVideoWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ShowVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShowOrderByRelevanceInput = {
    fields: ShowOrderByRelevanceFieldEnum | ShowOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShowCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    url?: SortOrder
    youtube_url?: SortOrder
    spotify_id?: SortOrder
    show_notes?: SortOrder
    hash?: SortOrder
    slug?: SortOrder
    md_file?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    show_type?: SortOrder
  }

  export type ShowAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type ShowMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    url?: SortOrder
    youtube_url?: SortOrder
    spotify_id?: SortOrder
    show_notes?: SortOrder
    hash?: SortOrder
    slug?: SortOrder
    md_file?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    show_type?: SortOrder
  }

  export type ShowMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    url?: SortOrder
    youtube_url?: SortOrder
    spotify_id?: SortOrder
    show_notes?: SortOrder
    hash?: SortOrder
    slug?: SortOrder
    md_file?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    show_type?: SortOrder
  }

  export type ShowSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type EnumShowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowType | EnumShowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShowType[]
    notIn?: $Enums.ShowType[]
    not?: NestedEnumShowTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShowTypeFilter<$PrismaModel>
    _max?: NestedEnumShowTypeFilter<$PrismaModel>
  }

  export type TranscriptUtteranceListRelationFilter = {
    every?: TranscriptUtteranceWhereInput
    some?: TranscriptUtteranceWhereInput
    none?: TranscriptUtteranceWhereInput
  }

  export type TranscriptUtteranceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranscriptOrderByRelevanceInput = {
    fields: TranscriptOrderByRelevanceFieldEnum | TranscriptOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TranscriptCountOrderByAggregateInput = {
    id?: SortOrder
    show_number?: SortOrder
  }

  export type TranscriptAvgOrderByAggregateInput = {
    show_number?: SortOrder
  }

  export type TranscriptMaxOrderByAggregateInput = {
    id?: SortOrder
    show_number?: SortOrder
  }

  export type TranscriptMinOrderByAggregateInput = {
    id?: SortOrder
    show_number?: SortOrder
  }

  export type TranscriptSumOrderByAggregateInput = {
    show_number?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TranscriptUtteranceWordListRelationFilter = {
    every?: TranscriptUtteranceWordWhereInput
    some?: TranscriptUtteranceWordWhereInput
    none?: TranscriptUtteranceWordWhereInput
  }

  export type TranscriptScalarRelationFilter = {
    is?: TranscriptWhereInput
    isNot?: TranscriptWhereInput
  }

  export type TranscriptUtteranceWordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TranscriptUtteranceOrderByRelevanceInput = {
    fields: TranscriptUtteranceOrderByRelevanceFieldEnum | TranscriptUtteranceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TranscriptUtteranceCountOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    channel?: SortOrder
    transcript_value?: SortOrder
    speaker?: SortOrder
    speakerName?: SortOrder
    transcriptId?: SortOrder
  }

  export type TranscriptUtteranceAvgOrderByAggregateInput = {
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    channel?: SortOrder
    speaker?: SortOrder
  }

  export type TranscriptUtteranceMaxOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    channel?: SortOrder
    transcript_value?: SortOrder
    speaker?: SortOrder
    speakerName?: SortOrder
    transcriptId?: SortOrder
  }

  export type TranscriptUtteranceMinOrderByAggregateInput = {
    id?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    channel?: SortOrder
    transcript_value?: SortOrder
    speaker?: SortOrder
    speakerName?: SortOrder
    transcriptId?: SortOrder
  }

  export type TranscriptUtteranceSumOrderByAggregateInput = {
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    channel?: SortOrder
    speaker?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TranscriptUtteranceNullableScalarRelationFilter = {
    is?: TranscriptUtteranceWhereInput | null
    isNot?: TranscriptUtteranceWhereInput | null
  }

  export type TranscriptUtteranceWordOrderByRelevanceInput = {
    fields: TranscriptUtteranceWordOrderByRelevanceFieldEnum | TranscriptUtteranceWordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TranscriptUtteranceWordCountOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    speaker?: SortOrder
    speaker_confidence?: SortOrder
    punctuated_word?: SortOrder
    transcriptUtteranceId?: SortOrder
  }

  export type TranscriptUtteranceWordAvgOrderByAggregateInput = {
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    speaker?: SortOrder
    speaker_confidence?: SortOrder
  }

  export type TranscriptUtteranceWordMaxOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    speaker?: SortOrder
    speaker_confidence?: SortOrder
    punctuated_word?: SortOrder
    transcriptUtteranceId?: SortOrder
  }

  export type TranscriptUtteranceWordMinOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    speaker?: SortOrder
    speaker_confidence?: SortOrder
    punctuated_word?: SortOrder
    transcriptUtteranceId?: SortOrder
  }

  export type TranscriptUtteranceWordSumOrderByAggregateInput = {
    start?: SortOrder
    end?: SortOrder
    confidence?: SortOrder
    speaker?: SortOrder
    speaker_confidence?: SortOrder
  }

  export type AiSummaryEntryListRelationFilter = {
    every?: AiSummaryEntryWhereInput
    some?: AiSummaryEntryWhereInput
    none?: AiSummaryEntryWhereInput
  }

  export type AiTweetListRelationFilter = {
    every?: AiTweetWhereInput
    some?: AiTweetWhereInput
    none?: AiTweetWhereInput
  }

  export type LinkListRelationFilter = {
    every?: LinkWhereInput
    some?: LinkWhereInput
    none?: LinkWhereInput
  }

  export type AiGuestListRelationFilter = {
    every?: AiGuestWhereInput
    some?: AiGuestWhereInput
    none?: AiGuestWhereInput
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type AiSummaryEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiTweetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiGuestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiShowNoteOrderByRelevanceInput = {
    fields: AiShowNoteOrderByRelevanceFieldEnum | AiShowNoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AiShowNoteCountOrderByAggregateInput = {
    id?: SortOrder
    show_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    provider?: SortOrder
  }

  export type AiShowNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    show_number?: SortOrder
  }

  export type AiShowNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    show_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    provider?: SortOrder
  }

  export type AiShowNoteMinOrderByAggregateInput = {
    id?: SortOrder
    show_number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    provider?: SortOrder
  }

  export type AiShowNoteSumOrderByAggregateInput = {
    id?: SortOrder
    show_number?: SortOrder
  }

  export type AiShowNoteScalarRelationFilter = {
    is?: AiShowNoteWhereInput
    isNot?: AiShowNoteWhereInput
  }

  export type AiSummaryEntryOrderByRelevanceInput = {
    fields: AiSummaryEntryOrderByRelevanceFieldEnum | AiSummaryEntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AiSummaryEntryCountOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    description?: SortOrder
    showNote?: SortOrder
  }

  export type AiSummaryEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type AiSummaryEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    description?: SortOrder
    showNote?: SortOrder
  }

  export type AiSummaryEntryMinOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    text?: SortOrder
    description?: SortOrder
    showNote?: SortOrder
  }

  export type AiSummaryEntrySumOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type AiTweetOrderByRelevanceInput = {
    fields: AiTweetOrderByRelevanceFieldEnum | AiTweetOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AiTweetCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    showNote?: SortOrder
  }

  export type AiTweetAvgOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type AiTweetMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    showNote?: SortOrder
  }

  export type AiTweetMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    showNote?: SortOrder
  }

  export type AiTweetSumOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type LinkOrderByRelevanceInput = {
    fields: LinkOrderByRelevanceFieldEnum | LinkOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LinkCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    timestamp?: SortOrder
    showNote?: SortOrder
  }

  export type LinkAvgOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type LinkMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    timestamp?: SortOrder
    showNote?: SortOrder
  }

  export type LinkMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    timestamp?: SortOrder
    showNote?: SortOrder
  }

  export type LinkSumOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type AiGuestOrderByRelevanceInput = {
    fields: AiGuestOrderByRelevanceFieldEnum | AiGuestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AiGuestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
  }

  export type AiGuestAvgOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type AiGuestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
  }

  export type AiGuestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
  }

  export type AiGuestSumOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type TopicOrderByRelevanceInput = {
    fields: TopicOrderByRelevanceFieldEnum | TopicOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
  }

  export type TopicAvgOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    showNote?: SortOrder
  }

  export type TopicSumOrderByAggregateInput = {
    id?: SortOrder
    showNote?: SortOrder
  }

  export type PlaylistOnVideoListRelationFilter = {
    every?: PlaylistOnVideoWhereInput
    some?: PlaylistOnVideoWhereInput
    none?: PlaylistOnVideoWhereInput
  }

  export type PlaylistOnVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoOrderByRelevanceInput = {
    fields: VideoOrderByRelevanceFieldEnum | VideoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    published_at?: SortOrder
    thumbnail?: SortOrder
    slug?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    published_at?: SortOrder
    thumbnail?: SortOrder
    slug?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    published_at?: SortOrder
    thumbnail?: SortOrder
    slug?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PlaylistOrderByRelevanceInput = {
    fields: PlaylistOrderByRelevanceFieldEnum | PlaylistOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlaylistCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    slug?: SortOrder
    unlisted?: SortOrder
  }

  export type PlaylistMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    slug?: SortOrder
    unlisted?: SortOrder
  }

  export type PlaylistMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    slug?: SortOrder
    unlisted?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type VideoScalarRelationFilter = {
    is?: VideoWhereInput
    isNot?: VideoWhereInput
  }

  export type PlaylistScalarRelationFilter = {
    is?: PlaylistWhereInput
    isNot?: PlaylistWhereInput
  }

  export type PlaylistOnVideoOrderByRelevanceInput = {
    fields: PlaylistOnVideoOrderByRelevanceFieldEnum | PlaylistOnVideoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlaylistOnVideoVideo_idPlaylist_idCompoundUniqueInput = {
    video_id: string
    playlist_id: string
  }

  export type PlaylistOnVideoCountOrderByAggregateInput = {
    video_id?: SortOrder
    playlist_id?: SortOrder
    order?: SortOrder
  }

  export type PlaylistOnVideoAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PlaylistOnVideoMaxOrderByAggregateInput = {
    video_id?: SortOrder
    playlist_id?: SortOrder
    order?: SortOrder
  }

  export type PlaylistOnVideoMinOrderByAggregateInput = {
    video_id?: SortOrder
    playlist_id?: SortOrder
    order?: SortOrder
  }

  export type PlaylistOnVideoSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RemotePlaylistOrderByRelevanceInput = {
    fields: RemotePlaylistOrderByRelevanceFieldEnum | RemotePlaylistOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RemotePlaylistCountOrderByAggregateInput = {
    playlist_id?: SortOrder
    title?: SortOrder
    videos_count?: SortOrder
    created_at?: SortOrder
  }

  export type RemotePlaylistAvgOrderByAggregateInput = {
    videos_count?: SortOrder
  }

  export type RemotePlaylistMaxOrderByAggregateInput = {
    playlist_id?: SortOrder
    title?: SortOrder
    videos_count?: SortOrder
    created_at?: SortOrder
  }

  export type RemotePlaylistMinOrderByAggregateInput = {
    playlist_id?: SortOrder
    title?: SortOrder
    videos_count?: SortOrder
    created_at?: SortOrder
  }

  export type RemotePlaylistSumOrderByAggregateInput = {
    videos_count?: SortOrder
  }

  export type ShowVideoOrderByRelevanceInput = {
    fields: ShowVideoOrderByRelevanceFieldEnum | ShowVideoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShowVideoShowIdVideoIdCompoundUniqueInput = {
    showId: string
    videoId: string
  }

  export type ShowVideoCountOrderByAggregateInput = {
    showId?: SortOrder
    videoId?: SortOrder
  }

  export type ShowVideoMaxOrderByAggregateInput = {
    showId?: SortOrder
    videoId?: SortOrder
  }

  export type ShowVideoMinOrderByAggregateInput = {
    showId?: SortOrder
    videoId?: SortOrder
  }

  export type EnumUserSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserSubmissionStatus | EnumUserSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserSubmissionStatus[]
    notIn?: $Enums.UserSubmissionStatus[]
    not?: NestedEnumUserSubmissionStatusFilter<$PrismaModel> | $Enums.UserSubmissionStatus
  }

  export type EnumUserSubmissionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserSubmissionType | EnumUserSubmissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserSubmissionType[]
    notIn?: $Enums.UserSubmissionType[]
    not?: NestedEnumUserSubmissionTypeFilter<$PrismaModel> | $Enums.UserSubmissionType
  }

  export type UserSubmissionOrderByRelevanceInput = {
    fields: UserSubmissionOrderByRelevanceFieldEnum | UserSubmissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    audio_url?: SortOrder
    status?: SortOrder
    submission_type?: SortOrder
  }

  export type UserSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    audio_url?: SortOrder
    status?: SortOrder
    submission_type?: SortOrder
  }

  export type UserSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    body?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    audio_url?: SortOrder
    status?: SortOrder
    submission_type?: SortOrder
  }

  export type EnumUserSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserSubmissionStatus | EnumUserSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserSubmissionStatus[]
    notIn?: $Enums.UserSubmissionStatus[]
    not?: NestedEnumUserSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserSubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumUserSubmissionStatusFilter<$PrismaModel>
  }

  export type EnumUserSubmissionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserSubmissionType | EnumUserSubmissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserSubmissionType[]
    notIn?: $Enums.UserSubmissionType[]
    not?: NestedEnumUserSubmissionTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserSubmissionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserSubmissionTypeFilter<$PrismaModel>
    _max?: NestedEnumUserSubmissionTypeFilter<$PrismaModel>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type ShowCreateNestedManyWithoutHostsInput = {
    create?: XOR<ShowCreateWithoutHostsInput, ShowUncheckedCreateWithoutHostsInput> | ShowCreateWithoutHostsInput[] | ShowUncheckedCreateWithoutHostsInput[]
    connectOrCreate?: ShowCreateOrConnectWithoutHostsInput | ShowCreateOrConnectWithoutHostsInput[]
    connect?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type ShowUncheckedCreateNestedManyWithoutHostsInput = {
    create?: XOR<ShowCreateWithoutHostsInput, ShowUncheckedCreateWithoutHostsInput> | ShowCreateWithoutHostsInput[] | ShowUncheckedCreateWithoutHostsInput[]
    connectOrCreate?: ShowCreateOrConnectWithoutHostsInput | ShowCreateOrConnectWithoutHostsInput[]
    connect?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type ShowUpdateManyWithoutHostsNestedInput = {
    create?: XOR<ShowCreateWithoutHostsInput, ShowUncheckedCreateWithoutHostsInput> | ShowCreateWithoutHostsInput[] | ShowUncheckedCreateWithoutHostsInput[]
    connectOrCreate?: ShowCreateOrConnectWithoutHostsInput | ShowCreateOrConnectWithoutHostsInput[]
    upsert?: ShowUpsertWithWhereUniqueWithoutHostsInput | ShowUpsertWithWhereUniqueWithoutHostsInput[]
    set?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
    disconnect?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
    delete?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
    connect?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
    update?: ShowUpdateWithWhereUniqueWithoutHostsInput | ShowUpdateWithWhereUniqueWithoutHostsInput[]
    updateMany?: ShowUpdateManyWithWhereWithoutHostsInput | ShowUpdateManyWithWhereWithoutHostsInput[]
    deleteMany?: ShowScalarWhereInput | ShowScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type ShowUncheckedUpdateManyWithoutHostsNestedInput = {
    create?: XOR<ShowCreateWithoutHostsInput, ShowUncheckedCreateWithoutHostsInput> | ShowCreateWithoutHostsInput[] | ShowUncheckedCreateWithoutHostsInput[]
    connectOrCreate?: ShowCreateOrConnectWithoutHostsInput | ShowCreateOrConnectWithoutHostsInput[]
    upsert?: ShowUpsertWithWhereUniqueWithoutHostsInput | ShowUpsertWithWhereUniqueWithoutHostsInput[]
    set?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
    disconnect?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
    delete?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
    connect?: ShowWhereUniqueInput | ShowWhereUniqueInput[]
    update?: ShowUpdateWithWhereUniqueWithoutHostsInput | ShowUpdateWithWhereUniqueWithoutHostsInput[]
    updateMany?: ShowUpdateManyWithWhereWithoutHostsInput | ShowUpdateManyWithWhereWithoutHostsInput[]
    deleteMany?: ShowScalarWhereInput | ShowScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserCreateNestedOneWithoutSessionInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSessionNestedInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    upsert?: UserUpsertWithoutSessionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionInput, UserUpdateWithoutSessionInput>, UserUncheckedUpdateWithoutSessionInput>
  }

  export type ShowCreateNestedOneWithoutGuestsInput = {
    create?: XOR<ShowCreateWithoutGuestsInput, ShowUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: ShowCreateOrConnectWithoutGuestsInput
    connect?: ShowWhereUniqueInput
  }

  export type GuestCreateNestedOneWithoutShowsInput = {
    create?: XOR<GuestCreateWithoutShowsInput, GuestUncheckedCreateWithoutShowsInput>
    connectOrCreate?: GuestCreateOrConnectWithoutShowsInput
    connect?: GuestWhereUniqueInput
  }

  export type TranscriptCreateNestedOneWithoutShowGuestInput = {
    create?: XOR<TranscriptCreateWithoutShowGuestInput, TranscriptUncheckedCreateWithoutShowGuestInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutShowGuestInput
    connect?: TranscriptWhereUniqueInput
  }

  export type ShowUpdateOneRequiredWithoutGuestsNestedInput = {
    create?: XOR<ShowCreateWithoutGuestsInput, ShowUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: ShowCreateOrConnectWithoutGuestsInput
    upsert?: ShowUpsertWithoutGuestsInput
    connect?: ShowWhereUniqueInput
    update?: XOR<XOR<ShowUpdateToOneWithWhereWithoutGuestsInput, ShowUpdateWithoutGuestsInput>, ShowUncheckedUpdateWithoutGuestsInput>
  }

  export type GuestUpdateOneRequiredWithoutShowsNestedInput = {
    create?: XOR<GuestCreateWithoutShowsInput, GuestUncheckedCreateWithoutShowsInput>
    connectOrCreate?: GuestCreateOrConnectWithoutShowsInput
    upsert?: GuestUpsertWithoutShowsInput
    connect?: GuestWhereUniqueInput
    update?: XOR<XOR<GuestUpdateToOneWithWhereWithoutShowsInput, GuestUpdateWithoutShowsInput>, GuestUncheckedUpdateWithoutShowsInput>
  }

  export type TranscriptUpdateOneWithoutShowGuestNestedInput = {
    create?: XOR<TranscriptCreateWithoutShowGuestInput, TranscriptUncheckedCreateWithoutShowGuestInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutShowGuestInput
    upsert?: TranscriptUpsertWithoutShowGuestInput
    disconnect?: TranscriptWhereInput | boolean
    delete?: TranscriptWhereInput | boolean
    connect?: TranscriptWhereUniqueInput
    update?: XOR<XOR<TranscriptUpdateToOneWithWhereWithoutShowGuestInput, TranscriptUpdateWithoutShowGuestInput>, TranscriptUncheckedUpdateWithoutShowGuestInput>
  }

  export type SocialLinkCreateNestedManyWithoutGuestInput = {
    create?: XOR<SocialLinkCreateWithoutGuestInput, SocialLinkUncheckedCreateWithoutGuestInput> | SocialLinkCreateWithoutGuestInput[] | SocialLinkUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutGuestInput | SocialLinkCreateOrConnectWithoutGuestInput[]
    createMany?: SocialLinkCreateManyGuestInputEnvelope
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
  }

  export type ShowGuestCreateNestedManyWithoutGuestInput = {
    create?: XOR<ShowGuestCreateWithoutGuestInput, ShowGuestUncheckedCreateWithoutGuestInput> | ShowGuestCreateWithoutGuestInput[] | ShowGuestUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutGuestInput | ShowGuestCreateOrConnectWithoutGuestInput[]
    createMany?: ShowGuestCreateManyGuestInputEnvelope
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
  }

  export type SocialLinkUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<SocialLinkCreateWithoutGuestInput, SocialLinkUncheckedCreateWithoutGuestInput> | SocialLinkCreateWithoutGuestInput[] | SocialLinkUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutGuestInput | SocialLinkCreateOrConnectWithoutGuestInput[]
    createMany?: SocialLinkCreateManyGuestInputEnvelope
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
  }

  export type ShowGuestUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<ShowGuestCreateWithoutGuestInput, ShowGuestUncheckedCreateWithoutGuestInput> | ShowGuestCreateWithoutGuestInput[] | ShowGuestUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutGuestInput | ShowGuestCreateOrConnectWithoutGuestInput[]
    createMany?: ShowGuestCreateManyGuestInputEnvelope
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
  }

  export type SocialLinkUpdateManyWithoutGuestNestedInput = {
    create?: XOR<SocialLinkCreateWithoutGuestInput, SocialLinkUncheckedCreateWithoutGuestInput> | SocialLinkCreateWithoutGuestInput[] | SocialLinkUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutGuestInput | SocialLinkCreateOrConnectWithoutGuestInput[]
    upsert?: SocialLinkUpsertWithWhereUniqueWithoutGuestInput | SocialLinkUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: SocialLinkCreateManyGuestInputEnvelope
    set?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    disconnect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    delete?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    update?: SocialLinkUpdateWithWhereUniqueWithoutGuestInput | SocialLinkUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: SocialLinkUpdateManyWithWhereWithoutGuestInput | SocialLinkUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
  }

  export type ShowGuestUpdateManyWithoutGuestNestedInput = {
    create?: XOR<ShowGuestCreateWithoutGuestInput, ShowGuestUncheckedCreateWithoutGuestInput> | ShowGuestCreateWithoutGuestInput[] | ShowGuestUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutGuestInput | ShowGuestCreateOrConnectWithoutGuestInput[]
    upsert?: ShowGuestUpsertWithWhereUniqueWithoutGuestInput | ShowGuestUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: ShowGuestCreateManyGuestInputEnvelope
    set?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    disconnect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    delete?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    update?: ShowGuestUpdateWithWhereUniqueWithoutGuestInput | ShowGuestUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: ShowGuestUpdateManyWithWhereWithoutGuestInput | ShowGuestUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: ShowGuestScalarWhereInput | ShowGuestScalarWhereInput[]
  }

  export type SocialLinkUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<SocialLinkCreateWithoutGuestInput, SocialLinkUncheckedCreateWithoutGuestInput> | SocialLinkCreateWithoutGuestInput[] | SocialLinkUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: SocialLinkCreateOrConnectWithoutGuestInput | SocialLinkCreateOrConnectWithoutGuestInput[]
    upsert?: SocialLinkUpsertWithWhereUniqueWithoutGuestInput | SocialLinkUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: SocialLinkCreateManyGuestInputEnvelope
    set?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    disconnect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    delete?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    connect?: SocialLinkWhereUniqueInput | SocialLinkWhereUniqueInput[]
    update?: SocialLinkUpdateWithWhereUniqueWithoutGuestInput | SocialLinkUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: SocialLinkUpdateManyWithWhereWithoutGuestInput | SocialLinkUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
  }

  export type ShowGuestUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<ShowGuestCreateWithoutGuestInput, ShowGuestUncheckedCreateWithoutGuestInput> | ShowGuestCreateWithoutGuestInput[] | ShowGuestUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutGuestInput | ShowGuestCreateOrConnectWithoutGuestInput[]
    upsert?: ShowGuestUpsertWithWhereUniqueWithoutGuestInput | ShowGuestUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: ShowGuestCreateManyGuestInputEnvelope
    set?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    disconnect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    delete?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    update?: ShowGuestUpdateWithWhereUniqueWithoutGuestInput | ShowGuestUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: ShowGuestUpdateManyWithWhereWithoutGuestInput | ShowGuestUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: ShowGuestScalarWhereInput | ShowGuestScalarWhereInput[]
  }

  export type GuestCreateNestedOneWithoutSocialInput = {
    create?: XOR<GuestCreateWithoutSocialInput, GuestUncheckedCreateWithoutSocialInput>
    connectOrCreate?: GuestCreateOrConnectWithoutSocialInput
    connect?: GuestWhereUniqueInput
  }

  export type GuestUpdateOneRequiredWithoutSocialNestedInput = {
    create?: XOR<GuestCreateWithoutSocialInput, GuestUncheckedCreateWithoutSocialInput>
    connectOrCreate?: GuestCreateOrConnectWithoutSocialInput
    upsert?: GuestUpsertWithoutSocialInput
    connect?: GuestWhereUniqueInput
    update?: XOR<XOR<GuestUpdateToOneWithWhereWithoutSocialInput, GuestUpdateWithoutSocialInput>, GuestUncheckedUpdateWithoutSocialInput>
  }

  export type ShowGuestCreateNestedManyWithoutShowInput = {
    create?: XOR<ShowGuestCreateWithoutShowInput, ShowGuestUncheckedCreateWithoutShowInput> | ShowGuestCreateWithoutShowInput[] | ShowGuestUncheckedCreateWithoutShowInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutShowInput | ShowGuestCreateOrConnectWithoutShowInput[]
    createMany?: ShowGuestCreateManyShowInputEnvelope
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
  }

  export type TranscriptCreateNestedOneWithoutShowInput = {
    create?: XOR<TranscriptCreateWithoutShowInput, TranscriptUncheckedCreateWithoutShowInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutShowInput
    connect?: TranscriptWhereUniqueInput
  }

  export type AiShowNoteCreateNestedOneWithoutShowInput = {
    create?: XOR<AiShowNoteCreateWithoutShowInput, AiShowNoteUncheckedCreateWithoutShowInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutShowInput
    connect?: AiShowNoteWhereUniqueInput
  }

  export type ShowVideoCreateNestedManyWithoutShowInput = {
    create?: XOR<ShowVideoCreateWithoutShowInput, ShowVideoUncheckedCreateWithoutShowInput> | ShowVideoCreateWithoutShowInput[] | ShowVideoUncheckedCreateWithoutShowInput[]
    connectOrCreate?: ShowVideoCreateOrConnectWithoutShowInput | ShowVideoCreateOrConnectWithoutShowInput[]
    createMany?: ShowVideoCreateManyShowInputEnvelope
    connect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutHostedShowsInput = {
    create?: XOR<UserCreateWithoutHostedShowsInput, UserUncheckedCreateWithoutHostedShowsInput> | UserCreateWithoutHostedShowsInput[] | UserUncheckedCreateWithoutHostedShowsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHostedShowsInput | UserCreateOrConnectWithoutHostedShowsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ShowGuestUncheckedCreateNestedManyWithoutShowInput = {
    create?: XOR<ShowGuestCreateWithoutShowInput, ShowGuestUncheckedCreateWithoutShowInput> | ShowGuestCreateWithoutShowInput[] | ShowGuestUncheckedCreateWithoutShowInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutShowInput | ShowGuestCreateOrConnectWithoutShowInput[]
    createMany?: ShowGuestCreateManyShowInputEnvelope
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
  }

  export type TranscriptUncheckedCreateNestedOneWithoutShowInput = {
    create?: XOR<TranscriptCreateWithoutShowInput, TranscriptUncheckedCreateWithoutShowInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutShowInput
    connect?: TranscriptWhereUniqueInput
  }

  export type AiShowNoteUncheckedCreateNestedOneWithoutShowInput = {
    create?: XOR<AiShowNoteCreateWithoutShowInput, AiShowNoteUncheckedCreateWithoutShowInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutShowInput
    connect?: AiShowNoteWhereUniqueInput
  }

  export type ShowVideoUncheckedCreateNestedManyWithoutShowInput = {
    create?: XOR<ShowVideoCreateWithoutShowInput, ShowVideoUncheckedCreateWithoutShowInput> | ShowVideoCreateWithoutShowInput[] | ShowVideoUncheckedCreateWithoutShowInput[]
    connectOrCreate?: ShowVideoCreateOrConnectWithoutShowInput | ShowVideoCreateOrConnectWithoutShowInput[]
    createMany?: ShowVideoCreateManyShowInputEnvelope
    connect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutHostedShowsInput = {
    create?: XOR<UserCreateWithoutHostedShowsInput, UserUncheckedCreateWithoutHostedShowsInput> | UserCreateWithoutHostedShowsInput[] | UserUncheckedCreateWithoutHostedShowsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHostedShowsInput | UserCreateOrConnectWithoutHostedShowsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EnumShowTypeFieldUpdateOperationsInput = {
    set?: $Enums.ShowType
  }

  export type ShowGuestUpdateManyWithoutShowNestedInput = {
    create?: XOR<ShowGuestCreateWithoutShowInput, ShowGuestUncheckedCreateWithoutShowInput> | ShowGuestCreateWithoutShowInput[] | ShowGuestUncheckedCreateWithoutShowInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutShowInput | ShowGuestCreateOrConnectWithoutShowInput[]
    upsert?: ShowGuestUpsertWithWhereUniqueWithoutShowInput | ShowGuestUpsertWithWhereUniqueWithoutShowInput[]
    createMany?: ShowGuestCreateManyShowInputEnvelope
    set?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    disconnect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    delete?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    update?: ShowGuestUpdateWithWhereUniqueWithoutShowInput | ShowGuestUpdateWithWhereUniqueWithoutShowInput[]
    updateMany?: ShowGuestUpdateManyWithWhereWithoutShowInput | ShowGuestUpdateManyWithWhereWithoutShowInput[]
    deleteMany?: ShowGuestScalarWhereInput | ShowGuestScalarWhereInput[]
  }

  export type TranscriptUpdateOneWithoutShowNestedInput = {
    create?: XOR<TranscriptCreateWithoutShowInput, TranscriptUncheckedCreateWithoutShowInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutShowInput
    upsert?: TranscriptUpsertWithoutShowInput
    disconnect?: TranscriptWhereInput | boolean
    delete?: TranscriptWhereInput | boolean
    connect?: TranscriptWhereUniqueInput
    update?: XOR<XOR<TranscriptUpdateToOneWithWhereWithoutShowInput, TranscriptUpdateWithoutShowInput>, TranscriptUncheckedUpdateWithoutShowInput>
  }

  export type AiShowNoteUpdateOneWithoutShowNestedInput = {
    create?: XOR<AiShowNoteCreateWithoutShowInput, AiShowNoteUncheckedCreateWithoutShowInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutShowInput
    upsert?: AiShowNoteUpsertWithoutShowInput
    disconnect?: AiShowNoteWhereInput | boolean
    delete?: AiShowNoteWhereInput | boolean
    connect?: AiShowNoteWhereUniqueInput
    update?: XOR<XOR<AiShowNoteUpdateToOneWithWhereWithoutShowInput, AiShowNoteUpdateWithoutShowInput>, AiShowNoteUncheckedUpdateWithoutShowInput>
  }

  export type ShowVideoUpdateManyWithoutShowNestedInput = {
    create?: XOR<ShowVideoCreateWithoutShowInput, ShowVideoUncheckedCreateWithoutShowInput> | ShowVideoCreateWithoutShowInput[] | ShowVideoUncheckedCreateWithoutShowInput[]
    connectOrCreate?: ShowVideoCreateOrConnectWithoutShowInput | ShowVideoCreateOrConnectWithoutShowInput[]
    upsert?: ShowVideoUpsertWithWhereUniqueWithoutShowInput | ShowVideoUpsertWithWhereUniqueWithoutShowInput[]
    createMany?: ShowVideoCreateManyShowInputEnvelope
    set?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    disconnect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    delete?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    connect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    update?: ShowVideoUpdateWithWhereUniqueWithoutShowInput | ShowVideoUpdateWithWhereUniqueWithoutShowInput[]
    updateMany?: ShowVideoUpdateManyWithWhereWithoutShowInput | ShowVideoUpdateManyWithWhereWithoutShowInput[]
    deleteMany?: ShowVideoScalarWhereInput | ShowVideoScalarWhereInput[]
  }

  export type UserUpdateManyWithoutHostedShowsNestedInput = {
    create?: XOR<UserCreateWithoutHostedShowsInput, UserUncheckedCreateWithoutHostedShowsInput> | UserCreateWithoutHostedShowsInput[] | UserUncheckedCreateWithoutHostedShowsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHostedShowsInput | UserCreateOrConnectWithoutHostedShowsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutHostedShowsInput | UserUpsertWithWhereUniqueWithoutHostedShowsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutHostedShowsInput | UserUpdateWithWhereUniqueWithoutHostedShowsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutHostedShowsInput | UserUpdateManyWithWhereWithoutHostedShowsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ShowGuestUncheckedUpdateManyWithoutShowNestedInput = {
    create?: XOR<ShowGuestCreateWithoutShowInput, ShowGuestUncheckedCreateWithoutShowInput> | ShowGuestCreateWithoutShowInput[] | ShowGuestUncheckedCreateWithoutShowInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutShowInput | ShowGuestCreateOrConnectWithoutShowInput[]
    upsert?: ShowGuestUpsertWithWhereUniqueWithoutShowInput | ShowGuestUpsertWithWhereUniqueWithoutShowInput[]
    createMany?: ShowGuestCreateManyShowInputEnvelope
    set?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    disconnect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    delete?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    update?: ShowGuestUpdateWithWhereUniqueWithoutShowInput | ShowGuestUpdateWithWhereUniqueWithoutShowInput[]
    updateMany?: ShowGuestUpdateManyWithWhereWithoutShowInput | ShowGuestUpdateManyWithWhereWithoutShowInput[]
    deleteMany?: ShowGuestScalarWhereInput | ShowGuestScalarWhereInput[]
  }

  export type TranscriptUncheckedUpdateOneWithoutShowNestedInput = {
    create?: XOR<TranscriptCreateWithoutShowInput, TranscriptUncheckedCreateWithoutShowInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutShowInput
    upsert?: TranscriptUpsertWithoutShowInput
    disconnect?: TranscriptWhereInput | boolean
    delete?: TranscriptWhereInput | boolean
    connect?: TranscriptWhereUniqueInput
    update?: XOR<XOR<TranscriptUpdateToOneWithWhereWithoutShowInput, TranscriptUpdateWithoutShowInput>, TranscriptUncheckedUpdateWithoutShowInput>
  }

  export type AiShowNoteUncheckedUpdateOneWithoutShowNestedInput = {
    create?: XOR<AiShowNoteCreateWithoutShowInput, AiShowNoteUncheckedCreateWithoutShowInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutShowInput
    upsert?: AiShowNoteUpsertWithoutShowInput
    disconnect?: AiShowNoteWhereInput | boolean
    delete?: AiShowNoteWhereInput | boolean
    connect?: AiShowNoteWhereUniqueInput
    update?: XOR<XOR<AiShowNoteUpdateToOneWithWhereWithoutShowInput, AiShowNoteUpdateWithoutShowInput>, AiShowNoteUncheckedUpdateWithoutShowInput>
  }

  export type ShowVideoUncheckedUpdateManyWithoutShowNestedInput = {
    create?: XOR<ShowVideoCreateWithoutShowInput, ShowVideoUncheckedCreateWithoutShowInput> | ShowVideoCreateWithoutShowInput[] | ShowVideoUncheckedCreateWithoutShowInput[]
    connectOrCreate?: ShowVideoCreateOrConnectWithoutShowInput | ShowVideoCreateOrConnectWithoutShowInput[]
    upsert?: ShowVideoUpsertWithWhereUniqueWithoutShowInput | ShowVideoUpsertWithWhereUniqueWithoutShowInput[]
    createMany?: ShowVideoCreateManyShowInputEnvelope
    set?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    disconnect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    delete?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    connect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    update?: ShowVideoUpdateWithWhereUniqueWithoutShowInput | ShowVideoUpdateWithWhereUniqueWithoutShowInput[]
    updateMany?: ShowVideoUpdateManyWithWhereWithoutShowInput | ShowVideoUpdateManyWithWhereWithoutShowInput[]
    deleteMany?: ShowVideoScalarWhereInput | ShowVideoScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutHostedShowsNestedInput = {
    create?: XOR<UserCreateWithoutHostedShowsInput, UserUncheckedCreateWithoutHostedShowsInput> | UserCreateWithoutHostedShowsInput[] | UserUncheckedCreateWithoutHostedShowsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutHostedShowsInput | UserCreateOrConnectWithoutHostedShowsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutHostedShowsInput | UserUpsertWithWhereUniqueWithoutHostedShowsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutHostedShowsInput | UserUpdateWithWhereUniqueWithoutHostedShowsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutHostedShowsInput | UserUpdateManyWithWhereWithoutHostedShowsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ShowCreateNestedOneWithoutTranscriptInput = {
    create?: XOR<ShowCreateWithoutTranscriptInput, ShowUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: ShowCreateOrConnectWithoutTranscriptInput
    connect?: ShowWhereUniqueInput
  }

  export type TranscriptUtteranceCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<TranscriptUtteranceCreateWithoutTranscriptInput, TranscriptUtteranceUncheckedCreateWithoutTranscriptInput> | TranscriptUtteranceCreateWithoutTranscriptInput[] | TranscriptUtteranceUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: TranscriptUtteranceCreateOrConnectWithoutTranscriptInput | TranscriptUtteranceCreateOrConnectWithoutTranscriptInput[]
    createMany?: TranscriptUtteranceCreateManyTranscriptInputEnvelope
    connect?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
  }

  export type ShowGuestCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<ShowGuestCreateWithoutTranscriptInput, ShowGuestUncheckedCreateWithoutTranscriptInput> | ShowGuestCreateWithoutTranscriptInput[] | ShowGuestUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutTranscriptInput | ShowGuestCreateOrConnectWithoutTranscriptInput[]
    createMany?: ShowGuestCreateManyTranscriptInputEnvelope
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
  }

  export type TranscriptUtteranceUncheckedCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<TranscriptUtteranceCreateWithoutTranscriptInput, TranscriptUtteranceUncheckedCreateWithoutTranscriptInput> | TranscriptUtteranceCreateWithoutTranscriptInput[] | TranscriptUtteranceUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: TranscriptUtteranceCreateOrConnectWithoutTranscriptInput | TranscriptUtteranceCreateOrConnectWithoutTranscriptInput[]
    createMany?: TranscriptUtteranceCreateManyTranscriptInputEnvelope
    connect?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
  }

  export type ShowGuestUncheckedCreateNestedManyWithoutTranscriptInput = {
    create?: XOR<ShowGuestCreateWithoutTranscriptInput, ShowGuestUncheckedCreateWithoutTranscriptInput> | ShowGuestCreateWithoutTranscriptInput[] | ShowGuestUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutTranscriptInput | ShowGuestCreateOrConnectWithoutTranscriptInput[]
    createMany?: ShowGuestCreateManyTranscriptInputEnvelope
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
  }

  export type ShowUpdateOneRequiredWithoutTranscriptNestedInput = {
    create?: XOR<ShowCreateWithoutTranscriptInput, ShowUncheckedCreateWithoutTranscriptInput>
    connectOrCreate?: ShowCreateOrConnectWithoutTranscriptInput
    upsert?: ShowUpsertWithoutTranscriptInput
    connect?: ShowWhereUniqueInput
    update?: XOR<XOR<ShowUpdateToOneWithWhereWithoutTranscriptInput, ShowUpdateWithoutTranscriptInput>, ShowUncheckedUpdateWithoutTranscriptInput>
  }

  export type TranscriptUtteranceUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<TranscriptUtteranceCreateWithoutTranscriptInput, TranscriptUtteranceUncheckedCreateWithoutTranscriptInput> | TranscriptUtteranceCreateWithoutTranscriptInput[] | TranscriptUtteranceUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: TranscriptUtteranceCreateOrConnectWithoutTranscriptInput | TranscriptUtteranceCreateOrConnectWithoutTranscriptInput[]
    upsert?: TranscriptUtteranceUpsertWithWhereUniqueWithoutTranscriptInput | TranscriptUtteranceUpsertWithWhereUniqueWithoutTranscriptInput[]
    createMany?: TranscriptUtteranceCreateManyTranscriptInputEnvelope
    set?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
    disconnect?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
    delete?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
    connect?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
    update?: TranscriptUtteranceUpdateWithWhereUniqueWithoutTranscriptInput | TranscriptUtteranceUpdateWithWhereUniqueWithoutTranscriptInput[]
    updateMany?: TranscriptUtteranceUpdateManyWithWhereWithoutTranscriptInput | TranscriptUtteranceUpdateManyWithWhereWithoutTranscriptInput[]
    deleteMany?: TranscriptUtteranceScalarWhereInput | TranscriptUtteranceScalarWhereInput[]
  }

  export type ShowGuestUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<ShowGuestCreateWithoutTranscriptInput, ShowGuestUncheckedCreateWithoutTranscriptInput> | ShowGuestCreateWithoutTranscriptInput[] | ShowGuestUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutTranscriptInput | ShowGuestCreateOrConnectWithoutTranscriptInput[]
    upsert?: ShowGuestUpsertWithWhereUniqueWithoutTranscriptInput | ShowGuestUpsertWithWhereUniqueWithoutTranscriptInput[]
    createMany?: ShowGuestCreateManyTranscriptInputEnvelope
    set?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    disconnect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    delete?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    update?: ShowGuestUpdateWithWhereUniqueWithoutTranscriptInput | ShowGuestUpdateWithWhereUniqueWithoutTranscriptInput[]
    updateMany?: ShowGuestUpdateManyWithWhereWithoutTranscriptInput | ShowGuestUpdateManyWithWhereWithoutTranscriptInput[]
    deleteMany?: ShowGuestScalarWhereInput | ShowGuestScalarWhereInput[]
  }

  export type TranscriptUtteranceUncheckedUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<TranscriptUtteranceCreateWithoutTranscriptInput, TranscriptUtteranceUncheckedCreateWithoutTranscriptInput> | TranscriptUtteranceCreateWithoutTranscriptInput[] | TranscriptUtteranceUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: TranscriptUtteranceCreateOrConnectWithoutTranscriptInput | TranscriptUtteranceCreateOrConnectWithoutTranscriptInput[]
    upsert?: TranscriptUtteranceUpsertWithWhereUniqueWithoutTranscriptInput | TranscriptUtteranceUpsertWithWhereUniqueWithoutTranscriptInput[]
    createMany?: TranscriptUtteranceCreateManyTranscriptInputEnvelope
    set?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
    disconnect?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
    delete?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
    connect?: TranscriptUtteranceWhereUniqueInput | TranscriptUtteranceWhereUniqueInput[]
    update?: TranscriptUtteranceUpdateWithWhereUniqueWithoutTranscriptInput | TranscriptUtteranceUpdateWithWhereUniqueWithoutTranscriptInput[]
    updateMany?: TranscriptUtteranceUpdateManyWithWhereWithoutTranscriptInput | TranscriptUtteranceUpdateManyWithWhereWithoutTranscriptInput[]
    deleteMany?: TranscriptUtteranceScalarWhereInput | TranscriptUtteranceScalarWhereInput[]
  }

  export type ShowGuestUncheckedUpdateManyWithoutTranscriptNestedInput = {
    create?: XOR<ShowGuestCreateWithoutTranscriptInput, ShowGuestUncheckedCreateWithoutTranscriptInput> | ShowGuestCreateWithoutTranscriptInput[] | ShowGuestUncheckedCreateWithoutTranscriptInput[]
    connectOrCreate?: ShowGuestCreateOrConnectWithoutTranscriptInput | ShowGuestCreateOrConnectWithoutTranscriptInput[]
    upsert?: ShowGuestUpsertWithWhereUniqueWithoutTranscriptInput | ShowGuestUpsertWithWhereUniqueWithoutTranscriptInput[]
    createMany?: ShowGuestCreateManyTranscriptInputEnvelope
    set?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    disconnect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    delete?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    connect?: ShowGuestWhereUniqueInput | ShowGuestWhereUniqueInput[]
    update?: ShowGuestUpdateWithWhereUniqueWithoutTranscriptInput | ShowGuestUpdateWithWhereUniqueWithoutTranscriptInput[]
    updateMany?: ShowGuestUpdateManyWithWhereWithoutTranscriptInput | ShowGuestUpdateManyWithWhereWithoutTranscriptInput[]
    deleteMany?: ShowGuestScalarWhereInput | ShowGuestScalarWhereInput[]
  }

  export type TranscriptUtteranceWordCreateNestedManyWithoutTranscriptUtteranceInput = {
    create?: XOR<TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput, TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput> | TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput[] | TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput[]
    connectOrCreate?: TranscriptUtteranceWordCreateOrConnectWithoutTranscriptUtteranceInput | TranscriptUtteranceWordCreateOrConnectWithoutTranscriptUtteranceInput[]
    createMany?: TranscriptUtteranceWordCreateManyTranscriptUtteranceInputEnvelope
    connect?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
  }

  export type TranscriptCreateNestedOneWithoutUtterancesInput = {
    create?: XOR<TranscriptCreateWithoutUtterancesInput, TranscriptUncheckedCreateWithoutUtterancesInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutUtterancesInput
    connect?: TranscriptWhereUniqueInput
  }

  export type TranscriptUtteranceWordUncheckedCreateNestedManyWithoutTranscriptUtteranceInput = {
    create?: XOR<TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput, TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput> | TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput[] | TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput[]
    connectOrCreate?: TranscriptUtteranceWordCreateOrConnectWithoutTranscriptUtteranceInput | TranscriptUtteranceWordCreateOrConnectWithoutTranscriptUtteranceInput[]
    createMany?: TranscriptUtteranceWordCreateManyTranscriptUtteranceInputEnvelope
    connect?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TranscriptUtteranceWordUpdateManyWithoutTranscriptUtteranceNestedInput = {
    create?: XOR<TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput, TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput> | TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput[] | TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput[]
    connectOrCreate?: TranscriptUtteranceWordCreateOrConnectWithoutTranscriptUtteranceInput | TranscriptUtteranceWordCreateOrConnectWithoutTranscriptUtteranceInput[]
    upsert?: TranscriptUtteranceWordUpsertWithWhereUniqueWithoutTranscriptUtteranceInput | TranscriptUtteranceWordUpsertWithWhereUniqueWithoutTranscriptUtteranceInput[]
    createMany?: TranscriptUtteranceWordCreateManyTranscriptUtteranceInputEnvelope
    set?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
    disconnect?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
    delete?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
    connect?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
    update?: TranscriptUtteranceWordUpdateWithWhereUniqueWithoutTranscriptUtteranceInput | TranscriptUtteranceWordUpdateWithWhereUniqueWithoutTranscriptUtteranceInput[]
    updateMany?: TranscriptUtteranceWordUpdateManyWithWhereWithoutTranscriptUtteranceInput | TranscriptUtteranceWordUpdateManyWithWhereWithoutTranscriptUtteranceInput[]
    deleteMany?: TranscriptUtteranceWordScalarWhereInput | TranscriptUtteranceWordScalarWhereInput[]
  }

  export type TranscriptUpdateOneRequiredWithoutUtterancesNestedInput = {
    create?: XOR<TranscriptCreateWithoutUtterancesInput, TranscriptUncheckedCreateWithoutUtterancesInput>
    connectOrCreate?: TranscriptCreateOrConnectWithoutUtterancesInput
    upsert?: TranscriptUpsertWithoutUtterancesInput
    connect?: TranscriptWhereUniqueInput
    update?: XOR<XOR<TranscriptUpdateToOneWithWhereWithoutUtterancesInput, TranscriptUpdateWithoutUtterancesInput>, TranscriptUncheckedUpdateWithoutUtterancesInput>
  }

  export type TranscriptUtteranceWordUncheckedUpdateManyWithoutTranscriptUtteranceNestedInput = {
    create?: XOR<TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput, TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput> | TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput[] | TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput[]
    connectOrCreate?: TranscriptUtteranceWordCreateOrConnectWithoutTranscriptUtteranceInput | TranscriptUtteranceWordCreateOrConnectWithoutTranscriptUtteranceInput[]
    upsert?: TranscriptUtteranceWordUpsertWithWhereUniqueWithoutTranscriptUtteranceInput | TranscriptUtteranceWordUpsertWithWhereUniqueWithoutTranscriptUtteranceInput[]
    createMany?: TranscriptUtteranceWordCreateManyTranscriptUtteranceInputEnvelope
    set?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
    disconnect?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
    delete?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
    connect?: TranscriptUtteranceWordWhereUniqueInput | TranscriptUtteranceWordWhereUniqueInput[]
    update?: TranscriptUtteranceWordUpdateWithWhereUniqueWithoutTranscriptUtteranceInput | TranscriptUtteranceWordUpdateWithWhereUniqueWithoutTranscriptUtteranceInput[]
    updateMany?: TranscriptUtteranceWordUpdateManyWithWhereWithoutTranscriptUtteranceInput | TranscriptUtteranceWordUpdateManyWithWhereWithoutTranscriptUtteranceInput[]
    deleteMany?: TranscriptUtteranceWordScalarWhereInput | TranscriptUtteranceWordScalarWhereInput[]
  }

  export type TranscriptUtteranceCreateNestedOneWithoutWordsInput = {
    create?: XOR<TranscriptUtteranceCreateWithoutWordsInput, TranscriptUtteranceUncheckedCreateWithoutWordsInput>
    connectOrCreate?: TranscriptUtteranceCreateOrConnectWithoutWordsInput
    connect?: TranscriptUtteranceWhereUniqueInput
  }

  export type TranscriptUtteranceUpdateOneWithoutWordsNestedInput = {
    create?: XOR<TranscriptUtteranceCreateWithoutWordsInput, TranscriptUtteranceUncheckedCreateWithoutWordsInput>
    connectOrCreate?: TranscriptUtteranceCreateOrConnectWithoutWordsInput
    upsert?: TranscriptUtteranceUpsertWithoutWordsInput
    disconnect?: TranscriptUtteranceWhereInput | boolean
    delete?: TranscriptUtteranceWhereInput | boolean
    connect?: TranscriptUtteranceWhereUniqueInput
    update?: XOR<XOR<TranscriptUtteranceUpdateToOneWithWhereWithoutWordsInput, TranscriptUtteranceUpdateWithoutWordsInput>, TranscriptUtteranceUncheckedUpdateWithoutWordsInput>
  }

  export type ShowCreateNestedOneWithoutAiShowNoteInput = {
    create?: XOR<ShowCreateWithoutAiShowNoteInput, ShowUncheckedCreateWithoutAiShowNoteInput>
    connectOrCreate?: ShowCreateOrConnectWithoutAiShowNoteInput
    connect?: ShowWhereUniqueInput
  }

  export type AiSummaryEntryCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<AiSummaryEntryCreateWithoutAiShowNoteInput, AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput> | AiSummaryEntryCreateWithoutAiShowNoteInput[] | AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiSummaryEntryCreateOrConnectWithoutAiShowNoteInput | AiSummaryEntryCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: AiSummaryEntryCreateManyAiShowNoteInputEnvelope
    connect?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
  }

  export type AiTweetCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<AiTweetCreateWithoutAiShowNoteInput, AiTweetUncheckedCreateWithoutAiShowNoteInput> | AiTweetCreateWithoutAiShowNoteInput[] | AiTweetUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiTweetCreateOrConnectWithoutAiShowNoteInput | AiTweetCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: AiTweetCreateManyAiShowNoteInputEnvelope
    connect?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
  }

  export type LinkCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<LinkCreateWithoutAiShowNoteInput, LinkUncheckedCreateWithoutAiShowNoteInput> | LinkCreateWithoutAiShowNoteInput[] | LinkUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: LinkCreateOrConnectWithoutAiShowNoteInput | LinkCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: LinkCreateManyAiShowNoteInputEnvelope
    connect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
  }

  export type AiGuestCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<AiGuestCreateWithoutAiShowNoteInput, AiGuestUncheckedCreateWithoutAiShowNoteInput> | AiGuestCreateWithoutAiShowNoteInput[] | AiGuestUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiGuestCreateOrConnectWithoutAiShowNoteInput | AiGuestCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: AiGuestCreateManyAiShowNoteInputEnvelope
    connect?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
  }

  export type TopicCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<TopicCreateWithoutAiShowNoteInput, TopicUncheckedCreateWithoutAiShowNoteInput> | TopicCreateWithoutAiShowNoteInput[] | TopicUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAiShowNoteInput | TopicCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: TopicCreateManyAiShowNoteInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type AiSummaryEntryUncheckedCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<AiSummaryEntryCreateWithoutAiShowNoteInput, AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput> | AiSummaryEntryCreateWithoutAiShowNoteInput[] | AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiSummaryEntryCreateOrConnectWithoutAiShowNoteInput | AiSummaryEntryCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: AiSummaryEntryCreateManyAiShowNoteInputEnvelope
    connect?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
  }

  export type AiTweetUncheckedCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<AiTweetCreateWithoutAiShowNoteInput, AiTweetUncheckedCreateWithoutAiShowNoteInput> | AiTweetCreateWithoutAiShowNoteInput[] | AiTweetUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiTweetCreateOrConnectWithoutAiShowNoteInput | AiTweetCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: AiTweetCreateManyAiShowNoteInputEnvelope
    connect?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
  }

  export type LinkUncheckedCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<LinkCreateWithoutAiShowNoteInput, LinkUncheckedCreateWithoutAiShowNoteInput> | LinkCreateWithoutAiShowNoteInput[] | LinkUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: LinkCreateOrConnectWithoutAiShowNoteInput | LinkCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: LinkCreateManyAiShowNoteInputEnvelope
    connect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
  }

  export type AiGuestUncheckedCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<AiGuestCreateWithoutAiShowNoteInput, AiGuestUncheckedCreateWithoutAiShowNoteInput> | AiGuestCreateWithoutAiShowNoteInput[] | AiGuestUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiGuestCreateOrConnectWithoutAiShowNoteInput | AiGuestCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: AiGuestCreateManyAiShowNoteInputEnvelope
    connect?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutAiShowNoteInput = {
    create?: XOR<TopicCreateWithoutAiShowNoteInput, TopicUncheckedCreateWithoutAiShowNoteInput> | TopicCreateWithoutAiShowNoteInput[] | TopicUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAiShowNoteInput | TopicCreateOrConnectWithoutAiShowNoteInput[]
    createMany?: TopicCreateManyAiShowNoteInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type ShowUpdateOneRequiredWithoutAiShowNoteNestedInput = {
    create?: XOR<ShowCreateWithoutAiShowNoteInput, ShowUncheckedCreateWithoutAiShowNoteInput>
    connectOrCreate?: ShowCreateOrConnectWithoutAiShowNoteInput
    upsert?: ShowUpsertWithoutAiShowNoteInput
    connect?: ShowWhereUniqueInput
    update?: XOR<XOR<ShowUpdateToOneWithWhereWithoutAiShowNoteInput, ShowUpdateWithoutAiShowNoteInput>, ShowUncheckedUpdateWithoutAiShowNoteInput>
  }

  export type AiSummaryEntryUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<AiSummaryEntryCreateWithoutAiShowNoteInput, AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput> | AiSummaryEntryCreateWithoutAiShowNoteInput[] | AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiSummaryEntryCreateOrConnectWithoutAiShowNoteInput | AiSummaryEntryCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: AiSummaryEntryUpsertWithWhereUniqueWithoutAiShowNoteInput | AiSummaryEntryUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: AiSummaryEntryCreateManyAiShowNoteInputEnvelope
    set?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
    disconnect?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
    delete?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
    connect?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
    update?: AiSummaryEntryUpdateWithWhereUniqueWithoutAiShowNoteInput | AiSummaryEntryUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: AiSummaryEntryUpdateManyWithWhereWithoutAiShowNoteInput | AiSummaryEntryUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: AiSummaryEntryScalarWhereInput | AiSummaryEntryScalarWhereInput[]
  }

  export type AiTweetUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<AiTweetCreateWithoutAiShowNoteInput, AiTweetUncheckedCreateWithoutAiShowNoteInput> | AiTweetCreateWithoutAiShowNoteInput[] | AiTweetUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiTweetCreateOrConnectWithoutAiShowNoteInput | AiTweetCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: AiTweetUpsertWithWhereUniqueWithoutAiShowNoteInput | AiTweetUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: AiTweetCreateManyAiShowNoteInputEnvelope
    set?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
    disconnect?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
    delete?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
    connect?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
    update?: AiTweetUpdateWithWhereUniqueWithoutAiShowNoteInput | AiTweetUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: AiTweetUpdateManyWithWhereWithoutAiShowNoteInput | AiTweetUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: AiTweetScalarWhereInput | AiTweetScalarWhereInput[]
  }

  export type LinkUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<LinkCreateWithoutAiShowNoteInput, LinkUncheckedCreateWithoutAiShowNoteInput> | LinkCreateWithoutAiShowNoteInput[] | LinkUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: LinkCreateOrConnectWithoutAiShowNoteInput | LinkCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: LinkUpsertWithWhereUniqueWithoutAiShowNoteInput | LinkUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: LinkCreateManyAiShowNoteInputEnvelope
    set?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    disconnect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    delete?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    connect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    update?: LinkUpdateWithWhereUniqueWithoutAiShowNoteInput | LinkUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: LinkUpdateManyWithWhereWithoutAiShowNoteInput | LinkUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: LinkScalarWhereInput | LinkScalarWhereInput[]
  }

  export type AiGuestUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<AiGuestCreateWithoutAiShowNoteInput, AiGuestUncheckedCreateWithoutAiShowNoteInput> | AiGuestCreateWithoutAiShowNoteInput[] | AiGuestUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiGuestCreateOrConnectWithoutAiShowNoteInput | AiGuestCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: AiGuestUpsertWithWhereUniqueWithoutAiShowNoteInput | AiGuestUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: AiGuestCreateManyAiShowNoteInputEnvelope
    set?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
    disconnect?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
    delete?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
    connect?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
    update?: AiGuestUpdateWithWhereUniqueWithoutAiShowNoteInput | AiGuestUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: AiGuestUpdateManyWithWhereWithoutAiShowNoteInput | AiGuestUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: AiGuestScalarWhereInput | AiGuestScalarWhereInput[]
  }

  export type TopicUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<TopicCreateWithoutAiShowNoteInput, TopicUncheckedCreateWithoutAiShowNoteInput> | TopicCreateWithoutAiShowNoteInput[] | TopicUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAiShowNoteInput | TopicCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutAiShowNoteInput | TopicUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: TopicCreateManyAiShowNoteInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutAiShowNoteInput | TopicUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutAiShowNoteInput | TopicUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type AiSummaryEntryUncheckedUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<AiSummaryEntryCreateWithoutAiShowNoteInput, AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput> | AiSummaryEntryCreateWithoutAiShowNoteInput[] | AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiSummaryEntryCreateOrConnectWithoutAiShowNoteInput | AiSummaryEntryCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: AiSummaryEntryUpsertWithWhereUniqueWithoutAiShowNoteInput | AiSummaryEntryUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: AiSummaryEntryCreateManyAiShowNoteInputEnvelope
    set?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
    disconnect?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
    delete?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
    connect?: AiSummaryEntryWhereUniqueInput | AiSummaryEntryWhereUniqueInput[]
    update?: AiSummaryEntryUpdateWithWhereUniqueWithoutAiShowNoteInput | AiSummaryEntryUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: AiSummaryEntryUpdateManyWithWhereWithoutAiShowNoteInput | AiSummaryEntryUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: AiSummaryEntryScalarWhereInput | AiSummaryEntryScalarWhereInput[]
  }

  export type AiTweetUncheckedUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<AiTweetCreateWithoutAiShowNoteInput, AiTweetUncheckedCreateWithoutAiShowNoteInput> | AiTweetCreateWithoutAiShowNoteInput[] | AiTweetUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiTweetCreateOrConnectWithoutAiShowNoteInput | AiTweetCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: AiTweetUpsertWithWhereUniqueWithoutAiShowNoteInput | AiTweetUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: AiTweetCreateManyAiShowNoteInputEnvelope
    set?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
    disconnect?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
    delete?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
    connect?: AiTweetWhereUniqueInput | AiTweetWhereUniqueInput[]
    update?: AiTweetUpdateWithWhereUniqueWithoutAiShowNoteInput | AiTweetUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: AiTweetUpdateManyWithWhereWithoutAiShowNoteInput | AiTweetUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: AiTweetScalarWhereInput | AiTweetScalarWhereInput[]
  }

  export type LinkUncheckedUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<LinkCreateWithoutAiShowNoteInput, LinkUncheckedCreateWithoutAiShowNoteInput> | LinkCreateWithoutAiShowNoteInput[] | LinkUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: LinkCreateOrConnectWithoutAiShowNoteInput | LinkCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: LinkUpsertWithWhereUniqueWithoutAiShowNoteInput | LinkUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: LinkCreateManyAiShowNoteInputEnvelope
    set?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    disconnect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    delete?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    connect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    update?: LinkUpdateWithWhereUniqueWithoutAiShowNoteInput | LinkUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: LinkUpdateManyWithWhereWithoutAiShowNoteInput | LinkUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: LinkScalarWhereInput | LinkScalarWhereInput[]
  }

  export type AiGuestUncheckedUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<AiGuestCreateWithoutAiShowNoteInput, AiGuestUncheckedCreateWithoutAiShowNoteInput> | AiGuestCreateWithoutAiShowNoteInput[] | AiGuestUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: AiGuestCreateOrConnectWithoutAiShowNoteInput | AiGuestCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: AiGuestUpsertWithWhereUniqueWithoutAiShowNoteInput | AiGuestUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: AiGuestCreateManyAiShowNoteInputEnvelope
    set?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
    disconnect?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
    delete?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
    connect?: AiGuestWhereUniqueInput | AiGuestWhereUniqueInput[]
    update?: AiGuestUpdateWithWhereUniqueWithoutAiShowNoteInput | AiGuestUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: AiGuestUpdateManyWithWhereWithoutAiShowNoteInput | AiGuestUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: AiGuestScalarWhereInput | AiGuestScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutAiShowNoteNestedInput = {
    create?: XOR<TopicCreateWithoutAiShowNoteInput, TopicUncheckedCreateWithoutAiShowNoteInput> | TopicCreateWithoutAiShowNoteInput[] | TopicUncheckedCreateWithoutAiShowNoteInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutAiShowNoteInput | TopicCreateOrConnectWithoutAiShowNoteInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutAiShowNoteInput | TopicUpsertWithWhereUniqueWithoutAiShowNoteInput[]
    createMany?: TopicCreateManyAiShowNoteInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutAiShowNoteInput | TopicUpdateWithWhereUniqueWithoutAiShowNoteInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutAiShowNoteInput | TopicUpdateManyWithWhereWithoutAiShowNoteInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type AiShowNoteCreateNestedOneWithoutSummaryInput = {
    create?: XOR<AiShowNoteCreateWithoutSummaryInput, AiShowNoteUncheckedCreateWithoutSummaryInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutSummaryInput
    connect?: AiShowNoteWhereUniqueInput
  }

  export type AiShowNoteUpdateOneRequiredWithoutSummaryNestedInput = {
    create?: XOR<AiShowNoteCreateWithoutSummaryInput, AiShowNoteUncheckedCreateWithoutSummaryInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutSummaryInput
    upsert?: AiShowNoteUpsertWithoutSummaryInput
    connect?: AiShowNoteWhereUniqueInput
    update?: XOR<XOR<AiShowNoteUpdateToOneWithWhereWithoutSummaryInput, AiShowNoteUpdateWithoutSummaryInput>, AiShowNoteUncheckedUpdateWithoutSummaryInput>
  }

  export type AiShowNoteCreateNestedOneWithoutTweetsInput = {
    create?: XOR<AiShowNoteCreateWithoutTweetsInput, AiShowNoteUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutTweetsInput
    connect?: AiShowNoteWhereUniqueInput
  }

  export type AiShowNoteUpdateOneRequiredWithoutTweetsNestedInput = {
    create?: XOR<AiShowNoteCreateWithoutTweetsInput, AiShowNoteUncheckedCreateWithoutTweetsInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutTweetsInput
    upsert?: AiShowNoteUpsertWithoutTweetsInput
    connect?: AiShowNoteWhereUniqueInput
    update?: XOR<XOR<AiShowNoteUpdateToOneWithWhereWithoutTweetsInput, AiShowNoteUpdateWithoutTweetsInput>, AiShowNoteUncheckedUpdateWithoutTweetsInput>
  }

  export type AiShowNoteCreateNestedOneWithoutLinksInput = {
    create?: XOR<AiShowNoteCreateWithoutLinksInput, AiShowNoteUncheckedCreateWithoutLinksInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutLinksInput
    connect?: AiShowNoteWhereUniqueInput
  }

  export type AiShowNoteUpdateOneRequiredWithoutLinksNestedInput = {
    create?: XOR<AiShowNoteCreateWithoutLinksInput, AiShowNoteUncheckedCreateWithoutLinksInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutLinksInput
    upsert?: AiShowNoteUpsertWithoutLinksInput
    connect?: AiShowNoteWhereUniqueInput
    update?: XOR<XOR<AiShowNoteUpdateToOneWithWhereWithoutLinksInput, AiShowNoteUpdateWithoutLinksInput>, AiShowNoteUncheckedUpdateWithoutLinksInput>
  }

  export type AiShowNoteCreateNestedOneWithoutGuestsInput = {
    create?: XOR<AiShowNoteCreateWithoutGuestsInput, AiShowNoteUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutGuestsInput
    connect?: AiShowNoteWhereUniqueInput
  }

  export type AiShowNoteUpdateOneRequiredWithoutGuestsNestedInput = {
    create?: XOR<AiShowNoteCreateWithoutGuestsInput, AiShowNoteUncheckedCreateWithoutGuestsInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutGuestsInput
    upsert?: AiShowNoteUpsertWithoutGuestsInput
    connect?: AiShowNoteWhereUniqueInput
    update?: XOR<XOR<AiShowNoteUpdateToOneWithWhereWithoutGuestsInput, AiShowNoteUpdateWithoutGuestsInput>, AiShowNoteUncheckedUpdateWithoutGuestsInput>
  }

  export type AiShowNoteCreateNestedOneWithoutTopicsInput = {
    create?: XOR<AiShowNoteCreateWithoutTopicsInput, AiShowNoteUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutTopicsInput
    connect?: AiShowNoteWhereUniqueInput
  }

  export type AiShowNoteUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<AiShowNoteCreateWithoutTopicsInput, AiShowNoteUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: AiShowNoteCreateOrConnectWithoutTopicsInput
    upsert?: AiShowNoteUpsertWithoutTopicsInput
    connect?: AiShowNoteWhereUniqueInput
    update?: XOR<XOR<AiShowNoteUpdateToOneWithWhereWithoutTopicsInput, AiShowNoteUpdateWithoutTopicsInput>, AiShowNoteUncheckedUpdateWithoutTopicsInput>
  }

  export type PlaylistOnVideoCreateNestedManyWithoutVideoInput = {
    create?: XOR<PlaylistOnVideoCreateWithoutVideoInput, PlaylistOnVideoUncheckedCreateWithoutVideoInput> | PlaylistOnVideoCreateWithoutVideoInput[] | PlaylistOnVideoUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: PlaylistOnVideoCreateOrConnectWithoutVideoInput | PlaylistOnVideoCreateOrConnectWithoutVideoInput[]
    createMany?: PlaylistOnVideoCreateManyVideoInputEnvelope
    connect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
  }

  export type ShowVideoCreateNestedManyWithoutVideoInput = {
    create?: XOR<ShowVideoCreateWithoutVideoInput, ShowVideoUncheckedCreateWithoutVideoInput> | ShowVideoCreateWithoutVideoInput[] | ShowVideoUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ShowVideoCreateOrConnectWithoutVideoInput | ShowVideoCreateOrConnectWithoutVideoInput[]
    createMany?: ShowVideoCreateManyVideoInputEnvelope
    connect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
  }

  export type PlaylistOnVideoUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<PlaylistOnVideoCreateWithoutVideoInput, PlaylistOnVideoUncheckedCreateWithoutVideoInput> | PlaylistOnVideoCreateWithoutVideoInput[] | PlaylistOnVideoUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: PlaylistOnVideoCreateOrConnectWithoutVideoInput | PlaylistOnVideoCreateOrConnectWithoutVideoInput[]
    createMany?: PlaylistOnVideoCreateManyVideoInputEnvelope
    connect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
  }

  export type ShowVideoUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<ShowVideoCreateWithoutVideoInput, ShowVideoUncheckedCreateWithoutVideoInput> | ShowVideoCreateWithoutVideoInput[] | ShowVideoUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ShowVideoCreateOrConnectWithoutVideoInput | ShowVideoCreateOrConnectWithoutVideoInput[]
    createMany?: ShowVideoCreateManyVideoInputEnvelope
    connect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
  }

  export type PlaylistOnVideoUpdateManyWithoutVideoNestedInput = {
    create?: XOR<PlaylistOnVideoCreateWithoutVideoInput, PlaylistOnVideoUncheckedCreateWithoutVideoInput> | PlaylistOnVideoCreateWithoutVideoInput[] | PlaylistOnVideoUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: PlaylistOnVideoCreateOrConnectWithoutVideoInput | PlaylistOnVideoCreateOrConnectWithoutVideoInput[]
    upsert?: PlaylistOnVideoUpsertWithWhereUniqueWithoutVideoInput | PlaylistOnVideoUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: PlaylistOnVideoCreateManyVideoInputEnvelope
    set?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    disconnect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    delete?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    connect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    update?: PlaylistOnVideoUpdateWithWhereUniqueWithoutVideoInput | PlaylistOnVideoUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: PlaylistOnVideoUpdateManyWithWhereWithoutVideoInput | PlaylistOnVideoUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: PlaylistOnVideoScalarWhereInput | PlaylistOnVideoScalarWhereInput[]
  }

  export type ShowVideoUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ShowVideoCreateWithoutVideoInput, ShowVideoUncheckedCreateWithoutVideoInput> | ShowVideoCreateWithoutVideoInput[] | ShowVideoUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ShowVideoCreateOrConnectWithoutVideoInput | ShowVideoCreateOrConnectWithoutVideoInput[]
    upsert?: ShowVideoUpsertWithWhereUniqueWithoutVideoInput | ShowVideoUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ShowVideoCreateManyVideoInputEnvelope
    set?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    disconnect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    delete?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    connect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    update?: ShowVideoUpdateWithWhereUniqueWithoutVideoInput | ShowVideoUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ShowVideoUpdateManyWithWhereWithoutVideoInput | ShowVideoUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ShowVideoScalarWhereInput | ShowVideoScalarWhereInput[]
  }

  export type PlaylistOnVideoUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<PlaylistOnVideoCreateWithoutVideoInput, PlaylistOnVideoUncheckedCreateWithoutVideoInput> | PlaylistOnVideoCreateWithoutVideoInput[] | PlaylistOnVideoUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: PlaylistOnVideoCreateOrConnectWithoutVideoInput | PlaylistOnVideoCreateOrConnectWithoutVideoInput[]
    upsert?: PlaylistOnVideoUpsertWithWhereUniqueWithoutVideoInput | PlaylistOnVideoUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: PlaylistOnVideoCreateManyVideoInputEnvelope
    set?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    disconnect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    delete?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    connect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    update?: PlaylistOnVideoUpdateWithWhereUniqueWithoutVideoInput | PlaylistOnVideoUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: PlaylistOnVideoUpdateManyWithWhereWithoutVideoInput | PlaylistOnVideoUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: PlaylistOnVideoScalarWhereInput | PlaylistOnVideoScalarWhereInput[]
  }

  export type ShowVideoUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<ShowVideoCreateWithoutVideoInput, ShowVideoUncheckedCreateWithoutVideoInput> | ShowVideoCreateWithoutVideoInput[] | ShowVideoUncheckedCreateWithoutVideoInput[]
    connectOrCreate?: ShowVideoCreateOrConnectWithoutVideoInput | ShowVideoCreateOrConnectWithoutVideoInput[]
    upsert?: ShowVideoUpsertWithWhereUniqueWithoutVideoInput | ShowVideoUpsertWithWhereUniqueWithoutVideoInput[]
    createMany?: ShowVideoCreateManyVideoInputEnvelope
    set?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    disconnect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    delete?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    connect?: ShowVideoWhereUniqueInput | ShowVideoWhereUniqueInput[]
    update?: ShowVideoUpdateWithWhereUniqueWithoutVideoInput | ShowVideoUpdateWithWhereUniqueWithoutVideoInput[]
    updateMany?: ShowVideoUpdateManyWithWhereWithoutVideoInput | ShowVideoUpdateManyWithWhereWithoutVideoInput[]
    deleteMany?: ShowVideoScalarWhereInput | ShowVideoScalarWhereInput[]
  }

  export type PlaylistOnVideoCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistOnVideoCreateWithoutPlaylistInput, PlaylistOnVideoUncheckedCreateWithoutPlaylistInput> | PlaylistOnVideoCreateWithoutPlaylistInput[] | PlaylistOnVideoUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistOnVideoCreateOrConnectWithoutPlaylistInput | PlaylistOnVideoCreateOrConnectWithoutPlaylistInput[]
    createMany?: PlaylistOnVideoCreateManyPlaylistInputEnvelope
    connect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
  }

  export type PlaylistOnVideoUncheckedCreateNestedManyWithoutPlaylistInput = {
    create?: XOR<PlaylistOnVideoCreateWithoutPlaylistInput, PlaylistOnVideoUncheckedCreateWithoutPlaylistInput> | PlaylistOnVideoCreateWithoutPlaylistInput[] | PlaylistOnVideoUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistOnVideoCreateOrConnectWithoutPlaylistInput | PlaylistOnVideoCreateOrConnectWithoutPlaylistInput[]
    createMany?: PlaylistOnVideoCreateManyPlaylistInputEnvelope
    connect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type PlaylistOnVideoUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistOnVideoCreateWithoutPlaylistInput, PlaylistOnVideoUncheckedCreateWithoutPlaylistInput> | PlaylistOnVideoCreateWithoutPlaylistInput[] | PlaylistOnVideoUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistOnVideoCreateOrConnectWithoutPlaylistInput | PlaylistOnVideoCreateOrConnectWithoutPlaylistInput[]
    upsert?: PlaylistOnVideoUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistOnVideoUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: PlaylistOnVideoCreateManyPlaylistInputEnvelope
    set?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    disconnect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    delete?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    connect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    update?: PlaylistOnVideoUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistOnVideoUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: PlaylistOnVideoUpdateManyWithWhereWithoutPlaylistInput | PlaylistOnVideoUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: PlaylistOnVideoScalarWhereInput | PlaylistOnVideoScalarWhereInput[]
  }

  export type PlaylistOnVideoUncheckedUpdateManyWithoutPlaylistNestedInput = {
    create?: XOR<PlaylistOnVideoCreateWithoutPlaylistInput, PlaylistOnVideoUncheckedCreateWithoutPlaylistInput> | PlaylistOnVideoCreateWithoutPlaylistInput[] | PlaylistOnVideoUncheckedCreateWithoutPlaylistInput[]
    connectOrCreate?: PlaylistOnVideoCreateOrConnectWithoutPlaylistInput | PlaylistOnVideoCreateOrConnectWithoutPlaylistInput[]
    upsert?: PlaylistOnVideoUpsertWithWhereUniqueWithoutPlaylistInput | PlaylistOnVideoUpsertWithWhereUniqueWithoutPlaylistInput[]
    createMany?: PlaylistOnVideoCreateManyPlaylistInputEnvelope
    set?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    disconnect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    delete?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    connect?: PlaylistOnVideoWhereUniqueInput | PlaylistOnVideoWhereUniqueInput[]
    update?: PlaylistOnVideoUpdateWithWhereUniqueWithoutPlaylistInput | PlaylistOnVideoUpdateWithWhereUniqueWithoutPlaylistInput[]
    updateMany?: PlaylistOnVideoUpdateManyWithWhereWithoutPlaylistInput | PlaylistOnVideoUpdateManyWithWhereWithoutPlaylistInput[]
    deleteMany?: PlaylistOnVideoScalarWhereInput | PlaylistOnVideoScalarWhereInput[]
  }

  export type VideoCreateNestedOneWithoutPlaylistsInput = {
    create?: XOR<VideoCreateWithoutPlaylistsInput, VideoUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutPlaylistsInput
    connect?: VideoWhereUniqueInput
  }

  export type PlaylistCreateNestedOneWithoutVideosInput = {
    create?: XOR<PlaylistCreateWithoutVideosInput, PlaylistUncheckedCreateWithoutVideosInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutVideosInput
    connect?: PlaylistWhereUniqueInput
  }

  export type VideoUpdateOneRequiredWithoutPlaylistsNestedInput = {
    create?: XOR<VideoCreateWithoutPlaylistsInput, VideoUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutPlaylistsInput
    upsert?: VideoUpsertWithoutPlaylistsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutPlaylistsInput, VideoUpdateWithoutPlaylistsInput>, VideoUncheckedUpdateWithoutPlaylistsInput>
  }

  export type PlaylistUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<PlaylistCreateWithoutVideosInput, PlaylistUncheckedCreateWithoutVideosInput>
    connectOrCreate?: PlaylistCreateOrConnectWithoutVideosInput
    upsert?: PlaylistUpsertWithoutVideosInput
    connect?: PlaylistWhereUniqueInput
    update?: XOR<XOR<PlaylistUpdateToOneWithWhereWithoutVideosInput, PlaylistUpdateWithoutVideosInput>, PlaylistUncheckedUpdateWithoutVideosInput>
  }

  export type ShowCreateNestedOneWithoutVideosInput = {
    create?: XOR<ShowCreateWithoutVideosInput, ShowUncheckedCreateWithoutVideosInput>
    connectOrCreate?: ShowCreateOrConnectWithoutVideosInput
    connect?: ShowWhereUniqueInput
  }

  export type VideoCreateNestedOneWithoutShowsInput = {
    create?: XOR<VideoCreateWithoutShowsInput, VideoUncheckedCreateWithoutShowsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutShowsInput
    connect?: VideoWhereUniqueInput
  }

  export type ShowUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<ShowCreateWithoutVideosInput, ShowUncheckedCreateWithoutVideosInput>
    connectOrCreate?: ShowCreateOrConnectWithoutVideosInput
    upsert?: ShowUpsertWithoutVideosInput
    connect?: ShowWhereUniqueInput
    update?: XOR<XOR<ShowUpdateToOneWithWhereWithoutVideosInput, ShowUpdateWithoutVideosInput>, ShowUncheckedUpdateWithoutVideosInput>
  }

  export type VideoUpdateOneRequiredWithoutShowsNestedInput = {
    create?: XOR<VideoCreateWithoutShowsInput, VideoUncheckedCreateWithoutShowsInput>
    connectOrCreate?: VideoCreateOrConnectWithoutShowsInput
    upsert?: VideoUpsertWithoutShowsInput
    connect?: VideoWhereUniqueInput
    update?: XOR<XOR<VideoUpdateToOneWithWhereWithoutShowsInput, VideoUpdateWithoutShowsInput>, VideoUncheckedUpdateWithoutShowsInput>
  }

  export type EnumUserSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserSubmissionStatus
  }

  export type EnumUserSubmissionTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserSubmissionType
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumShowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowType | EnumShowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShowType[]
    notIn?: $Enums.ShowType[]
    not?: NestedEnumShowTypeFilter<$PrismaModel> | $Enums.ShowType
  }

  export type NestedEnumShowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShowType | EnumShowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShowType[]
    notIn?: $Enums.ShowType[]
    not?: NestedEnumShowTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShowTypeFilter<$PrismaModel>
    _max?: NestedEnumShowTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserSubmissionStatus | EnumUserSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserSubmissionStatus[]
    notIn?: $Enums.UserSubmissionStatus[]
    not?: NestedEnumUserSubmissionStatusFilter<$PrismaModel> | $Enums.UserSubmissionStatus
  }

  export type NestedEnumUserSubmissionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserSubmissionType | EnumUserSubmissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserSubmissionType[]
    notIn?: $Enums.UserSubmissionType[]
    not?: NestedEnumUserSubmissionTypeFilter<$PrismaModel> | $Enums.UserSubmissionType
  }

  export type NestedEnumUserSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserSubmissionStatus | EnumUserSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserSubmissionStatus[]
    notIn?: $Enums.UserSubmissionStatus[]
    not?: NestedEnumUserSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserSubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumUserSubmissionStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserSubmissionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserSubmissionType | EnumUserSubmissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserSubmissionType[]
    notIn?: $Enums.UserSubmissionType[]
    not?: NestedEnumUserSubmissionTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserSubmissionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserSubmissionTypeFilter<$PrismaModel>
    _max?: NestedEnumUserSubmissionTypeFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    access_token?: string | null
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string
    ip?: string | null
    country?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    access_token?: string | null
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string
    ip?: string | null
    country?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShowCreateWithoutHostsInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestCreateNestedManyWithoutShowInput
    transcript?: TranscriptCreateNestedOneWithoutShowInput
    aiShowNote?: AiShowNoteCreateNestedOneWithoutShowInput
    videos?: ShowVideoCreateNestedManyWithoutShowInput
  }

  export type ShowUncheckedCreateWithoutHostsInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestUncheckedCreateNestedManyWithoutShowInput
    transcript?: TranscriptUncheckedCreateNestedOneWithoutShowInput
    aiShowNote?: AiShowNoteUncheckedCreateNestedOneWithoutShowInput
    videos?: ShowVideoUncheckedCreateNestedManyWithoutShowInput
  }

  export type ShowCreateOrConnectWithoutHostsInput = {
    where: ShowWhereUniqueInput
    create: XOR<ShowCreateWithoutHostsInput, ShowUncheckedCreateWithoutHostsInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    user_id?: StringNullableFilter<"Session"> | string | null
    access_token?: StringNullableFilter<"Session"> | string | null
    session_token?: StringFilter<"Session"> | string
    created_at?: DateTimeFilter<"Session"> | Date | string
    updated_at?: DateTimeFilter<"Session"> | Date | string
    ip?: StringNullableFilter<"Session"> | string | null
    country?: StringNullableFilter<"Session"> | string | null
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
  }

  export type ShowUpsertWithWhereUniqueWithoutHostsInput = {
    where: ShowWhereUniqueInput
    update: XOR<ShowUpdateWithoutHostsInput, ShowUncheckedUpdateWithoutHostsInput>
    create: XOR<ShowCreateWithoutHostsInput, ShowUncheckedCreateWithoutHostsInput>
  }

  export type ShowUpdateWithWhereUniqueWithoutHostsInput = {
    where: ShowWhereUniqueInput
    data: XOR<ShowUpdateWithoutHostsInput, ShowUncheckedUpdateWithoutHostsInput>
  }

  export type ShowUpdateManyWithWhereWithoutHostsInput = {
    where: ShowScalarWhereInput
    data: XOR<ShowUpdateManyMutationInput, ShowUncheckedUpdateManyWithoutHostsInput>
  }

  export type ShowScalarWhereInput = {
    AND?: ShowScalarWhereInput | ShowScalarWhereInput[]
    OR?: ShowScalarWhereInput[]
    NOT?: ShowScalarWhereInput | ShowScalarWhereInput[]
    id?: StringFilter<"Show"> | string
    number?: IntFilter<"Show"> | number
    title?: StringFilter<"Show"> | string
    date?: DateTimeFilter<"Show"> | Date | string
    url?: StringFilter<"Show"> | string
    youtube_url?: StringNullableFilter<"Show"> | string | null
    spotify_id?: StringNullableFilter<"Show"> | string | null
    show_notes?: StringFilter<"Show"> | string
    hash?: StringFilter<"Show"> | string
    slug?: StringFilter<"Show"> | string
    md_file?: StringFilter<"Show"> | string
    created_at?: DateTimeFilter<"Show"> | Date | string
    updated_at?: DateTimeFilter<"Show"> | Date | string
    show_type?: EnumShowTypeFilter<"Show"> | $Enums.ShowType
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    avatar_url?: string | null
    created_at?: Date | string
    email?: string | null
    github_id: number
    updated_at?: Date | string
    username?: string | null
    theme?: string
    name?: string | null
    twitter?: string | null
    session?: SessionCreateNestedManyWithoutUserInput
    hostedShows?: ShowCreateNestedManyWithoutHostsInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    avatar_url?: string | null
    created_at?: Date | string
    email?: string | null
    github_id: number
    updated_at?: Date | string
    username?: string | null
    theme?: string
    name?: string | null
    twitter?: string | null
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    hostedShows?: ShowUncheckedCreateNestedManyWithoutHostsInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUpdateManyWithoutUserNestedInput
    hostedShows?: ShowUpdateManyWithoutHostsNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    hostedShows?: ShowUncheckedUpdateManyWithoutHostsNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutSessionInput = {
    id?: string
    avatar_url?: string | null
    created_at?: Date | string
    email?: string | null
    github_id: number
    updated_at?: Date | string
    username?: string | null
    theme?: string
    name?: string | null
    twitter?: string | null
    roles?: UserRoleCreateNestedManyWithoutUserInput
    hostedShows?: ShowCreateNestedManyWithoutHostsInput
  }

  export type UserUncheckedCreateWithoutSessionInput = {
    id?: string
    avatar_url?: string | null
    created_at?: Date | string
    email?: string | null
    github_id: number
    updated_at?: Date | string
    username?: string | null
    theme?: string
    name?: string | null
    twitter?: string | null
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    hostedShows?: ShowUncheckedCreateNestedManyWithoutHostsInput
  }

  export type UserCreateOrConnectWithoutSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
  }

  export type UserUpsertWithoutSessionInput = {
    update: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
  }

  export type UserUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    hostedShows?: ShowUpdateManyWithoutHostsNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    hostedShows?: ShowUncheckedUpdateManyWithoutHostsNestedInput
  }

  export type ShowCreateWithoutGuestsInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    transcript?: TranscriptCreateNestedOneWithoutShowInput
    aiShowNote?: AiShowNoteCreateNestedOneWithoutShowInput
    videos?: ShowVideoCreateNestedManyWithoutShowInput
    hosts?: UserCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowUncheckedCreateWithoutGuestsInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    transcript?: TranscriptUncheckedCreateNestedOneWithoutShowInput
    aiShowNote?: AiShowNoteUncheckedCreateNestedOneWithoutShowInput
    videos?: ShowVideoUncheckedCreateNestedManyWithoutShowInput
    hosts?: UserUncheckedCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowCreateOrConnectWithoutGuestsInput = {
    where: ShowWhereUniqueInput
    create: XOR<ShowCreateWithoutGuestsInput, ShowUncheckedCreateWithoutGuestsInput>
  }

  export type GuestCreateWithoutShowsInput = {
    id?: string
    name: string
    name_slug: string
    twitter?: string | null
    github?: string | null
    of?: string | null
    url?: string | null
    social?: SocialLinkCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateWithoutShowsInput = {
    id?: string
    name: string
    name_slug: string
    twitter?: string | null
    github?: string | null
    of?: string | null
    url?: string | null
    social?: SocialLinkUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestCreateOrConnectWithoutShowsInput = {
    where: GuestWhereUniqueInput
    create: XOR<GuestCreateWithoutShowsInput, GuestUncheckedCreateWithoutShowsInput>
  }

  export type TranscriptCreateWithoutShowGuestInput = {
    id?: string
    show: ShowCreateNestedOneWithoutTranscriptInput
    utterances?: TranscriptUtteranceCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptUncheckedCreateWithoutShowGuestInput = {
    id?: string
    show_number: number
    utterances?: TranscriptUtteranceUncheckedCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptCreateOrConnectWithoutShowGuestInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutShowGuestInput, TranscriptUncheckedCreateWithoutShowGuestInput>
  }

  export type ShowUpsertWithoutGuestsInput = {
    update: XOR<ShowUpdateWithoutGuestsInput, ShowUncheckedUpdateWithoutGuestsInput>
    create: XOR<ShowCreateWithoutGuestsInput, ShowUncheckedCreateWithoutGuestsInput>
    where?: ShowWhereInput
  }

  export type ShowUpdateToOneWithWhereWithoutGuestsInput = {
    where?: ShowWhereInput
    data: XOR<ShowUpdateWithoutGuestsInput, ShowUncheckedUpdateWithoutGuestsInput>
  }

  export type ShowUpdateWithoutGuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    transcript?: TranscriptUpdateOneWithoutShowNestedInput
    aiShowNote?: AiShowNoteUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUpdateManyWithoutShowNestedInput
    hosts?: UserUpdateManyWithoutHostedShowsNestedInput
  }

  export type ShowUncheckedUpdateWithoutGuestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    transcript?: TranscriptUncheckedUpdateOneWithoutShowNestedInput
    aiShowNote?: AiShowNoteUncheckedUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUncheckedUpdateManyWithoutShowNestedInput
    hosts?: UserUncheckedUpdateManyWithoutHostedShowsNestedInput
  }

  export type GuestUpsertWithoutShowsInput = {
    update: XOR<GuestUpdateWithoutShowsInput, GuestUncheckedUpdateWithoutShowsInput>
    create: XOR<GuestCreateWithoutShowsInput, GuestUncheckedCreateWithoutShowsInput>
    where?: GuestWhereInput
  }

  export type GuestUpdateToOneWithWhereWithoutShowsInput = {
    where?: GuestWhereInput
    data: XOR<GuestUpdateWithoutShowsInput, GuestUncheckedUpdateWithoutShowsInput>
  }

  export type GuestUpdateWithoutShowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_slug?: StringFieldUpdateOperationsInput | string
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    of?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    social?: SocialLinkUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateWithoutShowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_slug?: StringFieldUpdateOperationsInput | string
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    of?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    social?: SocialLinkUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type TranscriptUpsertWithoutShowGuestInput = {
    update: XOR<TranscriptUpdateWithoutShowGuestInput, TranscriptUncheckedUpdateWithoutShowGuestInput>
    create: XOR<TranscriptCreateWithoutShowGuestInput, TranscriptUncheckedCreateWithoutShowGuestInput>
    where?: TranscriptWhereInput
  }

  export type TranscriptUpdateToOneWithWhereWithoutShowGuestInput = {
    where?: TranscriptWhereInput
    data: XOR<TranscriptUpdateWithoutShowGuestInput, TranscriptUncheckedUpdateWithoutShowGuestInput>
  }

  export type TranscriptUpdateWithoutShowGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    show?: ShowUpdateOneRequiredWithoutTranscriptNestedInput
    utterances?: TranscriptUtteranceUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateWithoutShowGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    show_number?: IntFieldUpdateOperationsInput | number
    utterances?: TranscriptUtteranceUncheckedUpdateManyWithoutTranscriptNestedInput
  }

  export type SocialLinkCreateWithoutGuestInput = {
    id?: string
    link: string
  }

  export type SocialLinkUncheckedCreateWithoutGuestInput = {
    id?: string
    link: string
  }

  export type SocialLinkCreateOrConnectWithoutGuestInput = {
    where: SocialLinkWhereUniqueInput
    create: XOR<SocialLinkCreateWithoutGuestInput, SocialLinkUncheckedCreateWithoutGuestInput>
  }

  export type SocialLinkCreateManyGuestInputEnvelope = {
    data: SocialLinkCreateManyGuestInput | SocialLinkCreateManyGuestInput[]
    skipDuplicates?: boolean
  }

  export type ShowGuestCreateWithoutGuestInput = {
    id?: string
    Show: ShowCreateNestedOneWithoutGuestsInput
    Transcript?: TranscriptCreateNestedOneWithoutShowGuestInput
  }

  export type ShowGuestUncheckedCreateWithoutGuestInput = {
    id?: string
    showId: string
    transcriptId?: string | null
  }

  export type ShowGuestCreateOrConnectWithoutGuestInput = {
    where: ShowGuestWhereUniqueInput
    create: XOR<ShowGuestCreateWithoutGuestInput, ShowGuestUncheckedCreateWithoutGuestInput>
  }

  export type ShowGuestCreateManyGuestInputEnvelope = {
    data: ShowGuestCreateManyGuestInput | ShowGuestCreateManyGuestInput[]
    skipDuplicates?: boolean
  }

  export type SocialLinkUpsertWithWhereUniqueWithoutGuestInput = {
    where: SocialLinkWhereUniqueInput
    update: XOR<SocialLinkUpdateWithoutGuestInput, SocialLinkUncheckedUpdateWithoutGuestInput>
    create: XOR<SocialLinkCreateWithoutGuestInput, SocialLinkUncheckedCreateWithoutGuestInput>
  }

  export type SocialLinkUpdateWithWhereUniqueWithoutGuestInput = {
    where: SocialLinkWhereUniqueInput
    data: XOR<SocialLinkUpdateWithoutGuestInput, SocialLinkUncheckedUpdateWithoutGuestInput>
  }

  export type SocialLinkUpdateManyWithWhereWithoutGuestInput = {
    where: SocialLinkScalarWhereInput
    data: XOR<SocialLinkUpdateManyMutationInput, SocialLinkUncheckedUpdateManyWithoutGuestInput>
  }

  export type SocialLinkScalarWhereInput = {
    AND?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
    OR?: SocialLinkScalarWhereInput[]
    NOT?: SocialLinkScalarWhereInput | SocialLinkScalarWhereInput[]
    id?: StringFilter<"SocialLink"> | string
    link?: StringFilter<"SocialLink"> | string
    guest_id?: StringFilter<"SocialLink"> | string
  }

  export type ShowGuestUpsertWithWhereUniqueWithoutGuestInput = {
    where: ShowGuestWhereUniqueInput
    update: XOR<ShowGuestUpdateWithoutGuestInput, ShowGuestUncheckedUpdateWithoutGuestInput>
    create: XOR<ShowGuestCreateWithoutGuestInput, ShowGuestUncheckedCreateWithoutGuestInput>
  }

  export type ShowGuestUpdateWithWhereUniqueWithoutGuestInput = {
    where: ShowGuestWhereUniqueInput
    data: XOR<ShowGuestUpdateWithoutGuestInput, ShowGuestUncheckedUpdateWithoutGuestInput>
  }

  export type ShowGuestUpdateManyWithWhereWithoutGuestInput = {
    where: ShowGuestScalarWhereInput
    data: XOR<ShowGuestUpdateManyMutationInput, ShowGuestUncheckedUpdateManyWithoutGuestInput>
  }

  export type ShowGuestScalarWhereInput = {
    AND?: ShowGuestScalarWhereInput | ShowGuestScalarWhereInput[]
    OR?: ShowGuestScalarWhereInput[]
    NOT?: ShowGuestScalarWhereInput | ShowGuestScalarWhereInput[]
    id?: StringFilter<"ShowGuest"> | string
    showId?: StringFilter<"ShowGuest"> | string
    guestId?: StringFilter<"ShowGuest"> | string
    transcriptId?: StringNullableFilter<"ShowGuest"> | string | null
  }

  export type GuestCreateWithoutSocialInput = {
    id?: string
    name: string
    name_slug: string
    twitter?: string | null
    github?: string | null
    of?: string | null
    url?: string | null
    shows?: ShowGuestCreateNestedManyWithoutGuestInput
  }

  export type GuestUncheckedCreateWithoutSocialInput = {
    id?: string
    name: string
    name_slug: string
    twitter?: string | null
    github?: string | null
    of?: string | null
    url?: string | null
    shows?: ShowGuestUncheckedCreateNestedManyWithoutGuestInput
  }

  export type GuestCreateOrConnectWithoutSocialInput = {
    where: GuestWhereUniqueInput
    create: XOR<GuestCreateWithoutSocialInput, GuestUncheckedCreateWithoutSocialInput>
  }

  export type GuestUpsertWithoutSocialInput = {
    update: XOR<GuestUpdateWithoutSocialInput, GuestUncheckedUpdateWithoutSocialInput>
    create: XOR<GuestCreateWithoutSocialInput, GuestUncheckedCreateWithoutSocialInput>
    where?: GuestWhereInput
  }

  export type GuestUpdateToOneWithWhereWithoutSocialInput = {
    where?: GuestWhereInput
    data: XOR<GuestUpdateWithoutSocialInput, GuestUncheckedUpdateWithoutSocialInput>
  }

  export type GuestUpdateWithoutSocialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_slug?: StringFieldUpdateOperationsInput | string
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    of?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    shows?: ShowGuestUpdateManyWithoutGuestNestedInput
  }

  export type GuestUncheckedUpdateWithoutSocialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_slug?: StringFieldUpdateOperationsInput | string
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    of?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    shows?: ShowGuestUncheckedUpdateManyWithoutGuestNestedInput
  }

  export type ShowGuestCreateWithoutShowInput = {
    id?: string
    Guest: GuestCreateNestedOneWithoutShowsInput
    Transcript?: TranscriptCreateNestedOneWithoutShowGuestInput
  }

  export type ShowGuestUncheckedCreateWithoutShowInput = {
    id?: string
    guestId: string
    transcriptId?: string | null
  }

  export type ShowGuestCreateOrConnectWithoutShowInput = {
    where: ShowGuestWhereUniqueInput
    create: XOR<ShowGuestCreateWithoutShowInput, ShowGuestUncheckedCreateWithoutShowInput>
  }

  export type ShowGuestCreateManyShowInputEnvelope = {
    data: ShowGuestCreateManyShowInput | ShowGuestCreateManyShowInput[]
    skipDuplicates?: boolean
  }

  export type TranscriptCreateWithoutShowInput = {
    id?: string
    utterances?: TranscriptUtteranceCreateNestedManyWithoutTranscriptInput
    ShowGuest?: ShowGuestCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptUncheckedCreateWithoutShowInput = {
    id?: string
    utterances?: TranscriptUtteranceUncheckedCreateNestedManyWithoutTranscriptInput
    ShowGuest?: ShowGuestUncheckedCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptCreateOrConnectWithoutShowInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutShowInput, TranscriptUncheckedCreateWithoutShowInput>
  }

  export type AiShowNoteCreateWithoutShowInput = {
    title: string
    description: string
    provider?: string
    summary?: AiSummaryEntryCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetCreateNestedManyWithoutAiShowNoteInput
    links?: LinkCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteUncheckedCreateWithoutShowInput = {
    id?: number
    title: string
    description: string
    provider?: string
    summary?: AiSummaryEntryUncheckedCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetUncheckedCreateNestedManyWithoutAiShowNoteInput
    links?: LinkUncheckedCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestUncheckedCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicUncheckedCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteCreateOrConnectWithoutShowInput = {
    where: AiShowNoteWhereUniqueInput
    create: XOR<AiShowNoteCreateWithoutShowInput, AiShowNoteUncheckedCreateWithoutShowInput>
  }

  export type ShowVideoCreateWithoutShowInput = {
    video: VideoCreateNestedOneWithoutShowsInput
  }

  export type ShowVideoUncheckedCreateWithoutShowInput = {
    videoId: string
  }

  export type ShowVideoCreateOrConnectWithoutShowInput = {
    where: ShowVideoWhereUniqueInput
    create: XOR<ShowVideoCreateWithoutShowInput, ShowVideoUncheckedCreateWithoutShowInput>
  }

  export type ShowVideoCreateManyShowInputEnvelope = {
    data: ShowVideoCreateManyShowInput | ShowVideoCreateManyShowInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutHostedShowsInput = {
    id?: string
    avatar_url?: string | null
    created_at?: Date | string
    email?: string | null
    github_id: number
    updated_at?: Date | string
    username?: string | null
    theme?: string
    name?: string | null
    twitter?: string | null
    session?: SessionCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHostedShowsInput = {
    id?: string
    avatar_url?: string | null
    created_at?: Date | string
    email?: string | null
    github_id: number
    updated_at?: Date | string
    username?: string | null
    theme?: string
    name?: string | null
    twitter?: string | null
    session?: SessionUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHostedShowsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHostedShowsInput, UserUncheckedCreateWithoutHostedShowsInput>
  }

  export type ShowGuestUpsertWithWhereUniqueWithoutShowInput = {
    where: ShowGuestWhereUniqueInput
    update: XOR<ShowGuestUpdateWithoutShowInput, ShowGuestUncheckedUpdateWithoutShowInput>
    create: XOR<ShowGuestCreateWithoutShowInput, ShowGuestUncheckedCreateWithoutShowInput>
  }

  export type ShowGuestUpdateWithWhereUniqueWithoutShowInput = {
    where: ShowGuestWhereUniqueInput
    data: XOR<ShowGuestUpdateWithoutShowInput, ShowGuestUncheckedUpdateWithoutShowInput>
  }

  export type ShowGuestUpdateManyWithWhereWithoutShowInput = {
    where: ShowGuestScalarWhereInput
    data: XOR<ShowGuestUpdateManyMutationInput, ShowGuestUncheckedUpdateManyWithoutShowInput>
  }

  export type TranscriptUpsertWithoutShowInput = {
    update: XOR<TranscriptUpdateWithoutShowInput, TranscriptUncheckedUpdateWithoutShowInput>
    create: XOR<TranscriptCreateWithoutShowInput, TranscriptUncheckedCreateWithoutShowInput>
    where?: TranscriptWhereInput
  }

  export type TranscriptUpdateToOneWithWhereWithoutShowInput = {
    where?: TranscriptWhereInput
    data: XOR<TranscriptUpdateWithoutShowInput, TranscriptUncheckedUpdateWithoutShowInput>
  }

  export type TranscriptUpdateWithoutShowInput = {
    id?: StringFieldUpdateOperationsInput | string
    utterances?: TranscriptUtteranceUpdateManyWithoutTranscriptNestedInput
    ShowGuest?: ShowGuestUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateWithoutShowInput = {
    id?: StringFieldUpdateOperationsInput | string
    utterances?: TranscriptUtteranceUncheckedUpdateManyWithoutTranscriptNestedInput
    ShowGuest?: ShowGuestUncheckedUpdateManyWithoutTranscriptNestedInput
  }

  export type AiShowNoteUpsertWithoutShowInput = {
    update: XOR<AiShowNoteUpdateWithoutShowInput, AiShowNoteUncheckedUpdateWithoutShowInput>
    create: XOR<AiShowNoteCreateWithoutShowInput, AiShowNoteUncheckedCreateWithoutShowInput>
    where?: AiShowNoteWhereInput
  }

  export type AiShowNoteUpdateToOneWithWhereWithoutShowInput = {
    where?: AiShowNoteWhereInput
    data: XOR<AiShowNoteUpdateWithoutShowInput, AiShowNoteUncheckedUpdateWithoutShowInput>
  }

  export type AiShowNoteUpdateWithoutShowInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    summary?: AiSummaryEntryUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteUncheckedUpdateWithoutShowInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    summary?: AiSummaryEntryUncheckedUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUncheckedUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUncheckedUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUncheckedUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUncheckedUpdateManyWithoutAiShowNoteNestedInput
  }

  export type ShowVideoUpsertWithWhereUniqueWithoutShowInput = {
    where: ShowVideoWhereUniqueInput
    update: XOR<ShowVideoUpdateWithoutShowInput, ShowVideoUncheckedUpdateWithoutShowInput>
    create: XOR<ShowVideoCreateWithoutShowInput, ShowVideoUncheckedCreateWithoutShowInput>
  }

  export type ShowVideoUpdateWithWhereUniqueWithoutShowInput = {
    where: ShowVideoWhereUniqueInput
    data: XOR<ShowVideoUpdateWithoutShowInput, ShowVideoUncheckedUpdateWithoutShowInput>
  }

  export type ShowVideoUpdateManyWithWhereWithoutShowInput = {
    where: ShowVideoScalarWhereInput
    data: XOR<ShowVideoUpdateManyMutationInput, ShowVideoUncheckedUpdateManyWithoutShowInput>
  }

  export type ShowVideoScalarWhereInput = {
    AND?: ShowVideoScalarWhereInput | ShowVideoScalarWhereInput[]
    OR?: ShowVideoScalarWhereInput[]
    NOT?: ShowVideoScalarWhereInput | ShowVideoScalarWhereInput[]
    showId?: StringFilter<"ShowVideo"> | string
    videoId?: StringFilter<"ShowVideo"> | string
  }

  export type UserUpsertWithWhereUniqueWithoutHostedShowsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutHostedShowsInput, UserUncheckedUpdateWithoutHostedShowsInput>
    create: XOR<UserCreateWithoutHostedShowsInput, UserUncheckedCreateWithoutHostedShowsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutHostedShowsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutHostedShowsInput, UserUncheckedUpdateWithoutHostedShowsInput>
  }

  export type UserUpdateManyWithWhereWithoutHostedShowsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutHostedShowsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    avatar_url?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    email?: StringNullableFilter<"User"> | string | null
    github_id?: IntFilter<"User"> | number
    updated_at?: DateTimeFilter<"User"> | Date | string
    username?: StringNullableFilter<"User"> | string | null
    theme?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    twitter?: StringNullableFilter<"User"> | string | null
  }

  export type ShowCreateWithoutTranscriptInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestCreateNestedManyWithoutShowInput
    aiShowNote?: AiShowNoteCreateNestedOneWithoutShowInput
    videos?: ShowVideoCreateNestedManyWithoutShowInput
    hosts?: UserCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowUncheckedCreateWithoutTranscriptInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestUncheckedCreateNestedManyWithoutShowInput
    aiShowNote?: AiShowNoteUncheckedCreateNestedOneWithoutShowInput
    videos?: ShowVideoUncheckedCreateNestedManyWithoutShowInput
    hosts?: UserUncheckedCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowCreateOrConnectWithoutTranscriptInput = {
    where: ShowWhereUniqueInput
    create: XOR<ShowCreateWithoutTranscriptInput, ShowUncheckedCreateWithoutTranscriptInput>
  }

  export type TranscriptUtteranceCreateWithoutTranscriptInput = {
    id?: string
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: string
    speaker: number
    speakerName?: string | null
    words?: TranscriptUtteranceWordCreateNestedManyWithoutTranscriptUtteranceInput
  }

  export type TranscriptUtteranceUncheckedCreateWithoutTranscriptInput = {
    id?: string
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: string
    speaker: number
    speakerName?: string | null
    words?: TranscriptUtteranceWordUncheckedCreateNestedManyWithoutTranscriptUtteranceInput
  }

  export type TranscriptUtteranceCreateOrConnectWithoutTranscriptInput = {
    where: TranscriptUtteranceWhereUniqueInput
    create: XOR<TranscriptUtteranceCreateWithoutTranscriptInput, TranscriptUtteranceUncheckedCreateWithoutTranscriptInput>
  }

  export type TranscriptUtteranceCreateManyTranscriptInputEnvelope = {
    data: TranscriptUtteranceCreateManyTranscriptInput | TranscriptUtteranceCreateManyTranscriptInput[]
    skipDuplicates?: boolean
  }

  export type ShowGuestCreateWithoutTranscriptInput = {
    id?: string
    Show: ShowCreateNestedOneWithoutGuestsInput
    Guest: GuestCreateNestedOneWithoutShowsInput
  }

  export type ShowGuestUncheckedCreateWithoutTranscriptInput = {
    id?: string
    showId: string
    guestId: string
  }

  export type ShowGuestCreateOrConnectWithoutTranscriptInput = {
    where: ShowGuestWhereUniqueInput
    create: XOR<ShowGuestCreateWithoutTranscriptInput, ShowGuestUncheckedCreateWithoutTranscriptInput>
  }

  export type ShowGuestCreateManyTranscriptInputEnvelope = {
    data: ShowGuestCreateManyTranscriptInput | ShowGuestCreateManyTranscriptInput[]
    skipDuplicates?: boolean
  }

  export type ShowUpsertWithoutTranscriptInput = {
    update: XOR<ShowUpdateWithoutTranscriptInput, ShowUncheckedUpdateWithoutTranscriptInput>
    create: XOR<ShowCreateWithoutTranscriptInput, ShowUncheckedCreateWithoutTranscriptInput>
    where?: ShowWhereInput
  }

  export type ShowUpdateToOneWithWhereWithoutTranscriptInput = {
    where?: ShowWhereInput
    data: XOR<ShowUpdateWithoutTranscriptInput, ShowUncheckedUpdateWithoutTranscriptInput>
  }

  export type ShowUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUpdateManyWithoutShowNestedInput
    aiShowNote?: AiShowNoteUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUpdateManyWithoutShowNestedInput
    hosts?: UserUpdateManyWithoutHostedShowsNestedInput
  }

  export type ShowUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUncheckedUpdateManyWithoutShowNestedInput
    aiShowNote?: AiShowNoteUncheckedUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUncheckedUpdateManyWithoutShowNestedInput
    hosts?: UserUncheckedUpdateManyWithoutHostedShowsNestedInput
  }

  export type TranscriptUtteranceUpsertWithWhereUniqueWithoutTranscriptInput = {
    where: TranscriptUtteranceWhereUniqueInput
    update: XOR<TranscriptUtteranceUpdateWithoutTranscriptInput, TranscriptUtteranceUncheckedUpdateWithoutTranscriptInput>
    create: XOR<TranscriptUtteranceCreateWithoutTranscriptInput, TranscriptUtteranceUncheckedCreateWithoutTranscriptInput>
  }

  export type TranscriptUtteranceUpdateWithWhereUniqueWithoutTranscriptInput = {
    where: TranscriptUtteranceWhereUniqueInput
    data: XOR<TranscriptUtteranceUpdateWithoutTranscriptInput, TranscriptUtteranceUncheckedUpdateWithoutTranscriptInput>
  }

  export type TranscriptUtteranceUpdateManyWithWhereWithoutTranscriptInput = {
    where: TranscriptUtteranceScalarWhereInput
    data: XOR<TranscriptUtteranceUpdateManyMutationInput, TranscriptUtteranceUncheckedUpdateManyWithoutTranscriptInput>
  }

  export type TranscriptUtteranceScalarWhereInput = {
    AND?: TranscriptUtteranceScalarWhereInput | TranscriptUtteranceScalarWhereInput[]
    OR?: TranscriptUtteranceScalarWhereInput[]
    NOT?: TranscriptUtteranceScalarWhereInput | TranscriptUtteranceScalarWhereInput[]
    id?: StringFilter<"TranscriptUtterance"> | string
    start?: FloatFilter<"TranscriptUtterance"> | number
    end?: FloatFilter<"TranscriptUtterance"> | number
    confidence?: FloatFilter<"TranscriptUtterance"> | number
    channel?: IntFilter<"TranscriptUtterance"> | number
    transcript_value?: StringFilter<"TranscriptUtterance"> | string
    speaker?: IntFilter<"TranscriptUtterance"> | number
    speakerName?: StringNullableFilter<"TranscriptUtterance"> | string | null
    transcriptId?: StringFilter<"TranscriptUtterance"> | string
  }

  export type ShowGuestUpsertWithWhereUniqueWithoutTranscriptInput = {
    where: ShowGuestWhereUniqueInput
    update: XOR<ShowGuestUpdateWithoutTranscriptInput, ShowGuestUncheckedUpdateWithoutTranscriptInput>
    create: XOR<ShowGuestCreateWithoutTranscriptInput, ShowGuestUncheckedCreateWithoutTranscriptInput>
  }

  export type ShowGuestUpdateWithWhereUniqueWithoutTranscriptInput = {
    where: ShowGuestWhereUniqueInput
    data: XOR<ShowGuestUpdateWithoutTranscriptInput, ShowGuestUncheckedUpdateWithoutTranscriptInput>
  }

  export type ShowGuestUpdateManyWithWhereWithoutTranscriptInput = {
    where: ShowGuestScalarWhereInput
    data: XOR<ShowGuestUpdateManyMutationInput, ShowGuestUncheckedUpdateManyWithoutTranscriptInput>
  }

  export type TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput = {
    id?: string
    word: string
    start: number
    end: number
    confidence: number
    speaker: number
    speaker_confidence: number
    punctuated_word: string
  }

  export type TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput = {
    id?: string
    word: string
    start: number
    end: number
    confidence: number
    speaker: number
    speaker_confidence: number
    punctuated_word: string
  }

  export type TranscriptUtteranceWordCreateOrConnectWithoutTranscriptUtteranceInput = {
    where: TranscriptUtteranceWordWhereUniqueInput
    create: XOR<TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput, TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput>
  }

  export type TranscriptUtteranceWordCreateManyTranscriptUtteranceInputEnvelope = {
    data: TranscriptUtteranceWordCreateManyTranscriptUtteranceInput | TranscriptUtteranceWordCreateManyTranscriptUtteranceInput[]
    skipDuplicates?: boolean
  }

  export type TranscriptCreateWithoutUtterancesInput = {
    id?: string
    show: ShowCreateNestedOneWithoutTranscriptInput
    ShowGuest?: ShowGuestCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptUncheckedCreateWithoutUtterancesInput = {
    id?: string
    show_number: number
    ShowGuest?: ShowGuestUncheckedCreateNestedManyWithoutTranscriptInput
  }

  export type TranscriptCreateOrConnectWithoutUtterancesInput = {
    where: TranscriptWhereUniqueInput
    create: XOR<TranscriptCreateWithoutUtterancesInput, TranscriptUncheckedCreateWithoutUtterancesInput>
  }

  export type TranscriptUtteranceWordUpsertWithWhereUniqueWithoutTranscriptUtteranceInput = {
    where: TranscriptUtteranceWordWhereUniqueInput
    update: XOR<TranscriptUtteranceWordUpdateWithoutTranscriptUtteranceInput, TranscriptUtteranceWordUncheckedUpdateWithoutTranscriptUtteranceInput>
    create: XOR<TranscriptUtteranceWordCreateWithoutTranscriptUtteranceInput, TranscriptUtteranceWordUncheckedCreateWithoutTranscriptUtteranceInput>
  }

  export type TranscriptUtteranceWordUpdateWithWhereUniqueWithoutTranscriptUtteranceInput = {
    where: TranscriptUtteranceWordWhereUniqueInput
    data: XOR<TranscriptUtteranceWordUpdateWithoutTranscriptUtteranceInput, TranscriptUtteranceWordUncheckedUpdateWithoutTranscriptUtteranceInput>
  }

  export type TranscriptUtteranceWordUpdateManyWithWhereWithoutTranscriptUtteranceInput = {
    where: TranscriptUtteranceWordScalarWhereInput
    data: XOR<TranscriptUtteranceWordUpdateManyMutationInput, TranscriptUtteranceWordUncheckedUpdateManyWithoutTranscriptUtteranceInput>
  }

  export type TranscriptUtteranceWordScalarWhereInput = {
    AND?: TranscriptUtteranceWordScalarWhereInput | TranscriptUtteranceWordScalarWhereInput[]
    OR?: TranscriptUtteranceWordScalarWhereInput[]
    NOT?: TranscriptUtteranceWordScalarWhereInput | TranscriptUtteranceWordScalarWhereInput[]
    id?: StringFilter<"TranscriptUtteranceWord"> | string
    word?: StringFilter<"TranscriptUtteranceWord"> | string
    start?: FloatFilter<"TranscriptUtteranceWord"> | number
    end?: FloatFilter<"TranscriptUtteranceWord"> | number
    confidence?: FloatFilter<"TranscriptUtteranceWord"> | number
    speaker?: IntFilter<"TranscriptUtteranceWord"> | number
    speaker_confidence?: FloatFilter<"TranscriptUtteranceWord"> | number
    punctuated_word?: StringFilter<"TranscriptUtteranceWord"> | string
    transcriptUtteranceId?: StringFilter<"TranscriptUtteranceWord"> | string
  }

  export type TranscriptUpsertWithoutUtterancesInput = {
    update: XOR<TranscriptUpdateWithoutUtterancesInput, TranscriptUncheckedUpdateWithoutUtterancesInput>
    create: XOR<TranscriptCreateWithoutUtterancesInput, TranscriptUncheckedCreateWithoutUtterancesInput>
    where?: TranscriptWhereInput
  }

  export type TranscriptUpdateToOneWithWhereWithoutUtterancesInput = {
    where?: TranscriptWhereInput
    data: XOR<TranscriptUpdateWithoutUtterancesInput, TranscriptUncheckedUpdateWithoutUtterancesInput>
  }

  export type TranscriptUpdateWithoutUtterancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    show?: ShowUpdateOneRequiredWithoutTranscriptNestedInput
    ShowGuest?: ShowGuestUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptUncheckedUpdateWithoutUtterancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    show_number?: IntFieldUpdateOperationsInput | number
    ShowGuest?: ShowGuestUncheckedUpdateManyWithoutTranscriptNestedInput
  }

  export type TranscriptUtteranceCreateWithoutWordsInput = {
    id?: string
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: string
    speaker: number
    speakerName?: string | null
    transcript: TranscriptCreateNestedOneWithoutUtterancesInput
  }

  export type TranscriptUtteranceUncheckedCreateWithoutWordsInput = {
    id?: string
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: string
    speaker: number
    speakerName?: string | null
    transcriptId: string
  }

  export type TranscriptUtteranceCreateOrConnectWithoutWordsInput = {
    where: TranscriptUtteranceWhereUniqueInput
    create: XOR<TranscriptUtteranceCreateWithoutWordsInput, TranscriptUtteranceUncheckedCreateWithoutWordsInput>
  }

  export type TranscriptUtteranceUpsertWithoutWordsInput = {
    update: XOR<TranscriptUtteranceUpdateWithoutWordsInput, TranscriptUtteranceUncheckedUpdateWithoutWordsInput>
    create: XOR<TranscriptUtteranceCreateWithoutWordsInput, TranscriptUtteranceUncheckedCreateWithoutWordsInput>
    where?: TranscriptUtteranceWhereInput
  }

  export type TranscriptUtteranceUpdateToOneWithWhereWithoutWordsInput = {
    where?: TranscriptUtteranceWhereInput
    data: XOR<TranscriptUtteranceUpdateWithoutWordsInput, TranscriptUtteranceUncheckedUpdateWithoutWordsInput>
  }

  export type TranscriptUtteranceUpdateWithoutWordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    channel?: IntFieldUpdateOperationsInput | number
    transcript_value?: StringFieldUpdateOperationsInput | string
    speaker?: IntFieldUpdateOperationsInput | number
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: TranscriptUpdateOneRequiredWithoutUtterancesNestedInput
  }

  export type TranscriptUtteranceUncheckedUpdateWithoutWordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    channel?: IntFieldUpdateOperationsInput | number
    transcript_value?: StringFieldUpdateOperationsInput | string
    speaker?: IntFieldUpdateOperationsInput | number
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    transcriptId?: StringFieldUpdateOperationsInput | string
  }

  export type ShowCreateWithoutAiShowNoteInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestCreateNestedManyWithoutShowInput
    transcript?: TranscriptCreateNestedOneWithoutShowInput
    videos?: ShowVideoCreateNestedManyWithoutShowInput
    hosts?: UserCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowUncheckedCreateWithoutAiShowNoteInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestUncheckedCreateNestedManyWithoutShowInput
    transcript?: TranscriptUncheckedCreateNestedOneWithoutShowInput
    videos?: ShowVideoUncheckedCreateNestedManyWithoutShowInput
    hosts?: UserUncheckedCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowCreateOrConnectWithoutAiShowNoteInput = {
    where: ShowWhereUniqueInput
    create: XOR<ShowCreateWithoutAiShowNoteInput, ShowUncheckedCreateWithoutAiShowNoteInput>
  }

  export type AiSummaryEntryCreateWithoutAiShowNoteInput = {
    time: string
    text: string
    description?: string | null
  }

  export type AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput = {
    id?: number
    time: string
    text: string
    description?: string | null
  }

  export type AiSummaryEntryCreateOrConnectWithoutAiShowNoteInput = {
    where: AiSummaryEntryWhereUniqueInput
    create: XOR<AiSummaryEntryCreateWithoutAiShowNoteInput, AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput>
  }

  export type AiSummaryEntryCreateManyAiShowNoteInputEnvelope = {
    data: AiSummaryEntryCreateManyAiShowNoteInput | AiSummaryEntryCreateManyAiShowNoteInput[]
    skipDuplicates?: boolean
  }

  export type AiTweetCreateWithoutAiShowNoteInput = {
    content: string
  }

  export type AiTweetUncheckedCreateWithoutAiShowNoteInput = {
    id?: number
    content: string
  }

  export type AiTweetCreateOrConnectWithoutAiShowNoteInput = {
    where: AiTweetWhereUniqueInput
    create: XOR<AiTweetCreateWithoutAiShowNoteInput, AiTweetUncheckedCreateWithoutAiShowNoteInput>
  }

  export type AiTweetCreateManyAiShowNoteInputEnvelope = {
    data: AiTweetCreateManyAiShowNoteInput | AiTweetCreateManyAiShowNoteInput[]
    skipDuplicates?: boolean
  }

  export type LinkCreateWithoutAiShowNoteInput = {
    name: string
    url: string
    timestamp?: string | null
  }

  export type LinkUncheckedCreateWithoutAiShowNoteInput = {
    id?: number
    name: string
    url: string
    timestamp?: string | null
  }

  export type LinkCreateOrConnectWithoutAiShowNoteInput = {
    where: LinkWhereUniqueInput
    create: XOR<LinkCreateWithoutAiShowNoteInput, LinkUncheckedCreateWithoutAiShowNoteInput>
  }

  export type LinkCreateManyAiShowNoteInputEnvelope = {
    data: LinkCreateManyAiShowNoteInput | LinkCreateManyAiShowNoteInput[]
    skipDuplicates?: boolean
  }

  export type AiGuestCreateWithoutAiShowNoteInput = {
    name: string
  }

  export type AiGuestUncheckedCreateWithoutAiShowNoteInput = {
    id?: number
    name: string
  }

  export type AiGuestCreateOrConnectWithoutAiShowNoteInput = {
    where: AiGuestWhereUniqueInput
    create: XOR<AiGuestCreateWithoutAiShowNoteInput, AiGuestUncheckedCreateWithoutAiShowNoteInput>
  }

  export type AiGuestCreateManyAiShowNoteInputEnvelope = {
    data: AiGuestCreateManyAiShowNoteInput | AiGuestCreateManyAiShowNoteInput[]
    skipDuplicates?: boolean
  }

  export type TopicCreateWithoutAiShowNoteInput = {
    name: string
  }

  export type TopicUncheckedCreateWithoutAiShowNoteInput = {
    id?: number
    name: string
  }

  export type TopicCreateOrConnectWithoutAiShowNoteInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutAiShowNoteInput, TopicUncheckedCreateWithoutAiShowNoteInput>
  }

  export type TopicCreateManyAiShowNoteInputEnvelope = {
    data: TopicCreateManyAiShowNoteInput | TopicCreateManyAiShowNoteInput[]
    skipDuplicates?: boolean
  }

  export type ShowUpsertWithoutAiShowNoteInput = {
    update: XOR<ShowUpdateWithoutAiShowNoteInput, ShowUncheckedUpdateWithoutAiShowNoteInput>
    create: XOR<ShowCreateWithoutAiShowNoteInput, ShowUncheckedCreateWithoutAiShowNoteInput>
    where?: ShowWhereInput
  }

  export type ShowUpdateToOneWithWhereWithoutAiShowNoteInput = {
    where?: ShowWhereInput
    data: XOR<ShowUpdateWithoutAiShowNoteInput, ShowUncheckedUpdateWithoutAiShowNoteInput>
  }

  export type ShowUpdateWithoutAiShowNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUpdateManyWithoutShowNestedInput
    transcript?: TranscriptUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUpdateManyWithoutShowNestedInput
    hosts?: UserUpdateManyWithoutHostedShowsNestedInput
  }

  export type ShowUncheckedUpdateWithoutAiShowNoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUncheckedUpdateManyWithoutShowNestedInput
    transcript?: TranscriptUncheckedUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUncheckedUpdateManyWithoutShowNestedInput
    hosts?: UserUncheckedUpdateManyWithoutHostedShowsNestedInput
  }

  export type AiSummaryEntryUpsertWithWhereUniqueWithoutAiShowNoteInput = {
    where: AiSummaryEntryWhereUniqueInput
    update: XOR<AiSummaryEntryUpdateWithoutAiShowNoteInput, AiSummaryEntryUncheckedUpdateWithoutAiShowNoteInput>
    create: XOR<AiSummaryEntryCreateWithoutAiShowNoteInput, AiSummaryEntryUncheckedCreateWithoutAiShowNoteInput>
  }

  export type AiSummaryEntryUpdateWithWhereUniqueWithoutAiShowNoteInput = {
    where: AiSummaryEntryWhereUniqueInput
    data: XOR<AiSummaryEntryUpdateWithoutAiShowNoteInput, AiSummaryEntryUncheckedUpdateWithoutAiShowNoteInput>
  }

  export type AiSummaryEntryUpdateManyWithWhereWithoutAiShowNoteInput = {
    where: AiSummaryEntryScalarWhereInput
    data: XOR<AiSummaryEntryUpdateManyMutationInput, AiSummaryEntryUncheckedUpdateManyWithoutAiShowNoteInput>
  }

  export type AiSummaryEntryScalarWhereInput = {
    AND?: AiSummaryEntryScalarWhereInput | AiSummaryEntryScalarWhereInput[]
    OR?: AiSummaryEntryScalarWhereInput[]
    NOT?: AiSummaryEntryScalarWhereInput | AiSummaryEntryScalarWhereInput[]
    id?: IntFilter<"AiSummaryEntry"> | number
    time?: StringFilter<"AiSummaryEntry"> | string
    text?: StringFilter<"AiSummaryEntry"> | string
    description?: StringNullableFilter<"AiSummaryEntry"> | string | null
    showNote?: IntFilter<"AiSummaryEntry"> | number
  }

  export type AiTweetUpsertWithWhereUniqueWithoutAiShowNoteInput = {
    where: AiTweetWhereUniqueInput
    update: XOR<AiTweetUpdateWithoutAiShowNoteInput, AiTweetUncheckedUpdateWithoutAiShowNoteInput>
    create: XOR<AiTweetCreateWithoutAiShowNoteInput, AiTweetUncheckedCreateWithoutAiShowNoteInput>
  }

  export type AiTweetUpdateWithWhereUniqueWithoutAiShowNoteInput = {
    where: AiTweetWhereUniqueInput
    data: XOR<AiTweetUpdateWithoutAiShowNoteInput, AiTweetUncheckedUpdateWithoutAiShowNoteInput>
  }

  export type AiTweetUpdateManyWithWhereWithoutAiShowNoteInput = {
    where: AiTweetScalarWhereInput
    data: XOR<AiTweetUpdateManyMutationInput, AiTweetUncheckedUpdateManyWithoutAiShowNoteInput>
  }

  export type AiTweetScalarWhereInput = {
    AND?: AiTweetScalarWhereInput | AiTweetScalarWhereInput[]
    OR?: AiTweetScalarWhereInput[]
    NOT?: AiTweetScalarWhereInput | AiTweetScalarWhereInput[]
    id?: IntFilter<"AiTweet"> | number
    content?: StringFilter<"AiTweet"> | string
    showNote?: IntFilter<"AiTweet"> | number
  }

  export type LinkUpsertWithWhereUniqueWithoutAiShowNoteInput = {
    where: LinkWhereUniqueInput
    update: XOR<LinkUpdateWithoutAiShowNoteInput, LinkUncheckedUpdateWithoutAiShowNoteInput>
    create: XOR<LinkCreateWithoutAiShowNoteInput, LinkUncheckedCreateWithoutAiShowNoteInput>
  }

  export type LinkUpdateWithWhereUniqueWithoutAiShowNoteInput = {
    where: LinkWhereUniqueInput
    data: XOR<LinkUpdateWithoutAiShowNoteInput, LinkUncheckedUpdateWithoutAiShowNoteInput>
  }

  export type LinkUpdateManyWithWhereWithoutAiShowNoteInput = {
    where: LinkScalarWhereInput
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyWithoutAiShowNoteInput>
  }

  export type LinkScalarWhereInput = {
    AND?: LinkScalarWhereInput | LinkScalarWhereInput[]
    OR?: LinkScalarWhereInput[]
    NOT?: LinkScalarWhereInput | LinkScalarWhereInput[]
    id?: IntFilter<"Link"> | number
    name?: StringFilter<"Link"> | string
    url?: StringFilter<"Link"> | string
    timestamp?: StringNullableFilter<"Link"> | string | null
    showNote?: IntFilter<"Link"> | number
  }

  export type AiGuestUpsertWithWhereUniqueWithoutAiShowNoteInput = {
    where: AiGuestWhereUniqueInput
    update: XOR<AiGuestUpdateWithoutAiShowNoteInput, AiGuestUncheckedUpdateWithoutAiShowNoteInput>
    create: XOR<AiGuestCreateWithoutAiShowNoteInput, AiGuestUncheckedCreateWithoutAiShowNoteInput>
  }

  export type AiGuestUpdateWithWhereUniqueWithoutAiShowNoteInput = {
    where: AiGuestWhereUniqueInput
    data: XOR<AiGuestUpdateWithoutAiShowNoteInput, AiGuestUncheckedUpdateWithoutAiShowNoteInput>
  }

  export type AiGuestUpdateManyWithWhereWithoutAiShowNoteInput = {
    where: AiGuestScalarWhereInput
    data: XOR<AiGuestUpdateManyMutationInput, AiGuestUncheckedUpdateManyWithoutAiShowNoteInput>
  }

  export type AiGuestScalarWhereInput = {
    AND?: AiGuestScalarWhereInput | AiGuestScalarWhereInput[]
    OR?: AiGuestScalarWhereInput[]
    NOT?: AiGuestScalarWhereInput | AiGuestScalarWhereInput[]
    id?: IntFilter<"AiGuest"> | number
    name?: StringFilter<"AiGuest"> | string
    showNote?: IntFilter<"AiGuest"> | number
  }

  export type TopicUpsertWithWhereUniqueWithoutAiShowNoteInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutAiShowNoteInput, TopicUncheckedUpdateWithoutAiShowNoteInput>
    create: XOR<TopicCreateWithoutAiShowNoteInput, TopicUncheckedCreateWithoutAiShowNoteInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutAiShowNoteInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutAiShowNoteInput, TopicUncheckedUpdateWithoutAiShowNoteInput>
  }

  export type TopicUpdateManyWithWhereWithoutAiShowNoteInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutAiShowNoteInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: IntFilter<"Topic"> | number
    name?: StringFilter<"Topic"> | string
    showNote?: IntFilter<"Topic"> | number
  }

  export type AiShowNoteCreateWithoutSummaryInput = {
    title: string
    description: string
    provider?: string
    show: ShowCreateNestedOneWithoutAiShowNoteInput
    tweets?: AiTweetCreateNestedManyWithoutAiShowNoteInput
    links?: LinkCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteUncheckedCreateWithoutSummaryInput = {
    id?: number
    show_number: number
    title: string
    description: string
    provider?: string
    tweets?: AiTweetUncheckedCreateNestedManyWithoutAiShowNoteInput
    links?: LinkUncheckedCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestUncheckedCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicUncheckedCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteCreateOrConnectWithoutSummaryInput = {
    where: AiShowNoteWhereUniqueInput
    create: XOR<AiShowNoteCreateWithoutSummaryInput, AiShowNoteUncheckedCreateWithoutSummaryInput>
  }

  export type AiShowNoteUpsertWithoutSummaryInput = {
    update: XOR<AiShowNoteUpdateWithoutSummaryInput, AiShowNoteUncheckedUpdateWithoutSummaryInput>
    create: XOR<AiShowNoteCreateWithoutSummaryInput, AiShowNoteUncheckedCreateWithoutSummaryInput>
    where?: AiShowNoteWhereInput
  }

  export type AiShowNoteUpdateToOneWithWhereWithoutSummaryInput = {
    where?: AiShowNoteWhereInput
    data: XOR<AiShowNoteUpdateWithoutSummaryInput, AiShowNoteUncheckedUpdateWithoutSummaryInput>
  }

  export type AiShowNoteUpdateWithoutSummaryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    show?: ShowUpdateOneRequiredWithoutAiShowNoteNestedInput
    tweets?: AiTweetUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteUncheckedUpdateWithoutSummaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    show_number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    tweets?: AiTweetUncheckedUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUncheckedUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUncheckedUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUncheckedUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteCreateWithoutTweetsInput = {
    title: string
    description: string
    provider?: string
    show: ShowCreateNestedOneWithoutAiShowNoteInput
    summary?: AiSummaryEntryCreateNestedManyWithoutAiShowNoteInput
    links?: LinkCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteUncheckedCreateWithoutTweetsInput = {
    id?: number
    show_number: number
    title: string
    description: string
    provider?: string
    summary?: AiSummaryEntryUncheckedCreateNestedManyWithoutAiShowNoteInput
    links?: LinkUncheckedCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestUncheckedCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicUncheckedCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteCreateOrConnectWithoutTweetsInput = {
    where: AiShowNoteWhereUniqueInput
    create: XOR<AiShowNoteCreateWithoutTweetsInput, AiShowNoteUncheckedCreateWithoutTweetsInput>
  }

  export type AiShowNoteUpsertWithoutTweetsInput = {
    update: XOR<AiShowNoteUpdateWithoutTweetsInput, AiShowNoteUncheckedUpdateWithoutTweetsInput>
    create: XOR<AiShowNoteCreateWithoutTweetsInput, AiShowNoteUncheckedCreateWithoutTweetsInput>
    where?: AiShowNoteWhereInput
  }

  export type AiShowNoteUpdateToOneWithWhereWithoutTweetsInput = {
    where?: AiShowNoteWhereInput
    data: XOR<AiShowNoteUpdateWithoutTweetsInput, AiShowNoteUncheckedUpdateWithoutTweetsInput>
  }

  export type AiShowNoteUpdateWithoutTweetsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    show?: ShowUpdateOneRequiredWithoutAiShowNoteNestedInput
    summary?: AiSummaryEntryUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteUncheckedUpdateWithoutTweetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    show_number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    summary?: AiSummaryEntryUncheckedUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUncheckedUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUncheckedUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUncheckedUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteCreateWithoutLinksInput = {
    title: string
    description: string
    provider?: string
    show: ShowCreateNestedOneWithoutAiShowNoteInput
    summary?: AiSummaryEntryCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteUncheckedCreateWithoutLinksInput = {
    id?: number
    show_number: number
    title: string
    description: string
    provider?: string
    summary?: AiSummaryEntryUncheckedCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetUncheckedCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestUncheckedCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicUncheckedCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteCreateOrConnectWithoutLinksInput = {
    where: AiShowNoteWhereUniqueInput
    create: XOR<AiShowNoteCreateWithoutLinksInput, AiShowNoteUncheckedCreateWithoutLinksInput>
  }

  export type AiShowNoteUpsertWithoutLinksInput = {
    update: XOR<AiShowNoteUpdateWithoutLinksInput, AiShowNoteUncheckedUpdateWithoutLinksInput>
    create: XOR<AiShowNoteCreateWithoutLinksInput, AiShowNoteUncheckedCreateWithoutLinksInput>
    where?: AiShowNoteWhereInput
  }

  export type AiShowNoteUpdateToOneWithWhereWithoutLinksInput = {
    where?: AiShowNoteWhereInput
    data: XOR<AiShowNoteUpdateWithoutLinksInput, AiShowNoteUncheckedUpdateWithoutLinksInput>
  }

  export type AiShowNoteUpdateWithoutLinksInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    show?: ShowUpdateOneRequiredWithoutAiShowNoteNestedInput
    summary?: AiSummaryEntryUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteUncheckedUpdateWithoutLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    show_number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    summary?: AiSummaryEntryUncheckedUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUncheckedUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUncheckedUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUncheckedUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteCreateWithoutGuestsInput = {
    title: string
    description: string
    provider?: string
    show: ShowCreateNestedOneWithoutAiShowNoteInput
    summary?: AiSummaryEntryCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetCreateNestedManyWithoutAiShowNoteInput
    links?: LinkCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteUncheckedCreateWithoutGuestsInput = {
    id?: number
    show_number: number
    title: string
    description: string
    provider?: string
    summary?: AiSummaryEntryUncheckedCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetUncheckedCreateNestedManyWithoutAiShowNoteInput
    links?: LinkUncheckedCreateNestedManyWithoutAiShowNoteInput
    topics?: TopicUncheckedCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteCreateOrConnectWithoutGuestsInput = {
    where: AiShowNoteWhereUniqueInput
    create: XOR<AiShowNoteCreateWithoutGuestsInput, AiShowNoteUncheckedCreateWithoutGuestsInput>
  }

  export type AiShowNoteUpsertWithoutGuestsInput = {
    update: XOR<AiShowNoteUpdateWithoutGuestsInput, AiShowNoteUncheckedUpdateWithoutGuestsInput>
    create: XOR<AiShowNoteCreateWithoutGuestsInput, AiShowNoteUncheckedCreateWithoutGuestsInput>
    where?: AiShowNoteWhereInput
  }

  export type AiShowNoteUpdateToOneWithWhereWithoutGuestsInput = {
    where?: AiShowNoteWhereInput
    data: XOR<AiShowNoteUpdateWithoutGuestsInput, AiShowNoteUncheckedUpdateWithoutGuestsInput>
  }

  export type AiShowNoteUpdateWithoutGuestsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    show?: ShowUpdateOneRequiredWithoutAiShowNoteNestedInput
    summary?: AiSummaryEntryUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteUncheckedUpdateWithoutGuestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    show_number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    summary?: AiSummaryEntryUncheckedUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUncheckedUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUncheckedUpdateManyWithoutAiShowNoteNestedInput
    topics?: TopicUncheckedUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteCreateWithoutTopicsInput = {
    title: string
    description: string
    provider?: string
    show: ShowCreateNestedOneWithoutAiShowNoteInput
    summary?: AiSummaryEntryCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetCreateNestedManyWithoutAiShowNoteInput
    links?: LinkCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteUncheckedCreateWithoutTopicsInput = {
    id?: number
    show_number: number
    title: string
    description: string
    provider?: string
    summary?: AiSummaryEntryUncheckedCreateNestedManyWithoutAiShowNoteInput
    tweets?: AiTweetUncheckedCreateNestedManyWithoutAiShowNoteInput
    links?: LinkUncheckedCreateNestedManyWithoutAiShowNoteInput
    guests?: AiGuestUncheckedCreateNestedManyWithoutAiShowNoteInput
  }

  export type AiShowNoteCreateOrConnectWithoutTopicsInput = {
    where: AiShowNoteWhereUniqueInput
    create: XOR<AiShowNoteCreateWithoutTopicsInput, AiShowNoteUncheckedCreateWithoutTopicsInput>
  }

  export type AiShowNoteUpsertWithoutTopicsInput = {
    update: XOR<AiShowNoteUpdateWithoutTopicsInput, AiShowNoteUncheckedUpdateWithoutTopicsInput>
    create: XOR<AiShowNoteCreateWithoutTopicsInput, AiShowNoteUncheckedCreateWithoutTopicsInput>
    where?: AiShowNoteWhereInput
  }

  export type AiShowNoteUpdateToOneWithWhereWithoutTopicsInput = {
    where?: AiShowNoteWhereInput
    data: XOR<AiShowNoteUpdateWithoutTopicsInput, AiShowNoteUncheckedUpdateWithoutTopicsInput>
  }

  export type AiShowNoteUpdateWithoutTopicsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    show?: ShowUpdateOneRequiredWithoutAiShowNoteNestedInput
    summary?: AiSummaryEntryUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUpdateManyWithoutAiShowNoteNestedInput
  }

  export type AiShowNoteUncheckedUpdateWithoutTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    show_number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    summary?: AiSummaryEntryUncheckedUpdateManyWithoutAiShowNoteNestedInput
    tweets?: AiTweetUncheckedUpdateManyWithoutAiShowNoteNestedInput
    links?: LinkUncheckedUpdateManyWithoutAiShowNoteNestedInput
    guests?: AiGuestUncheckedUpdateManyWithoutAiShowNoteNestedInput
  }

  export type PlaylistOnVideoCreateWithoutVideoInput = {
    order: number
    playlist: PlaylistCreateNestedOneWithoutVideosInput
  }

  export type PlaylistOnVideoUncheckedCreateWithoutVideoInput = {
    playlist_id: string
    order: number
  }

  export type PlaylistOnVideoCreateOrConnectWithoutVideoInput = {
    where: PlaylistOnVideoWhereUniqueInput
    create: XOR<PlaylistOnVideoCreateWithoutVideoInput, PlaylistOnVideoUncheckedCreateWithoutVideoInput>
  }

  export type PlaylistOnVideoCreateManyVideoInputEnvelope = {
    data: PlaylistOnVideoCreateManyVideoInput | PlaylistOnVideoCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type ShowVideoCreateWithoutVideoInput = {
    show: ShowCreateNestedOneWithoutVideosInput
  }

  export type ShowVideoUncheckedCreateWithoutVideoInput = {
    showId: string
  }

  export type ShowVideoCreateOrConnectWithoutVideoInput = {
    where: ShowVideoWhereUniqueInput
    create: XOR<ShowVideoCreateWithoutVideoInput, ShowVideoUncheckedCreateWithoutVideoInput>
  }

  export type ShowVideoCreateManyVideoInputEnvelope = {
    data: ShowVideoCreateManyVideoInput | ShowVideoCreateManyVideoInput[]
    skipDuplicates?: boolean
  }

  export type PlaylistOnVideoUpsertWithWhereUniqueWithoutVideoInput = {
    where: PlaylistOnVideoWhereUniqueInput
    update: XOR<PlaylistOnVideoUpdateWithoutVideoInput, PlaylistOnVideoUncheckedUpdateWithoutVideoInput>
    create: XOR<PlaylistOnVideoCreateWithoutVideoInput, PlaylistOnVideoUncheckedCreateWithoutVideoInput>
  }

  export type PlaylistOnVideoUpdateWithWhereUniqueWithoutVideoInput = {
    where: PlaylistOnVideoWhereUniqueInput
    data: XOR<PlaylistOnVideoUpdateWithoutVideoInput, PlaylistOnVideoUncheckedUpdateWithoutVideoInput>
  }

  export type PlaylistOnVideoUpdateManyWithWhereWithoutVideoInput = {
    where: PlaylistOnVideoScalarWhereInput
    data: XOR<PlaylistOnVideoUpdateManyMutationInput, PlaylistOnVideoUncheckedUpdateManyWithoutVideoInput>
  }

  export type PlaylistOnVideoScalarWhereInput = {
    AND?: PlaylistOnVideoScalarWhereInput | PlaylistOnVideoScalarWhereInput[]
    OR?: PlaylistOnVideoScalarWhereInput[]
    NOT?: PlaylistOnVideoScalarWhereInput | PlaylistOnVideoScalarWhereInput[]
    video_id?: StringFilter<"PlaylistOnVideo"> | string
    playlist_id?: StringFilter<"PlaylistOnVideo"> | string
    order?: IntFilter<"PlaylistOnVideo"> | number
  }

  export type ShowVideoUpsertWithWhereUniqueWithoutVideoInput = {
    where: ShowVideoWhereUniqueInput
    update: XOR<ShowVideoUpdateWithoutVideoInput, ShowVideoUncheckedUpdateWithoutVideoInput>
    create: XOR<ShowVideoCreateWithoutVideoInput, ShowVideoUncheckedCreateWithoutVideoInput>
  }

  export type ShowVideoUpdateWithWhereUniqueWithoutVideoInput = {
    where: ShowVideoWhereUniqueInput
    data: XOR<ShowVideoUpdateWithoutVideoInput, ShowVideoUncheckedUpdateWithoutVideoInput>
  }

  export type ShowVideoUpdateManyWithWhereWithoutVideoInput = {
    where: ShowVideoScalarWhereInput
    data: XOR<ShowVideoUpdateManyMutationInput, ShowVideoUncheckedUpdateManyWithoutVideoInput>
  }

  export type PlaylistOnVideoCreateWithoutPlaylistInput = {
    order: number
    video: VideoCreateNestedOneWithoutPlaylistsInput
  }

  export type PlaylistOnVideoUncheckedCreateWithoutPlaylistInput = {
    video_id: string
    order: number
  }

  export type PlaylistOnVideoCreateOrConnectWithoutPlaylistInput = {
    where: PlaylistOnVideoWhereUniqueInput
    create: XOR<PlaylistOnVideoCreateWithoutPlaylistInput, PlaylistOnVideoUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistOnVideoCreateManyPlaylistInputEnvelope = {
    data: PlaylistOnVideoCreateManyPlaylistInput | PlaylistOnVideoCreateManyPlaylistInput[]
    skipDuplicates?: boolean
  }

  export type PlaylistOnVideoUpsertWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistOnVideoWhereUniqueInput
    update: XOR<PlaylistOnVideoUpdateWithoutPlaylistInput, PlaylistOnVideoUncheckedUpdateWithoutPlaylistInput>
    create: XOR<PlaylistOnVideoCreateWithoutPlaylistInput, PlaylistOnVideoUncheckedCreateWithoutPlaylistInput>
  }

  export type PlaylistOnVideoUpdateWithWhereUniqueWithoutPlaylistInput = {
    where: PlaylistOnVideoWhereUniqueInput
    data: XOR<PlaylistOnVideoUpdateWithoutPlaylistInput, PlaylistOnVideoUncheckedUpdateWithoutPlaylistInput>
  }

  export type PlaylistOnVideoUpdateManyWithWhereWithoutPlaylistInput = {
    where: PlaylistOnVideoScalarWhereInput
    data: XOR<PlaylistOnVideoUpdateManyMutationInput, PlaylistOnVideoUncheckedUpdateManyWithoutPlaylistInput>
  }

  export type VideoCreateWithoutPlaylistsInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    published_at: Date | string
    thumbnail: string
    slug: string
    shows?: ShowVideoCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutPlaylistsInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    published_at: Date | string
    thumbnail: string
    slug: string
    shows?: ShowVideoUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutPlaylistsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutPlaylistsInput, VideoUncheckedCreateWithoutPlaylistsInput>
  }

  export type PlaylistCreateWithoutVideosInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    slug: string
    unlisted?: boolean | null
  }

  export type PlaylistUncheckedCreateWithoutVideosInput = {
    id?: string
    title: string
    description?: string | null
    created_at?: Date | string
    slug: string
    unlisted?: boolean | null
  }

  export type PlaylistCreateOrConnectWithoutVideosInput = {
    where: PlaylistWhereUniqueInput
    create: XOR<PlaylistCreateWithoutVideosInput, PlaylistUncheckedCreateWithoutVideosInput>
  }

  export type VideoUpsertWithoutPlaylistsInput = {
    update: XOR<VideoUpdateWithoutPlaylistsInput, VideoUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<VideoCreateWithoutPlaylistsInput, VideoUncheckedCreateWithoutPlaylistsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutPlaylistsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutPlaylistsInput, VideoUncheckedUpdateWithoutPlaylistsInput>
  }

  export type VideoUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    published_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shows?: ShowVideoUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    published_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shows?: ShowVideoUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type PlaylistUpsertWithoutVideosInput = {
    update: XOR<PlaylistUpdateWithoutVideosInput, PlaylistUncheckedUpdateWithoutVideosInput>
    create: XOR<PlaylistCreateWithoutVideosInput, PlaylistUncheckedCreateWithoutVideosInput>
    where?: PlaylistWhereInput
  }

  export type PlaylistUpdateToOneWithWhereWithoutVideosInput = {
    where?: PlaylistWhereInput
    data: XOR<PlaylistUpdateWithoutVideosInput, PlaylistUncheckedUpdateWithoutVideosInput>
  }

  export type PlaylistUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    unlisted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PlaylistUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    unlisted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ShowCreateWithoutVideosInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestCreateNestedManyWithoutShowInput
    transcript?: TranscriptCreateNestedOneWithoutShowInput
    aiShowNote?: AiShowNoteCreateNestedOneWithoutShowInput
    hosts?: UserCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowUncheckedCreateWithoutVideosInput = {
    id: string
    number: number
    title: string
    date: Date | string
    url: string
    youtube_url?: string | null
    spotify_id?: string | null
    show_notes: string
    hash: string
    slug: string
    md_file: string
    created_at?: Date | string
    updated_at?: Date | string
    show_type?: $Enums.ShowType
    guests?: ShowGuestUncheckedCreateNestedManyWithoutShowInput
    transcript?: TranscriptUncheckedCreateNestedOneWithoutShowInput
    aiShowNote?: AiShowNoteUncheckedCreateNestedOneWithoutShowInput
    hosts?: UserUncheckedCreateNestedManyWithoutHostedShowsInput
  }

  export type ShowCreateOrConnectWithoutVideosInput = {
    where: ShowWhereUniqueInput
    create: XOR<ShowCreateWithoutVideosInput, ShowUncheckedCreateWithoutVideosInput>
  }

  export type VideoCreateWithoutShowsInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    published_at: Date | string
    thumbnail: string
    slug: string
    playlists?: PlaylistOnVideoCreateNestedManyWithoutVideoInput
  }

  export type VideoUncheckedCreateWithoutShowsInput = {
    id?: string
    title: string
    description?: string | null
    url: string
    published_at: Date | string
    thumbnail: string
    slug: string
    playlists?: PlaylistOnVideoUncheckedCreateNestedManyWithoutVideoInput
  }

  export type VideoCreateOrConnectWithoutShowsInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutShowsInput, VideoUncheckedCreateWithoutShowsInput>
  }

  export type ShowUpsertWithoutVideosInput = {
    update: XOR<ShowUpdateWithoutVideosInput, ShowUncheckedUpdateWithoutVideosInput>
    create: XOR<ShowCreateWithoutVideosInput, ShowUncheckedCreateWithoutVideosInput>
    where?: ShowWhereInput
  }

  export type ShowUpdateToOneWithWhereWithoutVideosInput = {
    where?: ShowWhereInput
    data: XOR<ShowUpdateWithoutVideosInput, ShowUncheckedUpdateWithoutVideosInput>
  }

  export type ShowUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUpdateManyWithoutShowNestedInput
    transcript?: TranscriptUpdateOneWithoutShowNestedInput
    aiShowNote?: AiShowNoteUpdateOneWithoutShowNestedInput
    hosts?: UserUpdateManyWithoutHostedShowsNestedInput
  }

  export type ShowUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUncheckedUpdateManyWithoutShowNestedInput
    transcript?: TranscriptUncheckedUpdateOneWithoutShowNestedInput
    aiShowNote?: AiShowNoteUncheckedUpdateOneWithoutShowNestedInput
    hosts?: UserUncheckedUpdateManyWithoutHostedShowsNestedInput
  }

  export type VideoUpsertWithoutShowsInput = {
    update: XOR<VideoUpdateWithoutShowsInput, VideoUncheckedUpdateWithoutShowsInput>
    create: XOR<VideoCreateWithoutShowsInput, VideoUncheckedCreateWithoutShowsInput>
    where?: VideoWhereInput
  }

  export type VideoUpdateToOneWithWhereWithoutShowsInput = {
    where?: VideoWhereInput
    data: XOR<VideoUpdateWithoutShowsInput, VideoUncheckedUpdateWithoutShowsInput>
  }

  export type VideoUpdateWithoutShowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    published_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    playlists?: PlaylistOnVideoUpdateManyWithoutVideoNestedInput
  }

  export type VideoUncheckedUpdateWithoutShowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    published_at?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    playlists?: PlaylistOnVideoUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: number
    access_token?: string | null
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string
    ip?: string | null
    country?: string | null
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
  }

  export type SessionUpdateWithoutUserInput = {
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type ShowUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUpdateManyWithoutShowNestedInput
    transcript?: TranscriptUpdateOneWithoutShowNestedInput
    aiShowNote?: AiShowNoteUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUpdateManyWithoutShowNestedInput
  }

  export type ShowUncheckedUpdateWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
    guests?: ShowGuestUncheckedUpdateManyWithoutShowNestedInput
    transcript?: TranscriptUncheckedUpdateOneWithoutShowNestedInput
    aiShowNote?: AiShowNoteUncheckedUpdateOneWithoutShowNestedInput
    videos?: ShowVideoUncheckedUpdateManyWithoutShowNestedInput
  }

  export type ShowUncheckedUpdateManyWithoutHostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    youtube_url?: NullableStringFieldUpdateOperationsInput | string | null
    spotify_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_notes?: StringFieldUpdateOperationsInput | string
    hash?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    md_file?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    show_type?: EnumShowTypeFieldUpdateOperationsInput | $Enums.ShowType
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkCreateManyGuestInput = {
    id?: string
    link: string
  }

  export type ShowGuestCreateManyGuestInput = {
    id?: string
    showId: string
    transcriptId?: string | null
  }

  export type SocialLinkUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLinkUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
  }

  export type ShowGuestUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    Show?: ShowUpdateOneRequiredWithoutGuestsNestedInput
    Transcript?: TranscriptUpdateOneWithoutShowGuestNestedInput
  }

  export type ShowGuestUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    showId?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShowGuestUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    showId?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShowGuestCreateManyShowInput = {
    id?: string
    guestId: string
    transcriptId?: string | null
  }

  export type ShowVideoCreateManyShowInput = {
    videoId: string
  }

  export type ShowGuestUpdateWithoutShowInput = {
    id?: StringFieldUpdateOperationsInput | string
    Guest?: GuestUpdateOneRequiredWithoutShowsNestedInput
    Transcript?: TranscriptUpdateOneWithoutShowGuestNestedInput
  }

  export type ShowGuestUncheckedUpdateWithoutShowInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShowGuestUncheckedUpdateManyWithoutShowInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    transcriptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShowVideoUpdateWithoutShowInput = {
    video?: VideoUpdateOneRequiredWithoutShowsNestedInput
  }

  export type ShowVideoUncheckedUpdateWithoutShowInput = {
    videoId?: StringFieldUpdateOperationsInput | string
  }

  export type ShowVideoUncheckedUpdateManyWithoutShowInput = {
    videoId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutHostedShowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHostedShowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutHostedShowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    github_id?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TranscriptUtteranceCreateManyTranscriptInput = {
    id?: string
    start: number
    end: number
    confidence: number
    channel: number
    transcript_value: string
    speaker: number
    speakerName?: string | null
  }

  export type ShowGuestCreateManyTranscriptInput = {
    id?: string
    showId: string
    guestId: string
  }

  export type TranscriptUtteranceUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    channel?: IntFieldUpdateOperationsInput | number
    transcript_value?: StringFieldUpdateOperationsInput | string
    speaker?: IntFieldUpdateOperationsInput | number
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    words?: TranscriptUtteranceWordUpdateManyWithoutTranscriptUtteranceNestedInput
  }

  export type TranscriptUtteranceUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    channel?: IntFieldUpdateOperationsInput | number
    transcript_value?: StringFieldUpdateOperationsInput | string
    speaker?: IntFieldUpdateOperationsInput | number
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    words?: TranscriptUtteranceWordUncheckedUpdateManyWithoutTranscriptUtteranceNestedInput
  }

  export type TranscriptUtteranceUncheckedUpdateManyWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    channel?: IntFieldUpdateOperationsInput | number
    transcript_value?: StringFieldUpdateOperationsInput | string
    speaker?: IntFieldUpdateOperationsInput | number
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShowGuestUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    Show?: ShowUpdateOneRequiredWithoutGuestsNestedInput
    Guest?: GuestUpdateOneRequiredWithoutShowsNestedInput
  }

  export type ShowGuestUncheckedUpdateWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    showId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
  }

  export type ShowGuestUncheckedUpdateManyWithoutTranscriptInput = {
    id?: StringFieldUpdateOperationsInput | string
    showId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptUtteranceWordCreateManyTranscriptUtteranceInput = {
    id?: string
    word: string
    start: number
    end: number
    confidence: number
    speaker: number
    speaker_confidence: number
    punctuated_word: string
  }

  export type TranscriptUtteranceWordUpdateWithoutTranscriptUtteranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    speaker?: IntFieldUpdateOperationsInput | number
    speaker_confidence?: FloatFieldUpdateOperationsInput | number
    punctuated_word?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptUtteranceWordUncheckedUpdateWithoutTranscriptUtteranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    speaker?: IntFieldUpdateOperationsInput | number
    speaker_confidence?: FloatFieldUpdateOperationsInput | number
    punctuated_word?: StringFieldUpdateOperationsInput | string
  }

  export type TranscriptUtteranceWordUncheckedUpdateManyWithoutTranscriptUtteranceInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    start?: FloatFieldUpdateOperationsInput | number
    end?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    speaker?: IntFieldUpdateOperationsInput | number
    speaker_confidence?: FloatFieldUpdateOperationsInput | number
    punctuated_word?: StringFieldUpdateOperationsInput | string
  }

  export type AiSummaryEntryCreateManyAiShowNoteInput = {
    id?: number
    time: string
    text: string
    description?: string | null
  }

  export type AiTweetCreateManyAiShowNoteInput = {
    id?: number
    content: string
  }

  export type LinkCreateManyAiShowNoteInput = {
    id?: number
    name: string
    url: string
    timestamp?: string | null
  }

  export type AiGuestCreateManyAiShowNoteInput = {
    id?: number
    name: string
  }

  export type TopicCreateManyAiShowNoteInput = {
    id?: number
    name: string
  }

  export type AiSummaryEntryUpdateWithoutAiShowNoteInput = {
    time?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiSummaryEntryUncheckedUpdateWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiSummaryEntryUncheckedUpdateManyWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiTweetUpdateWithoutAiShowNoteInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type AiTweetUncheckedUpdateWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
  }

  export type AiTweetUncheckedUpdateManyWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
  }

  export type LinkUpdateWithoutAiShowNoteInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LinkUncheckedUpdateWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LinkUncheckedUpdateManyWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiGuestUpdateWithoutAiShowNoteInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AiGuestUncheckedUpdateWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AiGuestUncheckedUpdateManyWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUpdateWithoutAiShowNoteInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateManyWithoutAiShowNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistOnVideoCreateManyVideoInput = {
    playlist_id: string
    order: number
  }

  export type ShowVideoCreateManyVideoInput = {
    showId: string
  }

  export type PlaylistOnVideoUpdateWithoutVideoInput = {
    order?: IntFieldUpdateOperationsInput | number
    playlist?: PlaylistUpdateOneRequiredWithoutVideosNestedInput
  }

  export type PlaylistOnVideoUncheckedUpdateWithoutVideoInput = {
    playlist_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PlaylistOnVideoUncheckedUpdateManyWithoutVideoInput = {
    playlist_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ShowVideoUpdateWithoutVideoInput = {
    show?: ShowUpdateOneRequiredWithoutVideosNestedInput
  }

  export type ShowVideoUncheckedUpdateWithoutVideoInput = {
    showId?: StringFieldUpdateOperationsInput | string
  }

  export type ShowVideoUncheckedUpdateManyWithoutVideoInput = {
    showId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaylistOnVideoCreateManyPlaylistInput = {
    video_id: string
    order: number
  }

  export type PlaylistOnVideoUpdateWithoutPlaylistInput = {
    order?: IntFieldUpdateOperationsInput | number
    video?: VideoUpdateOneRequiredWithoutPlaylistsNestedInput
  }

  export type PlaylistOnVideoUncheckedUpdateWithoutPlaylistInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PlaylistOnVideoUncheckedUpdateManyWithoutPlaylistInput = {
    video_id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}